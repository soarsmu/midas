commit_id,repo,partition,diff,label,PL,LOC_MOD,filename
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -21,6 +21,7 @@ package org.jooby;
 import static com.google.common.base.Preconditions.checkArgument;
 import static java.util.Objects.requireNonNull;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
@@ -29,6 +30,7 @@ import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
@@ -66,7 +68,7 @@ import javaslang.control.Try.CheckedConsumer;
 public interface Env extends LifeCycle {
 
   /**
-   * Utility class for generated {@link Key} for named services.
+   * Utility class for generating {@link Key} for named services.
    *
    * @author edgar
    */
@@ -139,6 +141,8 @@ public interface Env extends LifeCycle {
 
       private ImmutableList.Builder<CheckedConsumer<Registry>> shutdown = ImmutableList.builder();
 
+      private Map<String, Function<String, String>> xss = new HashMap<>();
+
       private ServiceKey key = new ServiceKey();
 
       @Override
@@ -195,6 +199,18 @@ public interface Env extends LifeCycle {
       public List<CheckedConsumer<Registry>> startTasks() {
         return this.start.build();
       }
+
+      @Override
+      public Map<String, Function<String, String>> xss() {
+        return Collections.unmodifiableMap(xss);
+      }
+
+      @Override
+      public Env xss(final String name, final Function<String, String> escaper) {
+        xss.put(requireNonNull(name, ""Name required.""),
+            requireNonNull(escaper, ""Function required.""));
+        return this;
+      }
     };
   };
 
@@ -228,7 +244,6 @@ public interface Env extends LifeCycle {
     return new ServiceKey();
   }
 
-
   /**
    * Returns a string with all substitutions (the <code>${foo.bar}</code> syntax,
    * see <a href=""https://github.com/typesafehub/config/blob/master/HOCON.md"">the
@@ -423,6 +438,20 @@ public interface Env extends LifeCycle {
     return match().option(API.Case(predicate, result));
   }
 
+  /**
+   * @return XSS escape functions.
+   */
+  Map<String, Function<String, String>> xss();
+
+  /**
+   * Set/override a XSS escape function.
+   *
+   * @param name Escape's name.
+   * @param escaper Escape function.
+   * @return This environment.
+   */
+  Env xss(String name, Function<String, String> escaper);
+
   /**
    * @return List of start tasks.
    */
",1,java,16.0,Env.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -39,17 +39,11 @@ import java.util.regex.Pattern;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 
 import org.apache.poi.util.ReplacingInputStream;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.ActivityCode;
 import net.sf.mpxj.ActivityCodeContainer;
@@ -84,6 +78,7 @@ import net.sf.mpxj.TimeUnit;
 import net.sf.mpxj.common.BooleanHelper;
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.primavera.schema.APIBusinessObjects;
 import net.sf.mpxj.primavera.schema.ActivityCodeType;
@@ -265,25 +260,12 @@ public final class PrimaveraPMFileReader extends AbstractProjectReader
    {
       try
       {
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
          if (CONTEXT == null)
          {
             throw CONTEXT_EXCEPTION;
          }
 
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(configureInputSource(stream));
-
-         return (APIBusinessObjects) unmarshallerHandler.getResult();
+         return (APIBusinessObjects) UnmarshalHelper.unmarshal(CONTEXT, configureInputSource(stream), new NamespaceFilter(), false);
       }
 
       catch (ParserConfigurationException ex)
",1,java,20.0,PrimaveraPMFileReader.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -25,7 +25,6 @@
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -36,16 +35,9 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.DateRange;
 import net.sf.mpxj.Duration;
@@ -65,6 +57,7 @@
 import net.sf.mpxj.Task;
 import net.sf.mpxj.TimeUnit;
 import net.sf.mpxj.common.AlphanumComparator;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.conceptdraw.schema.Document;
 import net.sf.mpxj.conceptdraw.schema.Document.Calendars.Calendar;
 import net.sf.mpxj.conceptdraw.schema.Document.Calendars.Calendar.ExceptedDays.ExceptedDay;
@@ -99,6 +92,11 @@
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_calendarMap = new HashMap<>();
@@ -113,23 +111,7 @@
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(new InputSource(new InputStreamReader(stream)));
-         Document cdp = (Document) unmarshallerHandler.getResult();
+         Document cdp = (Document) UnmarshalHelper.unmarshal(CONTEXT, stream, new NamespaceFilter());
          readProjectProperties(cdp);
          readCalendars(cdp);",1,java,28.0,src/main/java/net/sf/mpxj/conceptdraw/ConceptDrawProjectReader.java
1a1d6ca1bc3ae840238dc345fa1eb2c7c28c8cb,apache/hive,train,"@@ -63,7 +63,7 @@ public static void setHiveConfWhiteList(HiveConf hiveConf) throws HiveAuthzPlugi
     String curBlackList = hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST);
     if (curBlackList == null || curBlackList.trim().isEmpty()) {
-      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, ""reflect,reflect2,java_method"");
+      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, ""reflect,reflect2,java_method,in_file"");
     }
   }",1,java,2.0,SettableConfigUpdater.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,train,"@@ -0,0 +1,96 @@
+/*
+ * To the extent possible under law, Kevin Locke has waived all copyright and
+ * related or neighboring rights to this work.
+ * <p/>
+ * A legal description of this waiver is available in <a href=""https://gist.github.com/kevinoid/3829665"">LICENSE.txt</a>
+ */
+package org.asynchttpclient.util;
+
+import sun.security.util.HostnameChecker;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.kerberos.KerberosPrincipal;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * Uses the internal HostnameChecker to verify the server's hostname matches with the
+ * certificate.  This is a requirement for HTTPS, but the raw SSLEngine does not have
+ * this functionality.  As such, it has to be added in manually.  For a more complete
+ * description of hostname verification and why it's important,
+ * please read
+ * <a href=""http://tersesystems.com/2014/03/23/fixing-hostname-verification/"">Fixing
+ * Hostname Verification</a>.
+ * <p/>
+ * This code is based on Kevin Locke's <a href=""http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/"">guide</a> .
+ * <p/>
+
+ */
+public class DefaultHostnameVerifier implements HostnameVerifier {
+
+    private HostnameVerifier extraHostnameVerifier;
+
+    public DefaultHostnameVerifier() {
+    }
+
+    public DefaultHostnameVerifier(HostnameVerifier extraHostnameVerifier) {
+        this.extraHostnameVerifier = extraHostnameVerifier;
+    }
+
+    private boolean hostnameMatches(String hostname, SSLSession session) {
+        HostnameChecker checker =
+                HostnameChecker.getInstance(HostnameChecker.TYPE_TLS);
+
+        boolean validCertificate = false, validPrincipal = false;
+        try {
+            Certificate[] peerCertificates = session.getPeerCertificates();
+
+            if (peerCertificates.length > 0 &&
+                    peerCertificates[0] instanceof X509Certificate) {
+                X509Certificate peerCertificate =
+                        (X509Certificate) peerCertificates[0];
+
+                try {
+                    checker.match(hostname, peerCertificate);
+                    // Certificate matches hostname
+                    validCertificate = true;
+                } catch (CertificateException ex) {
+                    // Certificate does not match hostname
+                }
+            } else {
+                // Peer does not have any certificates or they aren't X.509
+            }
+        } catch (SSLPeerUnverifiedException ex) {
+            // Not using certificates for peers, try verifying the principal
+            try {
+                Principal peerPrincipal = session.getPeerPrincipal();
+                if (peerPrincipal instanceof KerberosPrincipal) {
+                    validPrincipal = HostnameChecker.match(hostname,
+                            (KerberosPrincipal) peerPrincipal);
+                } else {
+                    // Can't verify principal, not Kerberos
+                }
+            } catch (SSLPeerUnverifiedException ex2) {
+                // Can't verify principal, no principal
+            }
+        }
+
+        return validCertificate || validPrincipal;
+    }
+
+    public boolean verify(String hostname, SSLSession session) {
+        if (hostnameMatches(hostname, session)) {
+            return true;
+        } else {
+            if (extraHostnameVerifier != null) {
+                return extraHostnameVerifier.verify(hostname, session);
+            } else {
+                return false;
+            }
+        }
+    }
+}
From fa056c572ab0c9b6edd05a7cc508898f35cc90d5 Mon Sep 17 00:00:00 2001
From: Will Sargent <will.sargent@gmail.com>
Date: Mon, 24 Mar 2014 23:25:44 -0700
Subject: [PATCH 2/3] Use reflection to avoid the ""not part of JDK"" error
 running tests.
---
 .../AsyncHttpClientConfigBean.java            |  8 +-
 .../util/DefaultHostnameVerifier.java         | 73 ++++++++++++++++---
 2 files changed, 65 insertions(+), 16 deletions(-)",1,java,60.0,api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2020, PostgreSQL Global Development Group
+ * See the LICENSE file in the project root for more information.
+ */
+
+package org.postgresql.xml;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.SAXParseException;
+
+/**
+ * Error handler that silently suppresses all errors.
+ */
+public class NullErrorHandler implements ErrorHandler {
+  public static final NullErrorHandler INSTANCE = new NullErrorHandler();
+
+  public void error(SAXParseException e) {
+  }
+
+  public void fatalError(SAXParseException e) {
+  }
+
+  public void warning(SAXParseException e) {
+  }
+}",1,java,13.0,pgjdbc/src/main/java/org/postgresql/xml/NullErrorHandler.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -661,6 +661,17 @@
     ""false"",
     ""Use SPNEGO in SSPI authentication requests""),
+  /**
+   * Factory class to instantiate factories for XML processing.
+   * The default factory disables external entity processing.
+   * Legacy behavior with external entity processing can be enabled by specifying a value of LEGACY_INSECURE.
+   * Or specify a custom class that implements {@code org.postgresql.xml.PGXmlFactoryFactory}.
+   */
+  XML_FACTORY_FACTORY(
+    ""xmlFactoryFactory"",
+    """",
+    ""Factory class to instantiate factories for XML processing""),
+
   ;
   private final String name;",1,java,5.0,pgjdbc/src/main/java/org/postgresql/PGProperty.java
0a78612f981c541ad2d997e6a365f2a0b3e799d9,cloudfoundry/uaa,train,"@@ -0,0 +1,65 @@
+package org.cloudfoundry.identity.uaa.security;
+
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+public class X509ExpiryCheckingTrustManager implements X509TrustManager {
+
+    private X509TrustManager delegate;
+
+    public X509ExpiryCheckingTrustManager() {
+        try {
+            TrustManagerFactory tmf;
+            tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init((KeyStore) null);
+            X509TrustManager x509Tm = null;
+            for (TrustManager tm : tmf.getTrustManagers()) {
+                if (tm instanceof X509TrustManager) {
+                    x509Tm = (X509TrustManager) tm;
+                    break;
+                }
+            }
+            delegate = x509Tm;
+        } catch (NoSuchAlgorithmException | KeyStoreException e) {
+        }
+    }
+
+    protected void setDelegate(X509TrustManager delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
+        if (delegate == null) {
+            throw new CertificateException();
+        } else {
+            delegate.checkClientTrusted(x509Certificates, s);
+        }
+    }
+
+    @Override
+    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
+        if (delegate == null) {
+            throw new CertificateException();
+        } else {
+            delegate.checkServerTrusted(x509Certificates, s);
+        }
+        for (X509Certificate certificate : x509Certificates) {
+            certificate.checkValidity();
+        }
+    }
+
+    @Override
+    public X509Certificate[] getAcceptedIssuers() {
+        if (delegate != null) {
+            return delegate.getAcceptedIssuers();
+        }
+        return new X509Certificate[0];
+    }
+}",1,java,58.0,X509ExpiryCheckingTrustManager.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -173,4 +173,11 @@ int checkInt(int value, int min, int max, int defaultValue) {
     return defaultValue;
   }
+  public boolean isAdminServiceAccessControlEnabled() {
+    return getBooleanProperty(""admin-service.access.control.enabled"", false);
+  }
+
+  public String getAdminServiceAccessTokens() {
+    return getValue(""admin-service.access.tokens"");
+  }
 }",1,java,7.0,apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/config/BizConfig.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -47,12 +47,6 @@ public class AuthorisedGetCaseViewOperation extends AbstractAuthorisedCaseViewOp
         return filterUpsertAccess(caseType, userRoles, caseView);
     }
 
-    @Override
-    @Deprecated
-    public CaseView execute(String jurisdictionId, String caseTypeId, String caseReference) {
-        return execute(caseReference);
-    }
-
     private CaseView filterUpsertAccess(CaseType caseType, Set<String> userRoles, CaseView caseView) {
         CaseViewTrigger[] authorisedTriggers;
         if (!getAccessControlService().canAccessCaseTypeWithCriteria(caseType,
",1,java,6.0,AuthorisedGetCaseViewOperation.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -4,16 +4,5 @@ import uk.gov.hmcts.ccd.domain.model.aggregated.CaseView;
 
 public interface GetCaseViewOperation {
 
-    /**
-     *
-     * @param jurisdictionId
-     * @param caseTypeId
-     * @param caseReference
-     * @return When found, case for given reference, formatted for display
-     * @deprecated Use {@link #execute(String)} instead
-     */
-    @Deprecated
-    CaseView execute(String jurisdictionId, String caseTypeId, String caseReference);
-
     CaseView execute(String caseReference);
 }
",1,java,3.0,GetCaseViewOperation.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -321,12 +321,25 @@ public static int getLeafIndex(long index, int xmssTreeHeight)
         return out.toByteArray();
     }
-    public static Object deserialize(byte[] data)
+    public static Object deserialize(byte[] data, Class clazz)
         throws IOException, ClassNotFoundException
     {
         ByteArrayInputStream in = new ByteArrayInputStream(data);
         ObjectInputStream is = new ObjectInputStream(in);
-        return is.readObject();
+        Object obj = is.readObject();
+
+        if (is.available() != 0)
+        {
+            throw new IOException(""unexpected data found at end of ObjectInputStream"");
+        }
+        if (clazz.isInstance(obj))
+        {
+            return obj;
+        }
+        else
+        {
+            throw new IOException(""unexpected class found in ObjectInputStream"");
+        }
     }
     public static int calculateTau(int index, int height)",1,java,16.0,core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSUtil.java
ce5c3e8079d64929abb76ec3ec7ac7c71a4a26b6,dotCMS/core,train,"@@ -438,7 +438,18 @@ public static String getStringProperty (String name) {
 	    _refreshProperties ();
 	    return props.getStringArray(name);
 	}
-
+	
+	/**
+	 * If config value == null, returns the default
+	 * @param name
+	 * @param defaultValue
+	 * @return
+	 */
+  public static String[] getStringArrayProperty (String name, String[] defaultValue) {
+      _refreshProperties ();
+      
+      return props.containsKey(name) ? props.getStringArray(name) : defaultValue;
+  }",1,java,5.0,dotCMS/src/main/java/com/dotmarketing/util/Config.java
c014f78b148685527c5646b1204cd7f595005afa,bcgit/bc-java,train,"@@ -0,0 +1,92 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.DERTaggedObject;
+
+/**
+ * The OtherName object.
+ * <pre>
+ * OtherName ::= SEQUENCE {
+ *      type-id    OBJECT IDENTIFIER,
+ *      value      [0] EXPLICIT ANY DEFINED BY type-id }
+ * </pre>
+ */
+public class OtherName
+    extends ASN1Object
+{
+    private final ASN1ObjectIdentifier typeID;
+    private final ASN1Encodable value;
+
+    /**
+     * OtherName factory method.
+     * @param obj the object used to construct an instance of <code>
+     * OtherName</code>. It must be an instance of <code>OtherName
+     * </code> or <code>ASN1Sequence</code>.
+     * @return the instance of <code>OtherName</code> built from the
+     * supplied object.
+     * @throws java.lang.IllegalArgumentException if the object passed
+     * to the factory is not an instance of <code>OtherName</code> or something that
+     * can be converted into an appropriate <code>ASN1Sequence</code>.
+     */
+    public static OtherName getInstance(
+        Object obj)
+    {
+
+        if (obj instanceof OtherName)
+        {
+            return (OtherName)obj;
+        }
+        else if (obj != null)
+        {
+            return new OtherName(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    /**
+     * Base constructor.
+     * @param typeID the type of the other name.
+     * @param value the ANY object that represents the value.
+     */
+    public OtherName(
+        ASN1ObjectIdentifier typeID,
+        ASN1Encodable value)
+    {
+        this.typeID = typeID;
+        this.value  = value;
+    }
+
+    private OtherName(ASN1Sequence seq)
+    {
+        this.typeID = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));
+        this.value = ASN1TaggedObject.getInstance(seq.getObjectAt(1)).getObject(); // explicitly tagged
+    }
+
+    public ASN1ObjectIdentifier getTypeID()
+    {
+        return typeID;
+    }
+
+    public ASN1Encodable getValue()
+    {
+        return value;
+    }
+
+    public ASN1Primitive toASN1Primitive()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(typeID);
+        v.add(new DERTaggedObject(true, 0, value));
+
+        return new DERSequence(v);
+    }
+}
",1,java,57.0,OtherName.java
1a1d6ca1bc3ae840238dc345fa1eb2c7c28c8cb,apache/hive,train,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.ql.security.authorization.plugin.fallback;
+
+import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hadoop.hive.ql.security.HiveAuthenticationProvider;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthorizer;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthorizerFactory;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthzPluginException;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthzSessionContext;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveMetastoreClientFactory;
+
+public class FallbackHiveAuthorizerFactory implements HiveAuthorizerFactory {
+  @Override
+  public HiveAuthorizer createHiveAuthorizer(HiveMetastoreClientFactory metastoreClientFactory,
+                                             HiveConf conf, HiveAuthenticationProvider authenticator,
+                                             HiveAuthzSessionContext ctx) {
+    return new FallbackHiveAuthorizer(conf, authenticator, ctx);
+  }
+}",1,java,17.0,FallbackHiveAuthorizerFactory.java
efad4cca2d7d461f5f8c08a0d7b51fabeb82d0a,apache/storm,train,"@@ -861,52 +861,9 @@ public class Utils {
-    public static void unJar(File jarFile, File toDir)
-            throws IOException {
-        JarFile jar = new JarFile(jarFile);
-        try {
-            Enumeration<JarEntry> entries = jar.entries();
-            while (entries.hasMoreElements()) {
-                final JarEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = jar.getInputStream(entry);
-                    try {
-                        File file = new File(toDir, entry.getName());
-                        ensureDirectory(file.getParentFile());
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            copyBytes(in, out, 8192);
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            jar.close();
-        }
-    }
-
-    /**
-     * Copies from one stream to another.
-     *
-     * @param in InputStream to read from
-     * @param out OutputStream to write to
-     * @param buffSize the size of the buffer
-     */
-    public static void copyBytes(InputStream in, OutputStream out, int buffSize)
-            throws IOException {
-        PrintStream ps = out instanceof PrintStream ? (PrintStream)out : null;
-        byte buf[] = new byte[buffSize];
-        int bytesRead = in.read(buf);
-        while (bytesRead >= 0) {
-            out.write(buf, 0, bytesRead);
-            if ((ps != null) && ps.checkError()) {
-                throw new IOException(""Unable to write to output stream."");
-            }
-            bytesRead = in.read(buf);
+    public static void unJar(File jarFile, File toDir) throws IOException {
+        try (JarFile jar = new JarFile(jarFile)) {
+            extractZipFile(jar, toDir, null);
         }
     }
@@ -930,20 +887,17 @@ public class Utils {
+     * @param symlinksDisabled true if symlinks should be disabled, else false.
-    public static void unTar(File inFile, File untarDir) throws IOException {
-        if (!untarDir.mkdirs()) {
-            if (!untarDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create "" + untarDir);
-            }
-        }
+    public static void unTar(File inFile, File untarDir, boolean symlinksDisabled) throws IOException {
+        ensureDirectory(untarDir);
         boolean gzipped = inFile.toString().endsWith(""gz"");
-        if (isOnWindows()) {
+        if (Utils.isOnWindows() || symlinksDisabled) {
-            unTarUsingJava(inFile, untarDir, gzipped);
+            unTarUsingJava(inFile, untarDir, gzipped, symlinksDisabled);
         } else {
@@ -980,7 +934,9 @@ public class Utils {
     }
     private static void unTarUsingJava(File inFile, File untarDir,
-                                       boolean gzipped) throws IOException {
+                                       boolean gzipped, boolean symlinksDisabled) throws IOException {
+        final String base = untarDir.getCanonicalPath();
+        LOG.trace(""java untar {} to {}"", inFile, base);
         InputStream inputStream = null;
         try {
             if (gzipped) {
@@ -991,7 +947,7 @@ public class Utils {
             }
             try (TarArchiveInputStream tis = new TarArchiveInputStream(inputStream)) {
                 for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null; ) {
-                    unpackEntries(tis, entry, untarDir);
+                    unpackEntries(tis, entry, untarDir, base, symlinksDisabled);
                     entry = tis.getNextTarEntry();
                 }
             }
@@ -1003,35 +959,82 @@ public class Utils {
     }
     private static void unpackEntries(TarArchiveInputStream tis,
-                                      TarArchiveEntry entry, File outputDir) throws IOException {
+                                      TarArchiveEntry entry, File outputDir, final String base,
+                                      boolean symlinksDisabled) throws IOException {
+        File target = new File(outputDir, entry.getName());
+        String found = target.getCanonicalPath();
+        if (!found.startsWith(base)) {
+            LOG.error(""Invalid location {} is outside of {}"", found, base);
+            return;
+        }
         if (entry.isDirectory()) {
-            File subDir = new File(outputDir, entry.getName());
-            if (!subDir.mkdirs() && !subDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                        + outputDir);
-            }
+            LOG.trace(""Extracting dir {}"", target);
+            ensureDirectory(target);
             for (TarArchiveEntry e : entry.getDirectoryEntries()) {
-                unpackEntries(tis, e, subDir);
+                unpackEntries(tis, e, target, base, symlinksDisabled);
             }
-            return;
+        } else if (entry.isSymbolicLink()) {
+            if (symlinksDisabled) {
+                LOG.info(""Symlinks disabled skipping {}"", target);
+            } else {
+                Path src = target.toPath();
+                Path dest = Paths.get(entry.getLinkName());
+                LOG.trace(""Extracting sym link {} to {}"", target, dest);
+                // Create symbolic link relative to tar parent dir
+                Files.createSymbolicLink(src, dest);
+            }
+        } else if (entry.isFile()) {
+            LOG.trace(""Extracting file {}"", target);
+            ensureDirectory(target.getParentFile());
+            try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
+                IOUtils.copy(tis, outputStream);
+            }
+        } else {
+            LOG.error(""{} is not a currently supported tar entry type."", entry);
         }
-        File outputFile = new File(outputDir, entry.getName());
-        if (!outputFile.getParentFile().exists()) {
-            if (!outputFile.getParentFile().mkdirs()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                                      + outputDir);
+
+        Path p = target.toPath();
+        if (Files.exists(p)) {
+            try {
+                //We created it so lets chmod it properly
+                int mode = entry.getMode();
+                Files.setPosixFilePermissions(p, parsePerms(mode));
+            } catch (UnsupportedOperationException e) {
+                //Ignored the file system we are on does not support this, so don't do it.
             }
         }
-        int count;
-        byte data[] = new byte[2048];
-        BufferedOutputStream outputStream = new BufferedOutputStream(
-                new FileOutputStream(outputFile));
+    }
-        while ((count = tis.read(data)) != -1) {
-            outputStream.write(data, 0, count);
+    private static Set<PosixFilePermission> parsePerms(int mode) {
+        Set<PosixFilePermission> ret = new HashSet<>();
+        if ((mode & 0001) > 0) {
+            ret.add(PosixFilePermission.OTHERS_EXECUTE);
+        }
+        if ((mode & 0002) > 0) {
+            ret.add(PosixFilePermission.OTHERS_WRITE);
+        }
+        if ((mode & 0004) > 0) {
+            ret.add(PosixFilePermission.OTHERS_READ);
+        }
+        if ((mode & 0010) > 0) {
+            ret.add(PosixFilePermission.GROUP_EXECUTE);
+        }
+        if ((mode & 0020) > 0) {
+            ret.add(PosixFilePermission.GROUP_WRITE);
         }
-        outputStream.flush();
-        outputStream.close();
+        if ((mode & 0040) > 0) {
+            ret.add(PosixFilePermission.GROUP_READ);
+        }
+        if ((mode & 0100) > 0) {
+            ret.add(PosixFilePermission.OWNER_EXECUTE);
+        }
+        if ((mode & 0200) > 0) {
+            ret.add(PosixFilePermission.OWNER_WRITE);
+        }
+        if ((mode & 0400) > 0) {
+            ret.add(PosixFilePermission.OWNER_READ);
+        }
+        return ret;
     }
     public static boolean isOnWindows() {
@@ -1045,16 +1048,21 @@ public class Utils {
         return Paths.get(path).isAbsolute();
     }
-    public static void unpack(File localrsrc, File dst) throws IOException {
+    public static void unpack(File localrsrc, File dst, boolean symLinksDisabled) throws IOException {
         String lowerDst = localrsrc.getName().toLowerCase();
-        if (lowerDst.endsWith("".jar"")) {
+        if (lowerDst.endsWith("".jar"") ||
+            lowerDst.endsWith(""_jar"")) {
             unJar(localrsrc, dst);
-        } else if (lowerDst.endsWith("".zip"")) {
+        } else if (lowerDst.endsWith("".zip"") ||
+            lowerDst.endsWith(""_zip"")) {
             unZip(localrsrc, dst);
         } else if (lowerDst.endsWith("".tar.gz"") ||
-                lowerDst.endsWith("".tgz"") ||
-                lowerDst.endsWith("".tar"")) {
-            unTar(localrsrc, dst);
+            lowerDst.endsWith(""_tar_gz"") ||
+            lowerDst.endsWith("".tgz"") ||
+            lowerDst.endsWith(""_tgz"") ||
+            lowerDst.endsWith("".tar"") ||
+            lowerDst.endsWith(""_tar"")) {
+            unTar(localrsrc, dst, symLinksDisabled);
         } else {
             LOG.warn(""Cannot unpack "" + localrsrc);
             if (!localrsrc.renameTo(dst)) {
@@ -1067,6 +1075,35 @@ public class Utils {
         }
     }
+    private static void extractZipFile(ZipFile zipFile, File toDir, String prefix) throws IOException {
+        ensureDirectory(toDir);
+        final String base = toDir.getCanonicalPath();
+
+        Enumeration<? extends ZipEntry> entries = zipFile.entries();
+        while (entries.hasMoreElements()) {
+            ZipEntry entry = entries.nextElement();
+            if (!entry.isDirectory()) {
+                if (prefix != null && !entry.getName().startsWith(prefix)) {
+                    //No need to extract it, it is not what we are looking for.
+                    continue;
+                }
+                File file = new File(toDir, entry.getName());
+                String found = file.getCanonicalPath();
+                if (!found.startsWith(base)) {
+                    LOG.error(""Invalid location {} is outside of {}"", found, base);
+                    continue;
+                }
+
+                try (InputStream in = zipFile.getInputStream(entry)) {
+                    ensureDirectory(file.getParentFile());
+                    try (OutputStream out = new FileOutputStream(file)) {
+                        IOUtils.copy(in, out);
+                    }
+                }
+            }
+        }
+    }
+
     public static boolean canUserReadBlob(ReadableBlobMeta meta, String user) {
         SettableBlobMeta settable = meta.get_settable();
         for (AccessControl acl : settable.get_acl()) {
@@ -1398,45 +1435,12 @@ public class Utils {
-     * @param unzipDir The unzip directory where to unzip the zip file.
+     * @param toDir The unzip directory where to unzip the zip file.
-    public static void unZip(File inFile, File unzipDir) throws IOException {
-        Enumeration<? extends ZipEntry> entries;
-        ZipFile zipFile = new ZipFile(inFile);
-
-        try {
-            entries = zipFile.entries();
-            while (entries.hasMoreElements()) {
-                ZipEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = zipFile.getInputStream(entry);
-                    try {
-                        File file = new File(unzipDir, entry.getName());
-                        if (!file.getParentFile().mkdirs()) {
-                            if (!file.getParentFile().isDirectory()) {
-                                throw new IOException(""Mkdirs failed to create "" +
-                                                      file.getParentFile().toString());
-                            }
-                        }
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            byte[] buffer = new byte[8192];
-                            int i;
-                            while ((i = in.read(buffer)) != -1) {
-                                out.write(buffer, 0, i);
-                            }
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            zipFile.close();
-        }
+    public static void unZip(File inFile, File toDir) throws IOException {
+        try (ZipFile zipFile = new ZipFile(inFile)) {
+            extractZipFile(zipFile, toDir, null);        }
     }
@@ -1910,21 +1914,10 @@ public class Utils {
     public static void extractDirFromJar(String jarpath, String dir, File destdir) {
         _instance.extractDirFromJarImpl(jarpath, dir, destdir);
     }
-    
+
     public void extractDirFromJarImpl(String jarpath, String dir, File destdir) {
         try (JarFile jarFile = new JarFile(jarpath)) {
-            Enumeration<JarEntry> jarEnums = jarFile.entries();
-            while (jarEnums.hasMoreElements()) {
-                JarEntry entry = jarEnums.nextElement();
-                if (!entry.isDirectory() && entry.getName().startsWith(dir)) {
-                    File aFile = new File(destdir, entry.getName());
-                    aFile.getParentFile().mkdirs();
-                    try (FileOutputStream out = new FileOutputStream(aFile);
-                         InputStream in = jarFile.getInputStream(entry)) {
-                        IOUtils.copy(in, out);
-                    }
-                }
-            }
+            extractZipFile(jarFile, destdir, dir);
         } catch (IOException e) {
             LOG.info(""Could not extract {} from {}"", dir, jarpath);
         }",1,java,237.0,Utils.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -3,6 +3,7 @@
 import com.ctrip.framework.apollo.configservice.util.AccessKeyUtil;
 import com.ctrip.framework.apollo.core.signature.Signature;
 import com.ctrip.framework.apollo.core.utils.StringUtils;
+import com.google.common.net.HttpHeaders;
 import java.io.IOException;
 import java.util.List;
 import java.util.Objects;
@@ -53,7 +54,7 @@ public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain
     List<String> availableSecrets = accessKeyUtil.findAvailableSecret(appId);
     if (!CollectionUtils.isEmpty(availableSecrets)) {
       String timestamp = request.getHeader(Signature.HTTP_HEADER_TIMESTAMP);
-      String authorization = request.getHeader(Signature.HTTP_HEADER_AUTHORIZATION);
+      String authorization = request.getHeader(HttpHeaders.AUTHORIZATION);
       if (!checkTimestamp(timestamp)) {",1,java,3.0,apollo-configservice/src/main/java/com/ctrip/framework/apollo/configservice/filter/ClientAuthenticationFilter.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -15,101 +15,43 @@
 package com.ning.http.util;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
+import com.ning.http.client.AsyncHttpClientConfig;
+
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
-import java.io.FileInputStream;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
 import java.security.SecureRandom;
-import java.security.Security;
-/**
- * This class is a copy of http://github.com/sonatype/wagon-ning/raw/master/src/main/java/org/apache/maven/wagon/providers/http/SslUtils.java
- */
 public class SslUtils {
-    private static SSLContext context = null;
-
-    public static SSLEngine getSSLEngine()
-            throws GeneralSecurityException, IOException {
-        SSLEngine engine = null;
-
-        SSLContext context = getSSLContext();
-        if (context != null) {
-            engine = context.createSSLEngine();
-            engine.setUseClientMode(true);
-        }
-
-        return engine;
+    private static class SingletonHolder {
+        public static final SslUtils instance = new SslUtils();
     }
-    public static SSLContext getSSLContext()
-            throws GeneralSecurityException, IOException {
-        if (context == null) {
-            SSLConfig config = new SSLConfig();
-            if (config.keyStoreLocation == null
-                    || config.trustStoreLocation == null) {
-                context = getLooseSSLContext();
-            } else {
-                context = getStrictSSLContext(config);
-            }
-        }
-        return context;
+    public static SslUtils getInstance() {
+        return SingletonHolder.instance;
     }
-    static SSLContext getStrictSSLContext(SSLConfig config)
-            throws GeneralSecurityException, IOException {
-        KeyStore keyStore = KeyStore.getInstance(config.keyStoreType);
-        InputStream keystoreInputStream = new FileInputStream(config.keyStoreLocation);
-        try {
-            keyStore.load(keystoreInputStream, (config.keyStorePassword == null) ? null
-                    : config.keyStorePassword.toCharArray());
-        } finally {
-            keystoreInputStream.close();
-        }
-
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(config.keyManagerAlgorithm);
-        keyManagerFactory.init(keyStore, (config.keyManagerPassword == null) ? null
-                : config.keyManagerPassword.toCharArray());
-        KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();
-
-        KeyStore trustStore = KeyStore.getInstance(config.trustStoreType);
-        InputStream truststoreInputStream = new FileInputStream(config.trustStoreLocation);
-        try {
-            trustStore.load(truststoreInputStream, (config.trustStorePassword == null) ? null
-                    : config.trustStorePassword.toCharArray());
-        } finally {
-            truststoreInputStream.close();
+    public SSLEngine createClientSSLEngine(AsyncHttpClientConfig config) throws GeneralSecurityException, IOException {
+        SSLContext sslContext = config.getSSLContext();
+        if (sslContext == null) {
+            sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
         }
-
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(config.trustManagerAlgorithm);
-        trustManagerFactory.init(trustStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        SSLContext context = SSLContext.getInstance(""TLS"");
-        context.init(keyManagers, trustManagers, null);
-
-        return context;
+        SSLEngine sslEngine = sslContext.createSSLEngine();
+        sslEngine.setUseClientMode(true);
+        return sslEngine;
     }
-    static SSLContext getLooseSSLContext()
-            throws GeneralSecurityException {
-        SSLContext sslContext = SSLContext.getInstance(""TLS"");
-        sslContext.init(null, new TrustManager[]{LooseTrustManager.INSTANCE}, new SecureRandom());
-        return sslContext;
+    public SSLContext getSSLContext(boolean acceptAnyCertificate) throws GeneralSecurityException, IOException {
+        // SSLContext.getDefault() doesn't exist in JDK5
+        return acceptAnyCertificate ? looseTrustManagerSSLContext : SSLContext.getInstance(""Default"");
     }
-    static class LooseTrustManager
-            implements X509TrustManager {
-
-        public static final LooseTrustManager INSTANCE = new LooseTrustManager();
+    static class LooseTrustManager implements X509TrustManager {
         public java.security.cert.X509Certificate[] getAcceptedIssuers() {
             return new java.security.cert.X509Certificate[0];
@@ -122,53 +64,15 @@ public void checkServerTrusted(java.security.cert.X509Certificate[] certs, Strin
         }
     }
-    private final static class SSLConfig {
-
-        public String keyStoreLocation;
-
-        public String keyStoreType = ""JKS"";
-
-        public String keyStorePassword = ""changeit"";
-
-        public String keyManagerAlgorithm = ""SunX509"";
-
-        public String keyManagerPassword = ""changeit"";
-
-        public String trustStoreLocation;
-
-        public String trustStoreType = ""JKS"";
+    private SSLContext looseTrustManagerSSLContext = looseTrustManagerSSLContext();
-        public String trustStorePassword = ""changeit"";
-
-        public String trustManagerAlgorithm = ""SunX509"";
-
-        public SSLConfig() {
-            keyStoreLocation = System.getProperty(""javax.net.ssl.keyStore"");
-            keyStorePassword = System.getProperty(""javax.net.ssl.keyStorePassword"", ""changeit"");
-            keyStoreType = System.getProperty(""javax.net.ssl.keyStoreType"", KeyStore.getDefaultType());
-            keyManagerAlgorithm = Security.getProperty(""ssl.KeyManagerFactory.algorithm"");
-
-            if (keyManagerAlgorithm == null) {
-                keyManagerAlgorithm = ""SunX509"";
-            }
-
-            keyManagerPassword = System.getProperty(""javax.net.ssl.keyStorePassword"", ""changeit"");
-
-            trustStoreLocation = System.getProperty(""javax.net.ssl.trustStore"");
-            if (trustStoreLocation == null) {
-                trustStoreLocation = keyStoreLocation;
-                trustStorePassword = keyStorePassword;
-                trustStoreType = keyStoreType;
-            } else {
-                trustStorePassword = System.getProperty(""javax.net.ssl.trustStorePassword"", ""changeit"");
-                trustStoreType = System.getProperty(""javax.net.ssl.trustStoreType"", KeyStore.getDefaultType());
-            }
-            trustManagerAlgorithm = Security.getProperty(""ssl.TrustManagerFactory.algorithm"");
-
-            if (trustManagerAlgorithm == null) {
-                trustManagerAlgorithm = ""SunX509"";
-            }
+    private SSLContext looseTrustManagerSSLContext() {
+        try {
+            SSLContext sslContext = SSLContext.getInstance(""TLS"");
+            sslContext.init(null, new TrustManager[] { new LooseTrustManager() }, new SecureRandom());
+            return sslContext;
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
         }
     }
-
-}
+}
\ No newline at end of file",1,java,119.0,src/main/java/com/ning/http/util/SslUtils.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -51,7 +51,7 @@ public class Entity {
     }
 
     @AllArgsConstructor
-    class Attribute {
+    public class Attribute {
         @Getter private String name;
         @Getter private Object value;
     }
",1,java,2.0,Entity.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -51,7 +51,7 @@ public BCXMSSPrivateKey(PrivateKeyInfo keyInfo)
             if (xmssPrivateKey.getBdsState() != null)
             {
-                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState()));
+                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState(), BDS.class));
             }
             this.keyParams = keyBuilder.build();",1,java,2.0,prov/src/main/java/org/bouncycastle/pqc/jcajce/provider/xmss/BCXMSSPrivateKey.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -0,0 +1,148 @@
+package uk.gov.hmcts.ccd.v2.internal.controller;
+
+import io.swagger.annotations.ApiOperation;
+import io.swagger.annotations.ApiParam;
+import io.swagger.annotations.ApiResponse;
+import io.swagger.annotations.ApiResponses;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Qualifier;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.web.bind.annotation.*;
+import uk.gov.hmcts.ccd.data.draft.CachedDraftGateway;
+import uk.gov.hmcts.ccd.data.draft.DraftGateway;
+import uk.gov.hmcts.ccd.domain.model.aggregated.CaseView;
+import uk.gov.hmcts.ccd.domain.model.std.CaseDataContent;
+import uk.gov.hmcts.ccd.domain.service.aggregated.DefaultGetCaseViewFromDraftOperation;
+import uk.gov.hmcts.ccd.domain.service.aggregated.GetCaseViewOperation;
+import uk.gov.hmcts.ccd.domain.service.upsertdraft.UpsertDraftOperation;
+import uk.gov.hmcts.ccd.v2.V2;
+import uk.gov.hmcts.ccd.v2.internal.resource.UICaseViewResource;
+import uk.gov.hmcts.ccd.v2.internal.resource.UIDraftResource;
+
+import javax.transaction.Transactional;
+import java.time.Duration;
+import java.time.Instant;
+
+import static org.springframework.http.ResponseEntity.status;
+
+@RestController
+@RequestMapping(path = ""/internal"")
+public class UIDraftsController {
+    private static final Logger LOG = LoggerFactory.getLogger(UIDraftsController.class);
+
+    private final UpsertDraftOperation upsertDraftOperation;
+    private final GetCaseViewOperation getDraftViewOperation;
+    private final DraftGateway draftGateway;
+
+    @Autowired
+    public UIDraftsController(
+        @Qualifier(""default"") final UpsertDraftOperation upsertDraftOperation,
+        @Qualifier(DefaultGetCaseViewFromDraftOperation.QUALIFIER) GetCaseViewOperation getDraftViewOperation,
+        @Qualifier(CachedDraftGateway.QUALIFIER) DraftGateway draftGateway
+    ) {
+        this.upsertDraftOperation = upsertDraftOperation;
+        this.getDraftViewOperation = getDraftViewOperation;
+        this.draftGateway = draftGateway;
+    }
+
+    @PostMapping(
+        path = ""/case-types/{ctid}/drafts"",
+        headers = {
+            V2.EXPERIMENTAL_HEADER
+        },
+        produces = {
+            V2.MediaType.UI_DRAFT_CREATE
+        }
+    )
+    @ResponseStatus(HttpStatus.CREATED)
+    @ApiOperation(
+        value = ""Save draft as a caseworker.""
+    )
+    @ApiResponses(value = {
+        @ApiResponse(code = 201, message = ""Draft created""),
+        @ApiResponse(code = 422, message = ""One of: cannot find event in requested case type or unable to sanitize document for case field""),
+        @ApiResponse(code = 500, message = ""Draft store is down."")
+    })
+    public ResponseEntity<UIDraftResource> saveDraft(
+        @ApiParam(value = ""Case type ID"", required = true)
+        @PathVariable(""ctid"") final String caseTypeId,
+        @RequestBody final CaseDataContent caseDataContent) {
+
+        ResponseEntity.BodyBuilder builder = status(HttpStatus.CREATED);
+        return builder.body(new UIDraftResource(upsertDraftOperation.executeSave(caseTypeId, caseDataContent), caseTypeId));
+    }
+
+    @PutMapping(
+        path = ""/case-types/{ctid}/drafts/{did}"",
+        headers = {
+            V2.EXPERIMENTAL_HEADER
+        },
+        produces = {
+            V2.MediaType.UI_DRAFT_UPDATE
+        }
+    )
+    @ResponseStatus(HttpStatus.OK)
+    @ApiOperation(
+        value = ""Update draft as a caseworker.""
+    )
+    @ApiResponses(value = {
+        @ApiResponse(code = 200, message = ""Draft updated""),
+        @ApiResponse(code = 422, message = ""One of: cannot find event in requested case type or unable to sanitize document for case field""),
+        @ApiResponse(code = 500, message = ""Draft store is down."")
+    })
+    public ResponseEntity<UIDraftResource> updateDraft(
+        @PathVariable(""ctid"") final String caseTypeId,
+        @PathVariable(""did"") final String draftId,
+        @RequestBody final CaseDataContent caseDataContent) {
+
+        return ResponseEntity.ok(new UIDraftResource(upsertDraftOperation.executeUpdate(caseTypeId, draftId, caseDataContent), caseTypeId));
+    }
+
+    @Transactional
+    @GetMapping(
+        path = ""/drafts/{did}"",
+        headers = {
+            V2.EXPERIMENTAL_HEADER
+        },
+        produces = {
+            V2.MediaType.UI_DRAFT_READ
+        })
+    @ResponseStatus(HttpStatus.OK)
+    @ApiOperation(value = ""Fetch a draft for display"")
+    @ApiResponses(value = {
+        @ApiResponse(code = 200, message = ""A displayable draft""),
+        @ApiResponse(code = 500, message = ""Draft store is down."")
+    })
+    public ResponseEntity<UICaseViewResource> findDraft(@PathVariable(""did"") final String did) {
+        Instant start = Instant.now();
+        CaseView caseView = getDraftViewOperation.execute(did);
+        final Duration between = Duration.between(start, Instant.now());
+        LOG.info(""findDraft has been completed in {} millisecs..."", between.toMillis());
+        return ResponseEntity.ok(new UICaseViewResource(caseView));
+    }
+
+    @Transactional
+    @DeleteMapping(path = ""/drafts/{did}"",
+        headers = {
+            V2.EXPERIMENTAL_HEADER
+        },
+        produces = {
+            V2.MediaType.UI_DRAFT_DELETE
+        })
+    @ResponseStatus(HttpStatus.OK)
+    @ApiOperation(value = ""Delete a given draft"")
+    @ApiResponses(value = {
+        @ApiResponse(code = 200, message = ""A draft deleted successfully""),
+        @ApiResponse(code = 500, message = ""Draft store is down."")
+    })
+    public ResponseEntity<Void> deleteDraft(@PathVariable(""did"") final String did) {
+        Instant start = Instant.now();
+        draftGateway.delete(did);
+        final Duration between = Duration.between(start, Instant.now());
+        LOG.info(""deleteDraft has been completed in {} millisecs..."", between.toMillis());
+        return ResponseEntity.ok().build();
+    }
+}
",1,java,137.0,UIDraftsController.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -48,7 +48,7 @@ public class GraphQLConversionUtils {
 
     private final Map<Class<?>, GraphQLScalarType> scalarMap = new HashMap<>();
 
-    protected NonEntityDictionary nonEntityDictionary = new NonEntityDictionary();
+    protected NonEntityDictionary nonEntityDictionary;
     protected EntityDictionary entityDictionary;
 
     private final Map<Class, GraphQLObjectType> outputConversions = new HashMap<>();
@@ -56,8 +56,9 @@ public class GraphQLConversionUtils {
     private final Map<Class, GraphQLEnumType> enumConversions = new HashMap<>();
     private final Map<String, GraphQLList> mapConversions = new HashMap<>();
 
-    public GraphQLConversionUtils(EntityDictionary dictionary) {
-        this.entityDictionary = dictionary;
+    public GraphQLConversionUtils(EntityDictionary entityDictionary, NonEntityDictionary nonEntityDictionary) {
+        this.entityDictionary = entityDictionary;
+        this.nonEntityDictionary = nonEntityDictionary;
         registerCustomScalars();
     }
 
",1,java,7.0,GraphQLConversionUtils.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -82,7 +82,14 @@ protected PublicKey engineGeneratePublic(
     {
         if (keySpec instanceof DHPublicKeySpec)
         {
-            return new BCDHPublicKey((DHPublicKeySpec)keySpec);
+            try
+            {
+                return new BCDHPublicKey((DHPublicKeySpec)keySpec);
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new InvalidKeySpecException(e.getMessage(), e);
+            }
         }
         return super.engineGeneratePublic(keySpec);",1,java,9.0,KeyFactorySpi.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -178,26 +178,19 @@ private AsymmetricCipherKeyPair genKeyPair()
         for (int h = numLayer - 1; h >= 0; h--)
         {
-            GMSSRootCalc tree = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);
-            try
-            {
-                // on lowest layer no lower root is available, so just call
-                // the method with null as first parameter
-                if (h == numLayer - 1)
-                {
-                    tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);
-                }
-                else
-                // otherwise call the method with the former computed root
-                // value
-                {
-                    tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);
-                }
+            GMSSRootCalc tree;
+            // on lowest layer no lower root is available, so just call
+            // the method with null as first parameter
+            if (h == numLayer - 1)
+            {
+                tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);
             }
-            catch (Exception e1)
+            else
+            // otherwise call the method with the former computed root
+            // value
             {
-                e1.printStackTrace();
+                tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);
             }",1,java,19.0,GMSSKeyPairGenerator.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -26,104 +26,92 @@
 public class LanguageVariableAPIImpl implements LanguageVariableAPI {
-    private final KeyValueAPI keyValueAPI;
-    private final LanguageAPI languageAPI;
-
-    /**
-     * Creates a new instance of the {@link LanguageVariableAPI}.
-     */
-    public LanguageVariableAPIImpl() {
-        this(APILocator.getKeyValueAPI(), APILocator.getLanguageAPI());
-        
-    }
+  private final KeyValueAPI keyValueAPI;
+  private final LanguageAPI languageAPI;
-    @VisibleForTesting
-    public LanguageVariableAPIImpl(final KeyValueAPI keyValueAPI, final LanguageAPI languageAPI) {
+  /**
+   * Creates a new instance of the {@link LanguageVariableAPI}.
+   */
+  public LanguageVariableAPIImpl() {
+    this(APILocator.getKeyValueAPI(), APILocator.getLanguageAPI());
-        this.keyValueAPI = keyValueAPI;
-        this.languageAPI = languageAPI;
-    }
+  }
-    @Override
-    public String get(final String key, final long languageId,
-                      final User user, final boolean respectFrontendRoles) {
+  @VisibleForTesting
+  public LanguageVariableAPIImpl(final KeyValueAPI keyValueAPI, final LanguageAPI languageAPI) {
-        if(!UtilMethods.isSet(key)) {
-            return null;
-        }
-        String languageValue = null;
+    this.keyValueAPI = keyValueAPI;
+    this.languageAPI = languageAPI;
+  }
-        try {
+  @Override
+  public String get(final String key, final long languageId, final User user, final boolean respectFrontendRoles) {
+
+    if (!UtilMethods.isSet(key)) {
+      return null;
+    }
+    String languageValue = null;
-            // get the content type LANGUAGEVARIABLE
-            final ContentType languageVariableContentType =
-                    APILocator.getContentTypeAPI(user).find(LANGUAGEVARIABLE);
+    try {
-            languageValue = this.getValueFromUserLanguage(key, languageId, user,
-                    respectFrontendRoles, languageVariableContentType);
+      // get the content type LANGUAGEVARIABLE
+      final ContentType languageVariableContentType = APILocator.getContentTypeAPI(user).find(LANGUAGEVARIABLE);
-            if (null == languageValue) {
+      languageValue = this.getValueFromUserLanguage(key, languageId, user, respectFrontendRoles, languageVariableContentType);
-                languageValue = this.getValueFromUserFallbackLanguage(key, languageId, user,
-                        respectFrontendRoles, languageVariableContentType);
+      if (null == languageValue) {
-                if (null == languageValue && languageVariableContentType instanceof MultilinguableFallback &&
-                        MultilinguableFallback.class.cast(languageVariableContentType).fallback()) {
+        languageValue = this.getValueFromUserFallbackLanguage(key, languageId, user, respectFrontendRoles, languageVariableContentType);
-                    languageValue = this.getValueFromDefaultLanguage(key, user,
-                            respectFrontendRoles, languageVariableContentType);
-                }
-            }
-        } catch (DotDataException | DotSecurityException e) {
+        if (null == languageValue && languageVariableContentType instanceof MultilinguableFallback
+            && MultilinguableFallback.class.cast(languageVariableContentType).fallback()) {
-            Logger.debug(this, ()-> String.format(""Could not retrieve Language Variable '%s': %s"", key, e.getMessage(), e));
+          languageValue = this.getValueFromDefaultLanguage(key, user, respectFrontendRoles, languageVariableContentType);
         }
+      }
+    } catch (DotDataException | DotSecurityException e) {
-        return (null != languageValue)? languageValue:key;
+      Logger.debug(this, () -> String.format(""Could not retrieve Language Variable '%s': %s"", key, e.getMessage(), e));
     }
-    @Override
-    public List<KeyValue> getAllLanguageVariablesKeyStartsWith(final String key,
-            final long languageId, final User user, final int limit) throws DotDataException, DotSecurityException {
-        return this.keyValueAPI.getKeyValuesByKeyStartingWith(key,languageId,APILocator.getContentTypeAPI(user).find(LANGUAGEVARIABLE),user,false,limit);
-    }
+    return (null != languageValue) ? languageValue : key;
+  }
-    private String getValueFromUserLanguage(final String key, long languageId,
-                                            final User user, final boolean respectFrontendRoles,
-                                            final ContentType languageVariableContentType) {
+  @Override
+  public List<KeyValue> getAllLanguageVariablesKeyStartsWith(final String key, final long languageId, final User user, final int limit)
+      throws DotDataException, DotSecurityException {
+    return this.keyValueAPI.getKeyValuesByKeyStartingWith(key, languageId, APILocator.getContentTypeAPI(user).find(LANGUAGEVARIABLE), user,
+        false, limit);
+  }
-        final KeyValue keyValue = this.keyValueAPI.get(key, languageId,
-                languageVariableContentType, user, respectFrontendRoles);
-        return (null != keyValue)?keyValue.getValue():null;
-    }
+  private String getValueFromUserLanguage(final String key, long languageId, final User user, final boolean respectFrontendRoles,
+      final ContentType languageVariableContentType) {
-    private String getValueFromUserFallbackLanguage(final String key, long languageId,
-                                            final User user, final boolean respectFrontendRoles,
-                                            final ContentType languageVariableContentType) {
+    final KeyValue keyValue = this.keyValueAPI.get(key, languageId, languageVariableContentType, user, respectFrontendRoles);
+    return (null != keyValue) ? keyValue.getValue() : null;
+  }
-        KeyValue keyValue               = null;
-        final Language fallbackLanguage = this.languageAPI.getFallbackLanguage
-                (this.languageAPI.getLanguage(languageId).getLanguageCode());
+  private String getValueFromUserFallbackLanguage(final String key, long languageId, final User user, final boolean respectFrontendRoles,
+      final ContentType languageVariableContentType) {
-        if (null != fallbackLanguage) {
+    KeyValue keyValue = null;
+    final Language fallbackLanguage = this.languageAPI.getFallbackLanguage(this.languageAPI.getLanguage(languageId).getLanguageCode());
-            keyValue = this.keyValueAPI.get(key, fallbackLanguage.getId(),
-                    languageVariableContentType, user, respectFrontendRoles);
-        }
+    if (null != fallbackLanguage) {
-        return (null != keyValue)?keyValue.getValue():null;
+      keyValue = this.keyValueAPI.get(key, fallbackLanguage.getId(), languageVariableContentType, user, respectFrontendRoles);
     }
-    private String getValueFromDefaultLanguage(final String key, final User user,
-                                               final boolean respectFrontendRoles,
-                                               final ContentType languageVariableContentType) {
+    return (null != keyValue) ? keyValue.getValue() : null;
+  }
-        final KeyValue keyValue  = this.keyValueAPI.get(key,
-                this.languageAPI.getDefaultLanguage().getId(),
-                languageVariableContentType, user, respectFrontendRoles);
+  private String getValueFromDefaultLanguage(final String key, final User user, final boolean respectFrontendRoles,
+      final ContentType languageVariableContentType) {
-        return (null != keyValue)?keyValue.getValue():null;
-    }
+    final KeyValue keyValue =
+        this.keyValueAPI.get(key, this.languageAPI.getDefaultLanguage().getId(), languageVariableContentType, user, respectFrontendRoles);
+    return (null != keyValue) ? keyValue.getValue() : null;
+  }
 }",1,java,119.0,dotCMS/src/main/java/com/dotcms/languagevariable/business/LanguageVariableAPIImpl.java
0fc6b522487c061f89e8cdacf09f722d3f20589,apache/storm,train,"@@ -859,52 +859,9 @@ public class Utils {
-    public static void unJar(File jarFile, File toDir)
-            throws IOException {
-        JarFile jar = new JarFile(jarFile);
-        try {
-            Enumeration<JarEntry> entries = jar.entries();
-            while (entries.hasMoreElements()) {
-                final JarEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = jar.getInputStream(entry);
-                    try {
-                        File file = new File(toDir, entry.getName());
-                        ensureDirectory(file.getParentFile());
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            copyBytes(in, out, 8192);
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            jar.close();
-        }
-    }
-
-    /**
-     * Copies from one stream to another.
-     *
-     * @param in InputStream to read from
-     * @param out OutputStream to write to
-     * @param buffSize the size of the buffer
-     */
-    public static void copyBytes(InputStream in, OutputStream out, int buffSize)
-            throws IOException {
-        PrintStream ps = out instanceof PrintStream ? (PrintStream)out : null;
-        byte buf[] = new byte[buffSize];
-        int bytesRead = in.read(buf);
-        while (bytesRead >= 0) {
-            out.write(buf, 0, bytesRead);
-            if ((ps != null) && ps.checkError()) {
-                throw new IOException(""Unable to write to output stream."");
-            }
-            bytesRead = in.read(buf);
+    public static void unJar(File jarFile, File toDir) throws IOException {
+        try (JarFile jar = new JarFile(jarFile)) {
+            extractZipFile(jar, toDir, null);
         }
     }
@@ -928,20 +885,17 @@ public class Utils {
+     * @param symlinksDisabled true if symlinks should be disabled, else false.
-    public static void unTar(File inFile, File untarDir) throws IOException {
-        if (!untarDir.mkdirs()) {
-            if (!untarDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create "" + untarDir);
-            }
-        }
+    public static void unTar(File inFile, File untarDir, boolean symlinksDisabled) throws IOException {
+        ensureDirectory(untarDir);
         boolean gzipped = inFile.toString().endsWith(""gz"");
-        if (isOnWindows()) {
+        if (Utils.isOnWindows() || symlinksDisabled) {
-            unTarUsingJava(inFile, untarDir, gzipped);
+            unTarUsingJava(inFile, untarDir, gzipped, symlinksDisabled);
         } else {
@@ -978,7 +932,9 @@ public class Utils {
     }
     private static void unTarUsingJava(File inFile, File untarDir,
-                                       boolean gzipped) throws IOException {
+                                       boolean gzipped, boolean symlinksDisabled) throws IOException {
+        final String base = untarDir.getCanonicalPath();
+        LOG.trace(""java untar {} to {}"", inFile, base);
         InputStream inputStream = null;
         try {
             if (gzipped) {
@@ -989,7 +945,7 @@ public class Utils {
             }
             try (TarArchiveInputStream tis = new TarArchiveInputStream(inputStream)) {
                 for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null; ) {
-                    unpackEntries(tis, entry, untarDir);
+                    unpackEntries(tis, entry, untarDir, base, symlinksDisabled);
                     entry = tis.getNextTarEntry();
                 }
             }
@@ -1001,35 +957,82 @@ public class Utils {
     }
     private static void unpackEntries(TarArchiveInputStream tis,
-                                      TarArchiveEntry entry, File outputDir) throws IOException {
+                                      TarArchiveEntry entry, File outputDir, final String base,
+                                      boolean symlinksDisabled) throws IOException {
+        File target = new File(outputDir, entry.getName());
+        String found = target.getCanonicalPath();
+        if (!found.startsWith(base)) {
+            LOG.error(""Invalid location {} is outside of {}"", found, base);
+            return;
+        }
         if (entry.isDirectory()) {
-            File subDir = new File(outputDir, entry.getName());
-            if (!subDir.mkdirs() && !subDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                        + outputDir);
-            }
+            LOG.trace(""Extracting dir {}"", target);
+            ensureDirectory(target);
             for (TarArchiveEntry e : entry.getDirectoryEntries()) {
-                unpackEntries(tis, e, subDir);
+                unpackEntries(tis, e, target, base, symlinksDisabled);
             }
-            return;
+        } else if (entry.isSymbolicLink()) {
+            if (symlinksDisabled) {
+                LOG.info(""Symlinks disabled skipping {}"", target);
+            } else {
+                Path src = target.toPath();
+                Path dest = Paths.get(entry.getLinkName());
+                LOG.trace(""Extracting sym link {} to {}"", target, dest);
+                // Create symbolic link relative to tar parent dir
+                Files.createSymbolicLink(src, dest);
+            }
+        } else if (entry.isFile()) {
+            LOG.trace(""Extracting file {}"", target);
+            ensureDirectory(target.getParentFile());
+            try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
+                IOUtils.copy(tis, outputStream);
+            }
+        } else {
+            LOG.error(""{} is not a currently supported tar entry type."", entry);
         }
-        File outputFile = new File(outputDir, entry.getName());
-        if (!outputFile.getParentFile().exists()) {
-            if (!outputFile.getParentFile().mkdirs()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                                      + outputDir);
+
+        Path p = target.toPath();
+        if (Files.exists(p)) {
+            try {
+                //We created it so lets chmod it properly
+                int mode = entry.getMode();
+                Files.setPosixFilePermissions(p, parsePerms(mode));
+            } catch (UnsupportedOperationException e) {
+                //Ignored the file system we are on does not support this, so don't do it.
             }
         }
-        int count;
-        byte data[] = new byte[2048];
-        BufferedOutputStream outputStream = new BufferedOutputStream(
-                new FileOutputStream(outputFile));
+    }
-        while ((count = tis.read(data)) != -1) {
-            outputStream.write(data, 0, count);
+    private static Set<PosixFilePermission> parsePerms(int mode) {
+        Set<PosixFilePermission> ret = new HashSet<>();
+        if ((mode & 0001) > 0) {
+            ret.add(PosixFilePermission.OTHERS_EXECUTE);
+        }
+        if ((mode & 0002) > 0) {
+            ret.add(PosixFilePermission.OTHERS_WRITE);
+        }
+        if ((mode & 0004) > 0) {
+            ret.add(PosixFilePermission.OTHERS_READ);
+        }
+        if ((mode & 0010) > 0) {
+            ret.add(PosixFilePermission.GROUP_EXECUTE);
         }
-        outputStream.flush();
-        outputStream.close();
+        if ((mode & 0020) > 0) {
+            ret.add(PosixFilePermission.GROUP_WRITE);
+        }
+        if ((mode & 0040) > 0) {
+            ret.add(PosixFilePermission.GROUP_READ);
+        }
+        if ((mode & 0100) > 0) {
+            ret.add(PosixFilePermission.OWNER_EXECUTE);
+        }
+        if ((mode & 0200) > 0) {
+            ret.add(PosixFilePermission.OWNER_WRITE);
+        }
+        if ((mode & 0400) > 0) {
+            ret.add(PosixFilePermission.OWNER_READ);
+        }
+        return ret;
     }
     public static boolean isOnWindows() {
@@ -1043,16 +1046,21 @@ public class Utils {
         return Paths.get(path).isAbsolute();
     }
-    public static void unpack(File localrsrc, File dst) throws IOException {
+    public static void unpack(File localrsrc, File dst, boolean symLinksDisabled) throws IOException {
         String lowerDst = localrsrc.getName().toLowerCase();
-        if (lowerDst.endsWith("".jar"")) {
+        if (lowerDst.endsWith("".jar"") ||
+            lowerDst.endsWith(""_jar"")) {
             unJar(localrsrc, dst);
-        } else if (lowerDst.endsWith("".zip"")) {
+        } else if (lowerDst.endsWith("".zip"") ||
+            lowerDst.endsWith(""_zip"")) {
             unZip(localrsrc, dst);
         } else if (lowerDst.endsWith("".tar.gz"") ||
-                lowerDst.endsWith("".tgz"") ||
-                lowerDst.endsWith("".tar"")) {
-            unTar(localrsrc, dst);
+            lowerDst.endsWith(""_tar_gz"") ||
+            lowerDst.endsWith("".tgz"") ||
+            lowerDst.endsWith(""_tgz"") ||
+            lowerDst.endsWith("".tar"") ||
+            lowerDst.endsWith(""_tar"")) {
+            unTar(localrsrc, dst, symLinksDisabled);
         } else {
             LOG.warn(""Cannot unpack "" + localrsrc);
             if (!localrsrc.renameTo(dst)) {
@@ -1065,6 +1073,35 @@ public class Utils {
         }
     }
+    private static void extractZipFile(ZipFile zipFile, File toDir, String prefix) throws IOException {
+        ensureDirectory(toDir);
+        final String base = toDir.getCanonicalPath();
+
+        Enumeration<? extends ZipEntry> entries = zipFile.entries();
+        while (entries.hasMoreElements()) {
+            ZipEntry entry = entries.nextElement();
+            if (!entry.isDirectory()) {
+                if (prefix != null && !entry.getName().startsWith(prefix)) {
+                    //No need to extract it, it is not what we are looking for.
+                    continue;
+                }
+                File file = new File(toDir, entry.getName());
+                String found = file.getCanonicalPath();
+                if (!found.startsWith(base)) {
+                    LOG.error(""Invalid location {} is outside of {}"", found, base);
+                    continue;
+                }
+
+                try (InputStream in = zipFile.getInputStream(entry)) {
+                    ensureDirectory(file.getParentFile());
+                    try (OutputStream out = new FileOutputStream(file)) {
+                        IOUtils.copy(in, out);
+                    }
+                }
+            }
+        }
+    }
+
     public static boolean canUserReadBlob(ReadableBlobMeta meta, String user) {
         SettableBlobMeta settable = meta.get_settable();
         for (AccessControl acl : settable.get_acl()) {
@@ -1374,45 +1411,12 @@ public class Utils {
-     * @param unzipDir The unzip directory where to unzip the zip file.
+     * @param toDir The unzip directory where to unzip the zip file.
-    public static void unZip(File inFile, File unzipDir) throws IOException {
-        Enumeration<? extends ZipEntry> entries;
-        ZipFile zipFile = new ZipFile(inFile);
-
-        try {
-            entries = zipFile.entries();
-            while (entries.hasMoreElements()) {
-                ZipEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = zipFile.getInputStream(entry);
-                    try {
-                        File file = new File(unzipDir, entry.getName());
-                        if (!file.getParentFile().mkdirs()) {
-                            if (!file.getParentFile().isDirectory()) {
-                                throw new IOException(""Mkdirs failed to create "" +
-                                                      file.getParentFile().toString());
-                            }
-                        }
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            byte[] buffer = new byte[8192];
-                            int i;
-                            while ((i = in.read(buffer)) != -1) {
-                                out.write(buffer, 0, i);
-                            }
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            zipFile.close();
-        }
+    public static void unZip(File inFile, File toDir) throws IOException {
+        try (ZipFile zipFile = new ZipFile(inFile)) {
+            extractZipFile(zipFile, toDir, null);        }
     }
@@ -1882,21 +1886,10 @@ public class Utils {
     public static void extractDirFromJar(String jarpath, String dir, File destdir) {
         _instance.extractDirFromJarImpl(jarpath, dir, destdir);
     }
-    
+
     public void extractDirFromJarImpl(String jarpath, String dir, File destdir) {
         try (JarFile jarFile = new JarFile(jarpath)) {
-            Enumeration<JarEntry> jarEnums = jarFile.entries();
-            while (jarEnums.hasMoreElements()) {
-                JarEntry entry = jarEnums.nextElement();
-                if (!entry.isDirectory() && entry.getName().startsWith(dir)) {
-                    File aFile = new File(destdir, entry.getName());
-                    aFile.getParentFile().mkdirs();
-                    try (FileOutputStream out = new FileOutputStream(aFile);
-                         InputStream in = jarFile.getInputStream(entry)) {
-                        IOUtils.copy(in, out);
-                    }
-                }
-            }
+            extractZipFile(jarFile, destdir, dir);
         } catch (IOException e) {
             LOG.info(""Could not extract {} from {}"", dir, jarpath);
         }",1,java,237.0,Utils.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,train,"@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) Will Sargent. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.security.Principal;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * Hostname checker interface.
+ */
+public interface HostnameChecker {
+
+    public void match(String hostname, X509Certificate peerCertificate) throws CertificateException;
+
+    public boolean match(String hostname, Principal principal);
+}",1,java,9.0,api/src/main/java/org/asynchttpclient/util/HostnameChecker.java
3dd86d04e8b90ba309819317d19e7260d414d9e7,apache/activemq,train,"@@ -1,139 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.activemq.util;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-/**
- *
- */
-public final class IOHelper {
-    protected static final int MAX_DIR_NAME_LENGTH;
-    protected static final int MAX_FILE_NAME_LENGTH;
-    private static final int DEFAULT_BUFFER_SIZE = 4096;
-    private IOHelper() {
-    }
-
-    public static String getDefaultDataDirectory() {
-        return getDefaultDirectoryPrefix() + ""activemq-data"";
-    }
-
-    public static String getDefaultStoreDirectory() {
-        return getDefaultDirectoryPrefix() + ""amqstore"";
-    }
-
-    /**
-     * Allows a system property to be used to overload the default data
-     * directory which can be useful for forcing the test cases to use a target/
-     * prefix
-     */
-    public static String getDefaultDirectoryPrefix() {
-        try {
-            return System.getProperty(""org.apache.activemq.default.directory.prefix"", """");
-        } catch (Exception e) {
-            return """";
-        }
-    }
-
-    public static boolean deleteFile(File fileToDelete) {
-        if (fileToDelete == null || !fileToDelete.exists()) {
-            return true;
-        }
-        boolean result = deleteChildren(fileToDelete);
-        result &= fileToDelete.delete();
-        return result;
-    }
-
-    public static boolean deleteChildren(File parent) {
-        if (parent == null || !parent.exists()) {
-            return false;
-        }
-        boolean result = true;
-        if (parent.isDirectory()) {
-            File[] files = parent.listFiles();
-            if (files == null) {
-                result = false;
-            } else {
-                for (int i = 0; i < files.length; i++) {
-                    File file = files[i];
-                    if (file.getName().equals(""."")
-                            || file.getName().equals("".."")) {
-                        continue;
-                    }
-                    if (file.isDirectory()) {
-                        result &= deleteFile(file);
-                    } else {
-                        result &= file.delete();
-                    }
-                }
-            }
-        }
-
-        return result;
-    }
-
-
-    public static void moveFile(File src, File targetDirectory) throws IOException {
-        if (!src.renameTo(new File(targetDirectory, src.getName()))) {
-            throw new IOException(""Failed to move "" + src + "" to "" + targetDirectory);
-        }
-    }
-
-    public static void copyFile(File src, File dest) throws IOException {
-        FileInputStream fileSrc = new FileInputStream(src);
-        FileOutputStream fileDest = new FileOutputStream(dest);
-        copyInputStream(fileSrc, fileDest);
-    }
-
-    public static void copyInputStream(InputStream in, OutputStream out) throws IOException {
-        try {
-            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
-            int len = in.read(buffer);
-            while (len >= 0) {
-                out.write(buffer, 0, len);
-                len = in.read(buffer);
-            }
-        } finally {
-            in.close();
-            out.close();
-        }
-    }
-
-    static {
-        MAX_DIR_NAME_LENGTH = Integer.valueOf(System.getProperty(""MaximumDirNameLength"",""200"")).intValue();
-        MAX_FILE_NAME_LENGTH = Integer.valueOf(System.getProperty(""MaximumFileNameLength"",""64"")).intValue();
-    }
-
-
-    public static void mkdirs(File dir) throws IOException {
-        if (dir.exists()) {
-            if (!dir.isDirectory()) {
-                throw new IOException(""Failed to create directory '"" + dir +""', regular file already existed with that name"");
-            }
-
-        } else {
-            if (!dir.mkdirs()) {
-                throw new IOException(""Failed to create directory '"" + dir+""'"");
-            }
-        }
-    }
-}",1,java,100.0,IOHelper.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -404,7 +404,7 @@ public class HttpHandlerImpl implements HttpHandler {
         if (ex != null) {
           throw ex;
         }
-        throw new Err(Status.NOT_FOUND, path);
+        throw new Err(Status.NOT_FOUND, req.path(true));
       }
     }, method, path, ""err"", accept));
 
@@ -436,10 +436,10 @@ public class HttpHandlerImpl implements HttpHandler {
   }
 
   private static Err handle405(final Set<Route.Definition> routeDefs, final String method,
-      final String uri, final MediaType type, final List<MediaType> accept) {
+      final String path, final MediaType type, final List<MediaType> accept) {
 
-    if (alternative(routeDefs, method, uri).size() > 0) {
-      return new Err(Status.METHOD_NOT_ALLOWED, method + uri);
+    if (alternative(routeDefs, method, path).size() > 0) {
+      return new Err(Status.METHOD_NOT_ALLOWED, method);
     }
 
     return null;
",1,java,8.0,HttpHandlerImpl.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -26,6 +26,12 @@ private BigInteger validate(BigInteger y, DHParameters dhParams)
             throw new NullPointerException(""y value cannot be null"");
         }
+        // TLS check
+        if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)
+        {
+            throw new IllegalArgumentException(""invalid DH public key"");
+        }
+
         if (dhParams.getQ() != null)
         {
             if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))
@@ -37,12 +43,6 @@ private BigInteger validate(BigInteger y, DHParameters dhParams)
         }
         else
         {
-            // TLS check
-            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)
-            {
-                throw new IllegalArgumentException(""invalid DH public key"");
-            }
-
             return y;         // we can't validate without Q.
         }
     }",1,java,8.0,core/src/main/java/org/bouncycastle/crypto/params/DHPublicKeyParameters.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -16,10 +16,12 @@
 import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
 import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
 import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
-import org.bouncycastle.asn1.x9.DHDomainParameters;
 import org.bouncycastle.asn1.x9.DomainParameters;
+import org.bouncycastle.asn1.x9.ValidationParams;
 import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+import org.bouncycastle.crypto.params.DHParameters;
 import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHValidationParameters;
 import org.bouncycastle.jcajce.provider.asymmetric.util.KeyUtil;
 public class BCDHPublicKey
@@ -29,6 +31,7 @@
     private BigInteger              y;
+    private transient DHPublicKeyParameters   dhPublicKey;
     private transient DHParameterSpec         dhSpec;
     private transient SubjectPublicKeyInfo    info;
@@ -37,6 +40,7 @@
     {
         this.y = spec.getY();
         this.dhSpec = new DHParameterSpec(spec.getP(), spec.getG());
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(spec.getP(), spec.getG()));
     }
     BCDHPublicKey(
@@ -44,6 +48,7 @@
     {
         this.y = key.getY();
         this.dhSpec = key.getParams();
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
     }
     BCDHPublicKey(
@@ -51,6 +56,7 @@
     {
         this.y = params.getY();
         this.dhSpec = new DHParameterSpec(params.getParameters().getP(), params.getParameters().getG(), params.getParameters().getL());
+        this.dhPublicKey = params;
     }
     BCDHPublicKey(
@@ -59,6 +65,7 @@
     {
         this.y = y;
         this.dhSpec = dhSpec;
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
     }
     public BCDHPublicKey(
@@ -94,12 +101,23 @@ public BCDHPublicKey(
             {
                 this.dhSpec = new DHParameterSpec(params.getP(), params.getG());
             }
+            this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
         }
         else if (id.equals(X9ObjectIdentifiers.dhpublicnumber))
         {
             DomainParameters params = DomainParameters.getInstance(seq);
             this.dhSpec = new DHParameterSpec(params.getP(), params.getG());
+            ValidationParams validationParams = params.getValidationParams();
+            if (validationParams != null)
+            {
+                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(),
+                                            new DHValidationParameters(validationParams.getSeed(), validationParams.getPgenCounter().intValue())));
+            }
+            else
+            {
+                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(), null));
+            }
         }
         else
         {
@@ -137,6 +155,11 @@ public BigInteger getY()
         return y;
     }
+    public DHPublicKeyParameters engineGetKeyParameters()
+    {
+        return dhPublicKey;
+    }
+
     private boolean isPKCSParam(ASN1Sequence seq)
     {
         if (seq.size() == 2)",1,java,24.0,BCDHPublicKey.java
a37b43cca82f108a8e3f5c2803a9b50911a60979,apache/activemq,train,"@@ -16,13 +16,14 @@
 package org.apache.activemq.store.kahadb.disk.util;
+import org.apache.activemq.util.RecoverableRandomAccessFile;
+
 import java.io.File;
+import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.util.ArrayList;
 import java.util.Arrays;
-import org.apache.activemq.util.RecoverableRandomAccessFile;
-
@@ -53,7 +54,7 @@ public class DiskBenchmark {
             try {
                 File file = new File(f);
                 if (file.exists()) {
-                    System.out.println(""File "" + file + "" allready exists, will not benchmark."");
+                    System.out.println(""File "" + file + "" already exists, will not benchmark."");
                 } else {
                     System.out.println(""Benchmarking: "" + file.getCanonicalPath());
                     Report report = benchmark.benchmark(file);
@@ -194,7 +195,7 @@ public class DiskBenchmark {
         }
     }
-    public Report benchmark(File file) throws IOException {
+    public Report benchmark(File file) throws Exception {
         Report rc = new Report();
@@ -202,94 +203,108 @@ public class DiskBenchmark {
         for (int i = 0; i < data.length; i++) {
             data[i] = (byte) ('a' + (i % 26));
         }
-        rc.size = data.length;
-
-        long start;
-        long now;
-        int ioCount;
-        try(RecoverableRandomAccessFile raf = new RecoverableRandomAccessFile(file, ""rw"")) {
-            preallocateDataFile(raf, file.getParentFile());
-            start = System.currentTimeMillis();
-            now = System.currentTimeMillis();
-            ioCount = 0;
-
-            // Figure out how many writes we can do in the sample interval.
-            while (true) {
+        rc.size = data.length;
+        RecoverableRandomAccessFile raf = new RecoverableRandomAccessFile(file, ""rw"");
+        preallocateDataFile(raf, file.getParentFile());
+
+        // Figure out how many writes we can do in the sample interval.
+        long start = System.currentTimeMillis();
+        long now = System.currentTimeMillis();
+        int ioCount = 0;
+        while (true) {
+            if ((now - start) > sampleInterval) {
+                break;
+            }
+            raf.seek(0);
+            for (long i = 0; i + data.length < size; i += data.length) {
+                raf.write(data);
+                ioCount++;
+                now = System.currentTimeMillis();
                 if ((now - start) > sampleInterval) {
                     break;
                 }
-                raf.seek(0);
-                for (long i = 0; i + data.length < size; i += data.length) {
-                    raf.write(data);
-                    ioCount++;
-                    now = System.currentTimeMillis();
-                    if ((now - start) > sampleInterval) {
-                        break;
-                    }
-                }
-                // Sync to disk so that the we actually write the data to disk..
-                // otherwise OS buffering might not really do the write.
-                raf.getChannel().force(!SKIP_METADATA_UPDATE);
             }
+            // Sync to disk so that the we actually write the data to disk..
+            // otherwise OS buffering might not really do the write.
             raf.getChannel().force(!SKIP_METADATA_UPDATE);
         }
+        raf.getChannel().force(!SKIP_METADATA_UPDATE);
+        raf.close();
         now = System.currentTimeMillis();
         rc.size = data.length;
         rc.writes = ioCount;
         rc.writeDuration = (now - start);
-        try(RecoverableRandomAccessFile raf = new RecoverableRandomAccessFile(file, ""rw"")) {
-            start = System.currentTimeMillis();
-            now = System.currentTimeMillis();
-            ioCount = 0;
-            while (true) {
+        raf = new RecoverableRandomAccessFile(file, ""rw"");
+        start = System.currentTimeMillis();
+        now = System.currentTimeMillis();
+        ioCount = 0;
+        while (true) {
+            if ((now - start) > sampleInterval) {
+                break;
+            }
+            for (long i = 0; i + data.length < size; i += data.length) {
+                raf.seek(i);
+                raf.write(data);
+                raf.getChannel().force(!SKIP_METADATA_UPDATE);
+                ioCount++;
+                now = System.currentTimeMillis();
                 if ((now - start) > sampleInterval) {
                     break;
                 }
-                for (long i = 0; i + data.length < size; i += data.length) {
-                    raf.seek(i);
-                    raf.write(data);
-                    raf.getChannel().force(!SKIP_METADATA_UPDATE);
-                    ioCount++;
-                    now = System.currentTimeMillis();
-                    if ((now - start) > sampleInterval) {
-                        break;
-                    }
-                }
             }
         }
+        raf.close();
         now = System.currentTimeMillis();
         rc.syncWrites = ioCount;
         rc.syncWriteDuration = (now - start);
-        try(RecoverableRandomAccessFile raf = new RecoverableRandomAccessFile(file, ""rw"")) {
-            start = System.currentTimeMillis();
-            now = System.currentTimeMillis();
-            ioCount = 0;
-            while (true) {
+        raf = new RecoverableRandomAccessFile(file, ""rw"");
+        start = System.currentTimeMillis();
+        now = System.currentTimeMillis();
+        ioCount = 0;
+        while (true) {
+            if ((now - start) > sampleInterval) {
+                break;
+            }
+            raf.seek(0);
+            for (long i = 0; i + data.length < size; i += data.length) {
+                raf.seek(i);
+                raf.readFully(data);
+                ioCount++;
+                now = System.currentTimeMillis();
                 if ((now - start) > sampleInterval) {
                     break;
                 }
-                raf.seek(0);
-                for (long i = 0; i + data.length < size; i += data.length) {
-                    raf.seek(i);
-                    raf.readFully(data);
-                    ioCount++;
-                    now = System.currentTimeMillis();
-                    if ((now - start) > sampleInterval) {
-                        break;
-                    }
-                }
             }
         }
+        raf.close();
         rc.reads = ioCount;
         rc.readDuration = (now - start);
         return rc;
     }
+    private void preallocateDataFile(RecoverableRandomAccessFile raf, File location) throws Exception {
+        File tmpFile;
+        if (location != null && location.isDirectory()) {
+            tmpFile = new File(location, ""template.dat"");
+        }else {
+            tmpFile = new File(""template.dat"");
+        }
+        if (tmpFile.exists()) {
+            tmpFile.delete();
+        }
+        RandomAccessFile templateFile = new RandomAccessFile(tmpFile, ""rw"");
+        templateFile.setLength(size);
+        templateFile.getChannel().force(true);
+        templateFile.getChannel().transferTo(0, size, raf.getChannel());
+        templateFile.close();
+        tmpFile.delete();
+    }
+
     public boolean isVerbose() {
         return verbose;
     }",1,java,121.0,DiskBenchmark.java
3dd86d04e8b90ba309819317d19e7260d414d9e7,apache/activemq,train,"@@ -1,230 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-//========================================================================
-//Copyright 2007 CSC - Scientific Computing Ltd.
-//========================================================================
-package org.apache.activemq.util;
-
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletException;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.UnavailableException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-
-/**
- * <p>
- * Adds support for HTTP PUT, MOVE and DELETE methods. If init parameters
- * read-permission-role and write-permission-role are defined then all requests
- * are authorized using the defined roles. Also GET methods are authorized.
- * </p>
- *
- * @author Aleksi Kallio
- */
-public class RestFilter implements Filter {
-    private static final Logger LOG = LoggerFactory.getLogger(RestFilter.class);
-
-    private static final String HTTP_HEADER_DESTINATION = ""Destination"";
-    private static final String HTTP_METHOD_MOVE = ""MOVE"";
-    private static final String HTTP_METHOD_PUT = ""PUT"";
-    private static final String HTTP_METHOD_GET = ""GET"";
-    private static final String HTTP_METHOD_DELETE = ""DELETE"";
-
-    private String readPermissionRole;
-    private String writePermissionRole;
-    private FilterConfig filterConfig;
-
-    public void init(FilterConfig filterConfig) throws UnavailableException {
-        this.filterConfig = filterConfig;
-        readPermissionRole = filterConfig.getInitParameter(""read-permission-role"");
-        writePermissionRole = filterConfig.getInitParameter(""write-permission-role"");
-    }
-
-    private File locateFile(HttpServletRequest request) {
-        return new File(filterConfig.getServletContext().getRealPath(request.getServletPath()), request.getPathInfo());
-    }
-
-    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-        if (!(request instanceof HttpServletRequest && response instanceof HttpServletResponse)) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(""request not HTTP, can not understand: "" + request.toString());
-            }
-            chain.doFilter(request, response);
-            return;
-        }
-
-        HttpServletRequest httpRequest = (HttpServletRequest)request;
-        HttpServletResponse httpResponse = (HttpServletResponse)response;
-
-        if (httpRequest.getMethod().equals(HTTP_METHOD_MOVE)) {
-            doMove(httpRequest, httpResponse);
-        } else if (httpRequest.getMethod().equals(HTTP_METHOD_PUT)) {
-            doPut(httpRequest, httpResponse);
-        } else if (httpRequest.getMethod().equals(HTTP_METHOD_GET)) {
-            if (checkGet(httpRequest, httpResponse)) {
-                chain.doFilter(httpRequest, httpResponse); // actual processing
-                                                            // done elsewhere
-            }
-        } else if (httpRequest.getMethod().equals(HTTP_METHOD_DELETE)) {
-            doDelete(httpRequest, httpResponse);
-        } else {
-            chain.doFilter(httpRequest, httpResponse);
-        }
-    }
-
-    protected void doMove(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""RESTful file access: MOVE request for "" + request.getRequestURI());
-        }
-
-        if (writePermissionRole != null && !request.isUserInRole(writePermissionRole)) {
-            response.sendError(HttpURLConnection.HTTP_FORBIDDEN);
-            return;
-        }
-
-        File file = locateFile(request);
-        String destination = request.getHeader(HTTP_HEADER_DESTINATION);
-
-        if (destination == null) {
-            response.sendError(HttpURLConnection.HTTP_BAD_REQUEST, ""Destination header not found"");
-            return;
-        }
-
-        try {
-            URL destinationUrl = new URL(destination);
-            IOHelper.copyFile(file, new File(destinationUrl.getFile()));
-            IOHelper.deleteFile(file);
-        } catch (IOException e) {
-            response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR); // file
-                                                                        // could
-                                                                        // not
-                                                                        // be
-                                                                        // moved
-            return;
-        }
-
-        response.setStatus(HttpURLConnection.HTTP_NO_CONTENT); // we return no
-                                                                // content
-    }
-
-    protected boolean checkGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""RESTful file access: GET request for "" + request.getRequestURI());
-        }
-
-        if (readPermissionRole != null && !request.isUserInRole(readPermissionRole)) {
-            response.sendError(HttpURLConnection.HTTP_FORBIDDEN);
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""RESTful file access: PUT request for "" + request.getRequestURI());
-        }
-
-        if (writePermissionRole != null && !request.isUserInRole(writePermissionRole)) {
-            response.sendError(HttpURLConnection.HTTP_FORBIDDEN);
-            return;
-        }
-
-        File file = locateFile(request);
-
-        if (file.exists()) {
-            boolean success = file.delete(); // replace file if it exists
-            if (!success) {
-                response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR); // file
-                                                                            // existed
-                                                                            // and
-                                                                            // could
-                                                                            // not
-                                                                            // be
-                                                                            // deleted
-                return;
-            }
-        }
-
-        FileOutputStream out = new FileOutputStream(file);
-        try {
-            IOHelper.copyInputStream(request.getInputStream(), out);
-        } catch (IOException e) {
-            LOG.warn(""Exception occured"" , e);
-            throw e;
-        } finally {
-            out.close();
-        }
-
-        response.setStatus(HttpURLConnection.HTTP_NO_CONTENT); // we return no
-                                                                // content
-    }
-
-    protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""RESTful file access: DELETE request for "" + request.getRequestURI());
-        }
-
-        if (writePermissionRole != null && !request.isUserInRole(writePermissionRole)) {
-            response.sendError(HttpURLConnection.HTTP_FORBIDDEN);
-            return;
-        }
-
-        File file = locateFile(request);
-
-        if (!file.exists()) {
-            response.sendError(HttpURLConnection.HTTP_NOT_FOUND); // file not
-                                                                    // found
-            return;
-        }
-
-        boolean success = IOHelper.deleteFile(file); // actual delete operation
-
-        if (success) {
-            response.setStatus(HttpURLConnection.HTTP_NO_CONTENT); // we return
-                                                                    // no
-                                                                    // content
-        } else {
-            response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR); // could
-                                                                        // not
-                                                                        // be
-                                                                        // deleted
-                                                                        // due
-                                                                        // to
-                                                                        // internal
-                                                                        // error
-        }
-    }
-
-    public void destroy() {
-        // nothing to destroy
-    }
-}",1,java,145.0,RestFilter.java
6f12d68c975e714a4197d68e363bcbbf302768c7,apache/groovy,train,"@@ -0,0 +1,350 @@
+/*
+ * Copyright (c) 2013 Oracle and/or its affiliates.
+ * All rights reserved. Use is subject to license terms.
+ *
+ * License Agreement
+ * 
+ * PLEASE READ THE FOLLOWING LICENSE TERMS CAREFULLY BEFORE USING THE 
+ * ACCOMPANYING PROGRAM. THESE TERMS CONSTITUTE A LEGAL AGREEMENT BETWEEN 
+ * YOU AND US.
+ * 
+ * ""Oracle"" refers to Oracle America, Inc., for and on behalf of itself and its 
+ * subsidiaries and affiliates under common control.  ""We,"" ""us,"" and ""our"" 
+ * refers to Oracle and any Program contributors. ""You"" and ""your"" refers to 
+ * the individual or entity that wishes to use the Program. ""Program"" refers to
+ * the Java API Documentation Updater Tool, Copyright (c) 2013, Oracle America,
+ * Inc., and updates or error corrections provided by Oracle or contributors.
+ * 
+ * WARNING: 
+ * The Program will analyze directory information on your computer 
+ * system and may modify software components on such computer system.  You 
+ * should only use the Program on computer systems that you maintain sufficient
+ * rights to update software components.
+ * 
+ * If your computer system is owned by a person or entity other than you, 
+ * you should check with such person or entity before using the Program. 
+ * 
+ * It is possible that you may lose some software functionality, and make 
+ * Java API Documentation pages unusable on your computer system after you use
+ * the Program to update software components.
+ * 
+ * License Rights and Obligations 
+ * We grant you a perpetual, nonexclusive, limited license to use, modify and 
+ * distribute the Program in binary and/or source code form, only for the
+ * purpose of analyzing the directory structure of your computer system and
+ * updating Java API Documentation files.  If you distribute the Program, in
+ * either or both binary or source form, including as modified by you, you
+ * shall include this License Agreement (""Agreement"") with your distribution.
+ * 
+ * All rights not expressly granted above are hereby reserved. If you want to
+ * use the Program for any purpose other than as permitted under this
+ * Agreement, you must obtain a valid license permitting such use from Oracle.
+ * Neither the name of Oracle nor the names of any Program contributors may be
+ * used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ * 
+ * Ownership and Restrictions 
+ * We retain all ownership and intellectual property rights in the Program as
+ * provided by us. You retain all ownership and intellectual property rights
+ * in your modifications.
+ * 
+ * Export
+ * You agree to comply fully with export laws and regulations of the United 
+ * States and any other applicable export laws (""Export Laws"") to assure that
+ * neither the Program nor any direct products thereof are:  (1) exported,
+ * directly or indirectly, in violation of this Agreement or Export Laws; or
+ * (2) used for any purposes prohibited by the Export Laws, including, without
+ * limitation, nuclear, chemical, or biological weapons proliferation, or
+ * development of missile technology. 
+ * 
+ * Disclaimer of Warranty and Limitation of Liability 
+ * THE PROGRAM IS PROVIDED ""AS IS"" WITHOUT WARRANTY OF ANY KIND. USE AT YOUR
+ * OWN RISK.  WE FURTHER DISCLAIM ALL WARRANTIES, EXPRESS AND IMPLIED,
+ * INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT. 
+ * 
+ * IN NO EVENT SHALL WE BE LIABLE FOR ANY INDIRECT, DIRECT, INCIDENTAL,
+ * SPECIAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, OR DAMAGES FOR LOSS OF PROFITS,
+ * REVENUE, DATA OR DATA USE, INCURRED BY YOU OR ANY THIRD PARTY, WHETHER IN AN
+ * ACTION IN CONTRACT OR TORT, EVEN IF WE HAVE BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGES.  ORACLE SHALL HAVE NO LIABILITY FOR MODIFICATIONS MADE BY
+ * YOU OR ANY THIRD PARTY.
+ * 
+ * Entire Agreement
+ * You agree that this Agreement is the complete agreement for the Program, and
+ * this Agreement supersedes all prior or contemporaneous agreements or
+ * representations. If any term of this Agreement is found to be invalid or
+ * unenforceable, the remaining provisions will remain effective. This
+ * Agreement is governed by the substantive and procedural laws of California.
+ * You and Oracle agree to submit to the exclusive jurisdiction of, and venue
+ * in, the courts of San Francisco or Santa Clara counties in California in
+ * any dispute between you and Oracle arising out of or relating to this
+ * Agreement. 
+ * 
+ * Last updated: 14 June 2013
+ */
+import java.io.*;
+
+/*
+ * Tool for finding and addressing files related to CVE-2013-1571.
+ * See README file for details.
+ */
+public class JavadocFixTool {
+    // Usual suspects
+    private final static String[] fileNames = {""index.html"",
+                                         ""index.htm"",
+                                         ""toc.html"",
+                                         ""toc.htm""};
+
+    // If we locate this function but not validURL - we are in trouble
+    private final String patchString = ""function loadFrames() {"";
+    // Main fix - should be inserted before the loadFrames() function alongside
+    // the code that calls this function
+    private final static String[] patchData =
+            {""    if (targetPage != \""\"" && !validURL(targetPage))"",
+             ""        targetPage = \""undefined\"";"",
+             ""    function validURL(url) {"",
+             ""        var pos = url.indexOf(\"".html\"");"",
+             ""        if (pos == -1 || pos != url.length - 5)"",
+             ""            return false;"",
+             ""        var allowNumber = false;"",
+             ""        var allowSep = false;"",
+             ""        var seenDot = false;"",
+             ""        for (var i = 0; i < url.length - 5; i++) {"",
+             ""            var ch = url.charAt(i);"",
+             ""            if ('a' <= ch && ch <= 'z' ||"",
+             ""                    'A' <= ch && ch <= 'Z' ||"",
+             ""                    ch == '$' ||"",
+             ""                    ch == '_') {"",
+             ""                allowNumber = true;"",
+             ""                allowSep = true;"",
+             ""            } else if ('0' <= ch && ch <= '9'"",
+             ""                    || ch == '-') {"",
+             ""                if (!allowNumber)"",
+             ""                     return false;"",
+             ""            } else if (ch == '/' || ch == '.') {"",
+             ""                if (!allowSep)"",
+             ""                    return false;"",
+             ""                allowNumber = false;"",
+             ""                allowSep = false;"",
+             ""                if (ch == '.')"",
+             ""                     seenDot = true;"",
+             ""                if (ch == '/' && seenDot)"",
+             ""                     return false;"",
+             ""            } else {"",
+             ""                return false;"",
+             ""            }"",
+             ""        }"",
+             ""        return true;"",
+             ""    }"",
+             ""    function loadFrames() {""};
+
+    private final String quickFixString = ""if (!(url.indexOf(\"".html\"") == url.length - 5))"";
+    private final String[] quickFix = {""        var pos = url.indexOf(\"".html\"");"",
+                                       ""        if (pos == -1 || pos != url.length - 5)""};
+    private static String readme = null;
+    private static String version = ""Java Documentation Updater Tool version 1.2 06/14/2013\n"";
+
+    private static boolean doPatch = true; // By default patch file
+    private static boolean recursive = false; // By default only look in the folder in parameter
+
+    public static void main(String[] args) {
+        System.out.println(version);
+
+        if (args.length < 1) {
+            // No arguments - lazily initialize readme, print readme and usage
+            initReadme();
+            if (readme != null) {
+                System.out.println(readme);
+            }
+            printUsage(System.out);
+            return;
+        }
+
+        // Last argument should be a path to the document root
+        String name = args[args.length-1];
+
+        // Analyze the rest of parameters
+        for (int i = 0 ; i < args.length -1; i++) {
+            if (""-R"".equalsIgnoreCase(args[i])) {
+                recursive = true;
+            } else if (""-C"".equalsIgnoreCase(args[i])) {
+                doPatch = false;
+            } else {
+                System.err.println(""Unknown option passed: ""+args[i]);
+                printUsage(System.err);
+                return;
+            }
+        }
+        new JavadocFixTool().proceed(name);
+    }
+
+    /*
+     * Print usage information into the provided PrintStream
+     * @param out PrintStream to write usage information
+     */
+    public static void printUsage(PrintStream out) {
+        out.println(""Usage: java -jar JavadocPatchTool.jar [-R] [-C] <Path to Javadoc root>"");
+        out.println(""    -R : Proceed recursively starting from given folder"");
+        out.println(""    -C : Check only - program will find vulnerable files and print their full paths"");
+    }
+
+    /*
+     * Lazily initialize the readme document, reading it from README file inside the jar
+     */
+    public static void initReadme() {
+        try {
+            InputStream readmeStream = JavadocFixTool.class.getResourceAsStream(""/README"");
+            if (readmeStream != null) {
+                BufferedReader readmeReader = new BufferedReader(new InputStreamReader(readmeStream));
+                StringBuilder readmeBuilder = new StringBuilder();
+                String s;
+                while ((s = readmeReader.readLine()) != null) {
+                    readmeBuilder.append(s);
+                    readmeBuilder.append(""\n"");
+                }
+                readme = readmeBuilder.toString();
+            }
+        } catch (IOException ignore) {} // Ignore exception - readme not initialized
+    }
+
+    /*
+     * Main procedure - proceed with the searching and/or fixing depending on
+     * the command line parameters
+     * @param name Path to the document root
+     */
+    public void proceed(String name) {
+        try {
+            File folder = new File(name);
+            if (folder.exists() && folder.isDirectory() && folder.canRead()) {
+                searchAndPatch(folder);
+            } else {
+                System.err.println(""Invalid folder in parameter \""""+name+""\"""");
+                printUsage(System.err);
+            }
+        } catch (Exception ignored) {} // Die silently
+    }
+
+    /*
+     * Find all the files that match the list given in the fileNames array.
+     * If file found attempt to patch it.
+     * If global parameter recursive is set to true attempt to go into the enclosed subfolders
+     * otherwise only patch said files in the folder directly pointed in parameter.
+     */
+    public void searchAndPatch(File folder) {
+        if (folder == null || !folder.isDirectory() || folder.list() == null) {
+            // Silently return
+            return;
+        }
+
+        for (File file : folder.listFiles()) {
+            if (file.isDirectory()) {
+                if(recursive) {
+                    searchAndPatch(file);
+                }
+                continue;
+            }
+            String name = file.getName();
+            for (String s : fileNames) {
+                if (s.equalsIgnoreCase(name)) {
+                    try {
+                        applyPatch(file, folder);
+                    } catch (Exception ex) {
+                        String filePath;
+                        try {
+                            filePath = file.getCanonicalPath();
+                        } catch (IOException ioe) {
+                            System.err.println(""Can not resolve path to ""+file.getName()+"" in folder ""+folder.getName());
+                            continue;
+                        }
+                        System.err.println(""Patch failed on: ""+filePath+"" due to the ""+ex);
+                    }
+                }
+            }
+        }
+    }
+
+    /*
+     * Try to apply patch to the single file in the specific folder
+     * If global parameter doPatch is false we should only print the location of the vulnerable html file
+     * and return
+     */
+    public void applyPatch(File file, File currentFolder) throws Exception {
+        FileInputStream fis = new FileInputStream(file);
+        BufferedReader br = new BufferedReader(new InputStreamReader(fis));
+        String line;
+        String failedString = patchString;
+        String[] patch = patchData;
+        // Attempt to look if file is vulnerable
+        for (int i = 0 ; i < 80 ; i++) { // Check first 80 lines - if there is no signature it is not our file
+            line = br.readLine();
+            if (line == null) {
+                // File less than 80 lines long, no signature encountered
+                return;
+            }
+            if (line.trim().equals(""function validURL(url) {"")) { // Already patched
+                failedString = null;
+                patch = null;
+                continue;
+            }
+            if (line.trim().equals(quickFixString)) { // The patch had famous 2-letter bug, update it
+                failedString = quickFixString;
+                patch = quickFix;
+                continue;
+            }
+            if (line.trim().equals(""function loadFrames() {"")) {
+                fis.close(); // It should not interfere with the file renaming process
+                if (failedString != null) {
+                    // Vulnerable file
+                    if (!doPatch) { // Report and return
+                        System.out.println(""Vulnerable file found: ""+file.getCanonicalPath());
+                    } else {
+                        replaceStringInFile(currentFolder, file, failedString, patch);
+                    }
+                }
+                return;
+            }
+        }
+    }
+
+    /*
+     * Replace one line in the given file in the given folder with the lines given
+     * @param folder Folder in which file should be created
+     * @param file Original file to patch
+     * @param template Trimmed String with the pattern we are have to find
+     * @param replacement Array of String that has to be written in the place of first line matching the template
+     */
+    public void replaceStringInFile(File folder, File file, String template, String[] replacement)
+            throws IOException {
+        System.out.println(""Patching file: ""+file.getCanonicalPath());
+        String name = file.getName();
+        File origFile = new File(folder, name+"".orig"");
+        file.renameTo(origFile);
+        File temporaryFile = new File(folder, name+"".tmp"");
+        if (temporaryFile.exists()) {
+            temporaryFile.delete();
+        }
+        temporaryFile.createNewFile();
+        String line;
+        FileInputStream fis = new FileInputStream(origFile);
+        PrintWriter pw = new PrintWriter(temporaryFile);
+        BufferedReader br = new BufferedReader(new InputStreamReader(fis));
+        while ((line = br.readLine()) != null) {
+            if (line.trim().equals(template)) {
+                for (String s : replacement) {
+                    pw.println(s);
+                }
+            } else {
+                pw.println(line);
+            }
+        }
+        pw.flush();
+        pw.close();
+        if (!temporaryFile.renameTo(new File(folder, name))) {
+            throw new IOException(""Unable to rename file in folder ""+folder.getName()+
+                    "" from \""""+temporaryFile.getName()+""\"" into \""""+name +
+                    ""\n Original file saved as ""+origFile.getName());
+        }
+        origFile.delete();
+    }
+}
",1,java,206.0,JavadocFixTool.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -52,7 +52,7 @@ public BCXMSSMTPrivateKey(PrivateKeyInfo keyInfo)
             if (xmssMtPrivateKey.getBdsState() != null)
             {
-                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState()));
+                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState(), BDSStateMap.class));
             }
             this.keyParams = keyBuilder.build();",1,java,2.0,BCXMSSMTPrivateKey.java
c19cc705688cfffa4fe735e0edbe84862b6c135f,jenkinsci/jenkins,train,"@@ -80,8 +80,10 @@ import java.net.URLConnection;
 import java.nio.file.FileSystems;
 import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.LinkOption;
+import java.nio.file.Paths;
 import java.nio.file.StandardCopyOption;
 import java.nio.file.attribute.FileAttribute;
 import java.nio.file.attribute.PosixFilePermission;
@@ -3044,33 +3046,61 @@ public final class FilePath implements Serializable {
             if (new File(potentialChildRelativePath).isAbsolute()) {
                 throw new IllegalArgumentException(""Only a relative path is supported, the given path is absolute: "" + potentialChildRelativePath);
             }
+    
+            Path parentAbsolutePath = Util.fileToPath(parentFile.getAbsoluteFile());
+            Path parentRealPath;
+            try {
+                parentRealPath = parentAbsolutePath.toRealPath();
+            }
+            catch(NoSuchFileException e) {
+                throw new IllegalArgumentException(""The parent does not exist"");
+            }
-            Path parent = parentFile.getAbsoluteFile().toPath().normalize();
-
+            // example: ""a/b/c"" that will become ""b/c"" then just ""c"", and finally an empty string
             String remainingPath = potentialChildRelativePath;
-            File currentFile = parentFile;
+
+            Path currentFilePath = parentFile.toPath();
             while (!remainingPath.isEmpty()) {
-                File directChild = this.getDirectChild(currentFile, remainingPath);
-                File childUsingFullPath = new File(currentFile, remainingPath);
-                remainingPath = childUsingFullPath.getAbsolutePath().substring(directChild.getAbsolutePath().length());
-                
-                File childFileSymbolic = Util.resolveSymlinkToFile(directChild);
+                Path directChild = this.getDirectChild(currentFilePath, remainingPath);
+                Path childUsingFullPath = currentFilePath.resolve(remainingPath);
+                Path rel = directChild.toAbsolutePath().relativize(childUsingFullPath.toAbsolutePath());
+                remainingPath = rel.toString();
+
+                File childFileSymbolic = Util.resolveSymlinkToFile(directChild.toFile());
                 if (childFileSymbolic == null) {
-                    currentFile = directChild;
+                    currentFilePath = directChild;
                 } else {
-                    currentFile = childFileSymbolic;
+                    currentFilePath = childFileSymbolic.toPath();
+                }
+
+                Path currentFileAbsolutePath = currentFilePath.toAbsolutePath();
+                try{
+                    Path child = currentFileAbsolutePath.toRealPath();
+                    if (!child.startsWith(parentRealPath)) {
+                        return false;
+                    }
+                } catch (NoSuchFileException e) {
+                    // nonexistent file
+                    // in case this folder / file will be copied somewhere else, 
+                    // it becomes the responsibility of that system to check the isDescendant with the existing links
+                    // we are not taking the parentRealPath to avoid possible problem
+                    try {
+                        Path child = currentFileAbsolutePath.normalize();
+                        Path parent = parentAbsolutePath.normalize();
+                        return child.startsWith(parent);
+                    } catch (InvalidPathException e2) {
+                        throw new IOException(e2);
+                    }
                 }
             }
-            //TODO could be refactored using Util#isDescendant(File, File) from 2.80+
-            Path child = currentFile.getAbsoluteFile().toPath().normalize();
-            return child.startsWith(parent);
+            return true;
         }
-        private @CheckForNull File getDirectChild(File parentFile, String childPath){
-            File current = new File(parentFile, childPath);
-            while (current != null && !parentFile.equals(current.getParentFile())) {
-                current = current.getParentFile();
+        private @CheckForNull Path getDirectChild(Path parentPath, String childPath){
+            Path current = parentPath.resolve(childPath);
+            while (current != null && !parentPath.equals(current.getParent())) {
+                current = current.getParent();
             }
             return current;
         }",1,java,52.0,FilePath.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -0,0 +1,32 @@
+package com.ctrip.framework.apollo.adminservice;
+
+import com.ctrip.framework.apollo.adminservice.filter.AdminServiceAuthenticationFilter;
+import com.ctrip.framework.apollo.biz.config.BizConfig;
+import org.springframework.boot.web.servlet.FilterRegistrationBean;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+
+@Configuration
+public class AdminServiceAutoConfiguration {
+
+  private final BizConfig bizConfig;
+
+  public AdminServiceAutoConfiguration(final BizConfig bizConfig) {
+    this.bizConfig = bizConfig;
+  }
+
+  @Bean
+  public FilterRegistrationBean<AdminServiceAuthenticationFilter> adminServiceAuthenticationFilter() {
+    FilterRegistrationBean<AdminServiceAuthenticationFilter> filterRegistrationBean = new FilterRegistrationBean<>();
+
+    filterRegistrationBean.setFilter(new AdminServiceAuthenticationFilter(bizConfig));
+    filterRegistrationBean.addUrlPatterns(""/apps/*"");
+    filterRegistrationBean.addUrlPatterns(""/appnamespaces/*"");
+    filterRegistrationBean.addUrlPatterns(""/instances/*"");
+    filterRegistrationBean.addUrlPatterns(""/items/*"");
+    filterRegistrationBean.addUrlPatterns(""/namespaces/*"");
+    filterRegistrationBean.addUrlPatterns(""/releases/*"");
+
+    return filterRegistrationBean;
+  }
+}",1,java,26.0,apollo-adminservice/src/main/java/com/ctrip/framework/apollo/adminservice/AdminServiceAutoConfiguration.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -25,9 +25,7 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import java.security.GeneralSecurityException;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
@@ -68,7 +66,6 @@
     protected ExecutorService applicationThreadPool;
     protected ProxyServerSelector proxyServerSelector;
     protected SSLContext sslContext;
-    protected SSLEngineFactory sslEngineFactory;
     protected AsyncHttpProviderConfig<?, ?> providerConfig;
     protected ConnectionsPool<?, ?> connectionsPool;
     protected Realm realm;
@@ -86,6 +83,7 @@
     protected boolean useRelativeURIsWithSSLProxies;
     protected int maxConnectionLifeTimeInMs;
     protected TimeConverter timeConverter;
+    protected boolean acceptAnyCertificate;
     protected AsyncHttpClientConfig() {
     }
@@ -106,7 +104,6 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   ExecutorService applicationThreadPool,
                                   ProxyServerSelector proxyServerSelector,
                                   SSLContext sslContext,
-                                  SSLEngineFactory sslEngineFactory,
                                   AsyncHttpProviderConfig<?, ?> providerConfig,
                                   ConnectionsPool<?, ?> connectionsPool, Realm realm,
                                   List<RequestFilter> requestFilters,
@@ -121,7 +118,8 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   int ioThreadMultiplier,
                                   boolean strict302Handling,
                                   boolean useRelativeURIsWithSSLProxies,
-                                  TimeConverter timeConverter) {
+                                  TimeConverter timeConverter, //
+                                  boolean acceptAnyCertificate) {
         this.maxTotalConnections = maxTotalConnections;
         this.maxConnectionPerHost = maxConnectionPerHost;
@@ -137,7 +135,6 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.userAgent = userAgent;
         this.allowPoolingConnection = keepAlive;
         this.sslContext = sslContext;
-        this.sslEngineFactory = sslEngineFactory;
         this.providerConfig = providerConfig;
         this.connectionsPool = connectionsPool;
         this.realm = realm;
@@ -161,6 +158,7 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.proxyServerSelector = proxyServerSelector;
         this.disableUrlEncodingForBoundedRequests = disableUrlEncodingForBoundedRequests;
         this.timeConverter = timeConverter;
+        this.acceptAnyCertificate = acceptAnyCertificate;
     }
@@ -310,28 +308,6 @@ public SSLContext getSSLContext() {
         return connectionsPool;
     }
-    /**
-     * Return an instance of {@link SSLEngineFactory} used for SSL connection.
-     *
-     * @return an instance of {@link SSLEngineFactory} used for SSL connection.
-     */
-    public SSLEngineFactory getSSLEngineFactory() {
-        if (sslEngineFactory == null) {
-            return new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() {
-                    if (sslContext != null) {
-                        SSLEngine sslEngine = sslContext.createSSLEngine();
-                        sslEngine.setUseClientMode(true);
-                        return sslEngine;
-                    } else {
-                        return null;
-                    }
-                }
-            };
-        }
-        return sslEngineFactory;
-    }
-
@@ -491,12 +467,19 @@ public int getMaxConnectionLifeTimeInMs() {
     }
-     * @return 1.8.2
+     * since 1.8.2
     public TimeConverter getTimeConverter() {
         return timeConverter;
     }
+    /**
+     * since 1.9.0
+     */
+    public boolean isAcceptAnyCertificate() {
+        return acceptAnyCertificate;
+    }
+
@@ -525,11 +508,11 @@ public TimeConverter getTimeConverter() {
         private boolean removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
         private boolean strict302Handling = defaultStrict302Handling();
         private HostnameVerifier hostnameVerifier = defaultHostnameVerifier();
+        private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
         private ExecutorService applicationThreadPool;
         private ProxyServerSelector proxyServerSelector = null;
         private SSLContext sslContext;
-        private SSLEngineFactory sslEngineFactory;
         private AsyncHttpProviderConfig<?, ?> providerConfig;
         private ConnectionsPool<?, ?> connectionsPool;
         private Realm realm;
@@ -713,17 +696,6 @@ public Builder setProxyServer(ProxyServer proxyServer) {
             return this;
         }
-        /**
-         * Set the {@link SSLEngineFactory} for secure connection.
-         *
-         * @param sslEngineFactory the {@link SSLEngineFactory} for secure connection
-         * @return a {@link Builder}
-         */
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            this.sslEngineFactory = sslEngineFactory;
-            return this;
-        }
-
@@ -731,13 +703,6 @@ public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
         public Builder setSSLContext(final SSLContext sslContext) {
-            this.sslEngineFactory = new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() throws GeneralSecurityException {
-                    SSLEngine sslEngine = sslContext.createSSLEngine();
-                    sslEngine.setUseClientMode(true);
-                    return sslEngine;
-                }
-            };
             this.sslContext = sslContext;
             return this;
         }
@@ -998,6 +963,11 @@ public Builder setTimeConverter(TimeConverter timeConverter) {
             return this;
         }
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            this.acceptAnyCertificate = acceptAnyCertificate;
+            return this;
+        }
+
@@ -1018,7 +988,6 @@ public Builder(AsyncHttpClientConfig prototype) {
             realm = prototype.getRealm();
             requestTimeoutInMs = prototype.getRequestTimeoutInMs();
             sslContext = prototype.getSSLContext();
-            sslEngineFactory = prototype.getSSLEngineFactory();
             userAgent = prototype.getUserAgent();
             followRedirect = prototype.isFollowRedirect();
             compressionEnabled = prototype.isCompressionEnabled();
@@ -1041,6 +1010,7 @@ public Builder(AsyncHttpClientConfig prototype) {
             hostnameVerifier = prototype.getHostnameVerifier();
             strict302Handling = prototype.isStrict302Handling();
             timeConverter = prototype.timeConverter;
+            acceptAnyCertificate = prototype.acceptAnyCertificate;
         }
@@ -1073,40 +1043,39 @@ public Thread newThread(Runnable r) {
                 proxyServerSelector = ProxyServerSelector.NO_PROXY_SELECTOR;
             }
-            return new AsyncHttpClientConfig(maxTotalConnections,
-                    maxConnectionPerHost,
-                    connectionTimeOutInMs,
-                    webSocketIdleTimeoutInMs,
-                    idleConnectionInPoolTimeoutInMs,
-                    idleConnectionTimeoutInMs,
-                    requestTimeoutInMs,
-                    maxConnectionLifeTimeInMs,
-                    followRedirect,
-                    maxDefaultRedirects,
-                    compressionEnabled,
-                    userAgent,
-                    allowPoolingConnection,
-                    applicationThreadPool,
-                    proxyServerSelector,
-                    sslContext,
-                    sslEngineFactory,
-                    providerConfig,
-                    connectionsPool,
-                    realm,
-                    requestFilters,
-                    responseFilters,
-                    ioExceptionFilters,
-                    requestCompressionLevel,
-                    maxRequestRetry,
-                    allowSslConnectionPool,
-                    disableUrlEncodingForBoundedRequests,
-                    removeQueryParamOnRedirect,
-                    hostnameVerifier,
-                    ioThreadMultiplier,
-                    strict302Handling,
-                    useRelativeURIsWithSSLProxies,
-                    timeConverter);
+            return new AsyncHttpClientConfig(maxTotalConnections, //
+                    maxConnectionPerHost, //
+                    connectionTimeOutInMs, //
+                    webSocketIdleTimeoutInMs, //
+                    idleConnectionInPoolTimeoutInMs, //
+                    idleConnectionTimeoutInMs, //
+                    requestTimeoutInMs, //
+                    maxConnectionLifeTimeInMs, //
+                    followRedirect, //
+                    maxDefaultRedirects, //
+                    compressionEnabled, //
+                    userAgent, //
+                    allowPoolingConnection, //
+                    applicationThreadPool, //
+                    proxyServerSelector, //
+                    sslContext, //
+                    providerConfig, //
+                    connectionsPool, //
+                    realm, //
+                    requestFilters, //
+                    responseFilters, //
+                    ioExceptionFilters, //
+                    requestCompressionLevel, //
+                    maxRequestRetry, //
+                    allowSslConnectionPool, //
+                    disableUrlEncodingForBoundedRequests, //
+                    removeQueryParamOnRedirect, //
+                    hostnameVerifier, //
+                    ioThreadMultiplier, //
+                    strict302Handling, //
+                    useRelativeURIsWithSSLProxies, //
+                    timeConverter, //
+                    acceptAnyCertificate);
         }
     }
 }
-",1,java,114.0,src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
c19cc705688cfffa4fe735e0edbe84862b6c135f,jenkinsci/jenkins,train,"@@ -42,12 +42,16 @@ import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
 import java.nio.file.LinkOption;
 import java.util.ArrayList;
+import java.util.Deque;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nonnull;
 import jenkins.MasterToSlaveFileCallable;
+import org.kohsuke.accmod.Restricted;
+import org.kohsuke.accmod.restrictions.NoExternalUse;
@@ -208,6 +212,27 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
         return callable.call();
     }
+    /**
+     * Determine if the implementation supports the {@link #isDescendant(String)} method
+     *
+     * TODO un-restrict it in a weekly after the patch
+     */
+    @Restricted(NoExternalUse.class)
+    public boolean supportIsDescendant() {
+        return false;
+    }
+
+    /**
+     * Check if the relative path is really a descendant of this folder, following the symbolic links.
+     * Meant to be used in coordination with {@link #child(String)}.
+     *
+     * TODO un-restrict it in a weekly after the patch
+     */
+    @Restricted(NoExternalUse.class)
+    public boolean isDescendant(String childRelativePath) throws IOException {
+        return false;
+    }
+
@@ -301,6 +326,7 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
                     throw new IOException(e);
                 }
             }
+
         private boolean isIllegalSymlink() { // TODO JENKINS-26838
             try {
                 String myPath = f.toPath().toRealPath(new LinkOption[0]).toString();
@@ -316,6 +342,54 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
             }
             return false;
         }
+
+        /**
+         * TODO un-restrict it in a weekly after the patch
+         */
+        @Override
+        @Restricted(NoExternalUse.class)
+        public boolean supportIsDescendant() {
+            return true;
+        }
+
+        /**
+         * TODO un-restrict it in a weekly after the patch
+         */
+        @Override
+        @Restricted(NoExternalUse.class)
+        public boolean isDescendant(String potentialChildRelativePath) throws IOException {
+            if (new File(potentialChildRelativePath).isAbsolute()) {
+                throw new IllegalArgumentException(""Only a relative path is supported, the given path is absolute: "" + potentialChildRelativePath);
+            }
+            
+            FilePath root = new FilePath(this.root);
+            String relativePath = computeRelativePathToRoot();
+            
+            try {
+                return root.isDescendant(relativePath + potentialChildRelativePath);
+            }
+            catch (InterruptedException e) {
+                return false;
+            }
+        }
+
+        /**
+         * To be kept in sync with {@link FilePathVF#computeRelativePathToRoot()}
+         */
+        private String computeRelativePathToRoot(){
+            if (this.root.equals(this.f)) {
+                return """";
+            }
+            
+            Deque<String> relativePath = new LinkedList<>();
+            File current = this.f;
+            while (current != null && !current.equals(this.root)) {
+                relativePath.addFirst(current.getName());
+                current = current.getParentFile();
+            }
+            
+            return String.join(File.separator, relativePath) + File.separator;
+        }
     }
@@ -324,12 +398,14 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
     public static VirtualFile forFilePath(final FilePath f) {
-        return new FilePathVF(f);
+        return new FilePathVF(f, f);
     }
     private static final class FilePathVF extends VirtualFile {
         private final FilePath f;
-        FilePathVF(FilePath f) {
+        private final FilePath root;
+        FilePathVF(FilePath f, FilePath root) {
             this.f = f;
+            this.root = root;
         }
             @Override public String getName() {
                 return f.getName();
@@ -367,7 +443,7 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
                     List<FilePath> kids = f.list();
                     VirtualFile[] vfs = new VirtualFile[kids.size()];
                     for (int i = 0; i < vfs.length; i++) {
-                        vfs[i] = forFilePath(kids.get(i));
+                        vfs[i] = new FilePathVF(kids.get(i), this.root);
                     }
                     return vfs;
                 } catch (InterruptedException x) {
@@ -382,7 +458,7 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
                 }
             }
             @Override public VirtualFile child(String name) {
-                return forFilePath(f.child(name));
+                return new FilePathVF(f.child(name), this.root);
             }
             @Override public long length() throws IOException {
                 try {
@@ -419,6 +495,53 @@ public abstract class VirtualFile implements Comparable<VirtualFile>, Serializab
                     throw (IOException) new IOException(x.toString()).initCause(x);
                 }
             }
+
+        /**
+         * TODO un-restrict it in a weekly after the patch
+         */
+        @Override
+        @Restricted(NoExternalUse.class)
+        public boolean supportIsDescendant() {
+            return true;
+        }
+
+        /**
+         * TODO un-restrict it in a weekly after the patch
+         */
+        @Override
+        @Restricted(NoExternalUse.class)
+        public boolean isDescendant(String potentialChildRelativePath) throws IOException {
+            if (new File(potentialChildRelativePath).isAbsolute()) {
+                throw new IllegalArgumentException(""Only a relative path is supported, the given path is absolute: "" + potentialChildRelativePath);
+            }
+            
+            String relativePath = computeRelativePathToRoot();
+            
+            try {
+                return this.root.isDescendant(relativePath + potentialChildRelativePath);
+            }
+            catch (InterruptedException e) {
+                return false;
+            }
+        }
+
+        /**
+         * To be kept in sync with {@link FileVF#computeRelativePathToRoot()}
+         */
+        private String computeRelativePathToRoot(){
+            if (this.root.equals(this.f)) {
+                return """";
+            }
+
+            LinkedList<String> relativePath = new LinkedList<>();
+            FilePath current = this.f;
+            while (current != null && !current.equals(this.root)) {
+                relativePath.addFirst(current.getName());
+                current = current.getParent();
+            }
+
+            return String.join(File.separator, relativePath) + File.separator;
+        }
     }
     private static final class Scanner extends MasterToSlaveFileCallable<String[]> {
         private final String glob;",1,java,85.0,VirtualFile.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -567,8 +567,11 @@ protected void saveLanguageKeys(Language lang, Map<String, String> generalKeys,
 			CacheLocator.getLanguageCache().removeLanguageKeys( lang.getLanguageCode(), lang.getCountryCode() );
 			CacheLocator.getLanguageCache().removeLanguageKeys( lang.getLanguageCode(), null );
-			MultiMessageResources messages = (MultiMessageResources) Config.CONTEXT.getAttribute( Globals.MESSAGES_KEY );
-			messages.reload();
+			// doing instanceof so tests don't fail with Mockito
+			if(Config.CONTEXT.getAttribute( Globals.MESSAGES_KEY ) instanceof MultiMessageResources) {
+  			MultiMessageResources messages = (MultiMessageResources) Config.CONTEXT.getAttribute( Globals.MESSAGES_KEY );
+  			messages.reload();
+			}
 		} catch (IOException e) {
 			Logger.error(this, ""A IOException as occurred while saving the properties files"", e);
 			throw new DotRuntimeException(""A IOException as occurred while saving the properties files"", e);",1,java,6.0,dotCMS/src/main/java/com/dotmarketing/portlets/languagesmanager/business/LanguageFactoryImpl.java
ce5c3e8079d64929abb76ec3ec7ac7c71a4a26b6,dotCMS/core,train,"@@ -0,0 +1,87 @@
+package com.dotcms.filters.interceptor.dotcms;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import com.dotcms.filters.interceptor.Result;
+import com.dotcms.filters.interceptor.WebInterceptor;
+import com.dotcms.util.SecurityUtils;
+import com.dotmarketing.util.Config;
+
+/**
+ * Interceptor created to validate referers for incoming requests. This will reject any calls to
+ * URIs that do not include a valid referer or Origin header and will help prevent XSS attacks
+ */
+public class XSSPreventionWebInterceptor implements WebInterceptor {
+
+  private static final long serialVersionUID = 1L;
+
+  private static final String XSS_PROTECTED_PATHS = ""XSS_PROTECTED_PATHS"";
+  private static String[] protectedPaths = null;
+
+  // \A -> The beginning of the input
+  // All paths needs to be in lower case as the URI is lowercase before to be evaluated
+  private static final String[] XSS_PROTECTED_PATHS_DEFAULT ={
+          ""\\A/html/"", 
+          ""\\A/c/"", 
+          ""\\A/servlets"", 
+          ""\\A/servlet/"",
+          ""\\A/dottaillogservlet"", 
+          ""\\A/dwr/"",
+          ""\\A/dotajaxdirector"", 
+          ""\\A/dotscheduledjobs"", 
+          ""\\A/jsontags/"", 
+          ""\\A/edit/""
+      };
+
+  private final SecurityUtils securityUtils;
+  
+  public XSSPreventionWebInterceptor() {
+    this(new SecurityUtils());
+  }
+  
+  public XSSPreventionWebInterceptor(SecurityUtils securityUtils) {
+    this.securityUtils=securityUtils;
+  }
+
+  @Override
+  public String[] getFilters() {
+
+    return protectedPaths;
+  }
+
+  @Override
+  public void init() {
+    protectedPaths = Config.getStringArrayProperty(XSS_PROTECTED_PATHS, XSS_PROTECTED_PATHS_DEFAULT);
+  }
+
+  @Override
+  public Result intercept(final HttpServletRequest request, HttpServletResponse response) throws IOException {
+
+    Result result = Result.NEXT;
+    if(!securityUtils.validateReferer(request)) {
+      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
+      response.setContentType(""text/html"");
+      response.getWriter().print(unauthorizedHtmlResponse());
+      response.getWriter().close();
+      result = Result.SKIP_NO_CHAIN;
+    }
+   
+
+    return result; // if it is log in, continue!
+  }
+
+  /**
+   * HTML response that will be mainly use for angular in order to identify we have a 401. Basically
+   * from angular there is not a simpler way to identify the status of the requested URL by an iframe
+   * but angular can check things like the title of the iframe and handle according to that.
+   */
+  private String unauthorizedHtmlResponse() {
+
+    return """" + ""<html>\n"" + "" <head>\n"" + ""     <title>401</title>\n"" + "" </head>\n"" + "" <body>"" + ""     <h1>401 / Unauthorized</h1>\n"";
+
+  }
+
+}",1,java,56.0,dotCMS/src/main/java/com/dotcms/filters/interceptor/dotcms/XSSPreventionWebInterceptor.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -46,7 +46,6 @@ public class AccountFederatedIdentityBean {
     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {
         this.session = session;
-        URI accountIdentityUpdateUri = Urls.accountFederatedIdentityUpdate(baseUri, realm.getName());
         List<IdentityProviderModel> identityProviders = realm.getIdentityProviders();
         Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);
@@ -63,15 +62,8 @@ public class AccountFederatedIdentityBean {
                     availableIdentities++;
                 }
-                String action = identity != null ? ""remove"" : ""add"";
-                String actionUrl = UriBuilder.fromUri(accountIdentityUpdateUri)
-                        .queryParam(""action"", action)
-                        .queryParam(""provider_id"", providerId)
-                        .queryParam(""stateChecker"", stateChecker)
-                        .build().toString();
-
                 String displayName = KeycloakModelUtils.getIdentityProviderDisplayName(session, provider);
-                FederatedIdentityEntry entry = new FederatedIdentityEntry(identity, displayName, provider.getAlias(), provider.getAlias(), actionUrl,
+                FederatedIdentityEntry entry = new FederatedIdentityEntry(identity, displayName, provider.getAlias(), provider.getAlias(),
                 		  															provider.getConfig() != null ? provider.getConfig().get(""guiOrder"") : null);
                 orderedSet.add(entry);
             }
@@ -105,17 +97,15 @@ public class AccountFederatedIdentityBean {
         private FederatedIdentityModel federatedIdentityModel;
         private final String providerId;
 		private final String providerName;
-        private final String actionUrl;
         private final String guiOrder;
         private final String displayName;
         public FederatedIdentityEntry(FederatedIdentityModel federatedIdentityModel, String displayName, String providerId,
-                                      String providerName, String actionUrl, String guiOrder) {
+                                      String providerName, String guiOrder) {
             this.federatedIdentityModel = federatedIdentityModel;
             this.displayName = displayName;
             this.providerId = providerId;
             this.providerName = providerName;
-            this.actionUrl = actionUrl;
             this.guiOrder = guiOrder;
         }
@@ -139,10 +129,6 @@ public class AccountFederatedIdentityBean {
             return federatedIdentityModel != null;
         }
-        public String getActionUrl() {
-            return actionUrl;
-        }
-        
         public String getGuiOrder() {
             return guiOrder;
         }
@@ -186,4 +172,4 @@ public class AccountFederatedIdentityBean {
 			return 10000;
 		}
 	}
-}
\ No newline at end of file
+}",1,java,18.0,AccountFederatedIdentityBean.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -17,12 +17,15 @@
 package com.googlecode.wicket.jquery.core.utils;
 import org.apache.wicket.Component;
+import org.apache.wicket.Page;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import org.apache.wicket.event.Broadcast;
 import com.googlecode.wicket.jquery.core.ajax.AjaxPayload;
+import com.googlecode.wicket.jquery.core.ajax.HandlerPayload;
- * Utility class for handling for broadcasting {@link AjaxPayload}{@code s}
+ * Utility class for handling for broadcasting {@link HandlerPayload}{@code s}
@@ -43,41 +46,133 @@ public class BroadcastUtils
+	@Deprecated
 	public static void breadth(Component component, AjaxPayload payload)
 	{
 		component.send(component, Broadcast.BREADTH, payload);
 	}
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#BREADTH} mode
+	 * 
+	 * @param component the sink {@link Component}, likely a page
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void breadth(Component component, HandlerPayload payload)
+	{
+		component.send(component, Broadcast.BREADTH, payload);
+	}
+
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#BREADTH} mode
+	 * 
+	 * @param handler the {@link IPartialPageRequestHandler} holding the sink {@link Page}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void breadth(IPartialPageRequestHandler handler, HandlerPayload payload)
+	{
+		BroadcastUtils.breadth((Page) handler.getPage(), payload);
+	}
+
+	@Deprecated
 	public static void bubble(Component component, AjaxPayload payload)
 	{
 		component.send(component, Broadcast.BUBBLE, payload);
 	}
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#BUBBLE} mode
+	 * 
+	 * @param component the sink {@link Component}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void bubble(Component component, HandlerPayload payload)
+	{
+		component.send(component, Broadcast.BUBBLE, payload);
+	}
+
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#BUBBLE} mode
+	 * 
+	 * @param handler the {@link IPartialPageRequestHandler} holding the sink {@link Page}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void bubble(IPartialPageRequestHandler handler, HandlerPayload payload)
+	{
+		BroadcastUtils.bubble((Page) handler.getPage(), payload);
+	}
+
+	@Deprecated
 	public static void depth(Component component, AjaxPayload payload)
 	{
 		component.send(component, Broadcast.DEPTH, payload);
 	}
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#DEPTH} mode
+	 * 
+	 * @param component the sink {@link Component}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void depth(Component component, HandlerPayload payload)
+	{
+		component.send(component, Broadcast.DEPTH, payload);
+	}
+
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#DEPTH} mode
+	 * 
+	 * @param handler the {@link IPartialPageRequestHandler} holding the sink {@link Page}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void depth(IPartialPageRequestHandler handler, HandlerPayload payload)
+	{
+		BroadcastUtils.depth((Page) handler.getPage(), payload);
+	}
+
+	@Deprecated
 	public static void exact(Component component, AjaxPayload payload)
 	{
 		component.send(component, Broadcast.EXACT, payload);
 	}
+
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#EXACT} mode
+	 * 
+	 * @param component the sink {@link Component}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void exact(Component component, HandlerPayload payload)
+	{
+		component.send(component, Broadcast.EXACT, payload);
+	}
+
+	/**
+	 * Sends an {@link HandlerPayload} in {@link Broadcast#EXACT} mode
+	 * 
+	 * @param handler the {@link IPartialPageRequestHandler} holding the sink {@link Page}
+	 * @param payload the {@link HandlerPayload}
+	 */
+	public static void exact(IPartialPageRequestHandler handler, HandlerPayload payload)
+	{
+		BroadcastUtils.exact((Page) handler.getPage(), payload);
+	}
 }",1,java,40.0,BroadcastUtils.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -24,7 +24,7 @@
 import org.bouncycastle.crypto.KeyEncoder;
 import org.bouncycastle.crypto.agreement.ECDHBasicAgreement;
 import org.bouncycastle.crypto.digests.SHA1Digest;
-import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.AESEngine;
 import org.bouncycastle.crypto.engines.DESedeEngine;
 import org.bouncycastle.crypto.engines.IESEngine;
 import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
@@ -538,7 +538,7 @@ public ECIESwithDESedeCBC()
     {
         public ECIESwithAESCBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), 16);
+            super(new CBCBlockCipher(new AESEngine()), 16);
         }
     }
 }",1,java,4.0,IESCipher.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -39,17 +39,11 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 import org.apache.poi.util.ReplacingInputStream;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.ActivityCode;
 import net.sf.mpxj.ActivityCodeContainer;
@@ -84,6 +78,7 @@
 import net.sf.mpxj.common.BooleanHelper;
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.primavera.schema.APIBusinessObjects;
 import net.sf.mpxj.primavera.schema.ActivityCodeType;
@@ -265,25 +260,12 @@ private APIBusinessObjects processFile(InputStream stream) throws MPXJException
    {
       try
       {
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
          if (CONTEXT == null)
          {
             throw CONTEXT_EXCEPTION;
          }
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(configureInputSource(stream));
-
-         return (APIBusinessObjects) unmarshallerHandler.getResult();
+         return (APIBusinessObjects) UnmarshalHelper.unmarshal(CONTEXT, configureInputSource(stream), new NamespaceFilter(), false);
       }
       catch (ParserConfigurationException ex)",1,java,20.0,src/main/java/net/sf/mpxj/primavera/PrimaveraPMFileReader.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2020, PostgreSQL Global Development Group
+ * See the LICENSE file in the project root for more information.
+ */
+
+package org.postgresql.xml;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import javax.xml.XMLConstants;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.sax.SAXTransformerFactory;
+
+/**
+ * Default implementation of PGXmlFactoryFactory that configures each factory per OWASP recommendations.
+ *
+ * @see <a href=""https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</a>
+ */
+public class DefaultPGXmlFactoryFactory implements PGXmlFactoryFactory {
+  public static final DefaultPGXmlFactoryFactory INSTANCE = new DefaultPGXmlFactoryFactory();
+
+  private DefaultPGXmlFactoryFactory() {
+  }
+
+  private DocumentBuilderFactory getDocumentBuilderFactory() {
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+    setFactoryProperties(factory);
+    factory.setXIncludeAware(false);
+    factory.setExpandEntityReferences(false);
+    return factory;
+  }
+
+  @Override
+  public DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
+    DocumentBuilder builder = getDocumentBuilderFactory().newDocumentBuilder();
+    builder.setEntityResolver(EmptyStringEntityResolver.INSTANCE);
+    builder.setErrorHandler(NullErrorHandler.INSTANCE);
+    return builder;
+  }
+
+  @Override
+  public TransformerFactory newTransformerFactory() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    setFactoryProperties(factory);
+    return factory;
+  }
+
+  @Override
+  public SAXTransformerFactory newSAXTransformerFactory() {
+    SAXTransformerFactory factory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+    setFactoryProperties(factory);
+    return factory;
+  }
+
+  @Override
+  public XMLInputFactory newXMLInputFactory() {
+    XMLInputFactory factory = XMLInputFactory.newInstance();
+    setPropertyQuietly(factory, XMLInputFactory.SUPPORT_DTD, false);
+    setPropertyQuietly(factory, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
+    return factory;
+  }
+
+  @Override
+  public XMLOutputFactory newXMLOutputFactory() {
+    XMLOutputFactory factory = XMLOutputFactory.newInstance();
+    return factory;
+  }
+
+  @Override
+  public XMLReader createXMLReader() throws SAXException {
+    XMLReader factory = XMLReaderFactory.createXMLReader();
+    setFeatureQuietly(factory, ""http://apache.org/xml/features/disallow-doctype-decl"", true);
+    setFeatureQuietly(factory, ""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+    setFeatureQuietly(factory, ""http://xml.org/sax/features/external-general-entities"", false);
+    setFeatureQuietly(factory, ""http://xml.org/sax/features/external-parameter-entities"", false);
+    factory.setErrorHandler(NullErrorHandler.INSTANCE);
+    return factory;
+  }
+
+  private static void setFeatureQuietly(Object factory, String name, boolean value) {
+    try {
+      if (factory instanceof DocumentBuilderFactory) {
+        ((DocumentBuilderFactory) factory).setFeature(name, value);
+      } else if (factory instanceof TransformerFactory) {
+        ((TransformerFactory) factory).setFeature(name, value);
+      } else if (factory instanceof XMLReader) {
+        ((XMLReader) factory).setFeature(name, value);
+      } else {
+        throw new Error(""Invalid factory class: "" + factory.getClass());
+      }
+      return;
+    } catch (Exception ignore) {
+    }
+  }
+
+  private static void setAttributeQuietly(Object factory, String name, Object value) {
+    try {
+      if (factory instanceof DocumentBuilderFactory) {
+        ((DocumentBuilderFactory) factory).setAttribute(name, value);
+      } else if (factory instanceof TransformerFactory) {
+        ((TransformerFactory) factory).setAttribute(name, value);
+      } else {
+        throw new Error(""Invalid factory class: "" + factory.getClass());
+      }
+    } catch (Exception ignore) {
+    }
+  }
+
+  private static void setFactoryProperties(Object factory) {
+    setFeatureQuietly(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true);
+    setFeatureQuietly(factory, ""http://apache.org/xml/features/disallow-doctype-decl"", true);
+    setFeatureQuietly(factory, ""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+    setFeatureQuietly(factory, ""http://xml.org/sax/features/external-general-entities"", false);
+    setFeatureQuietly(factory, ""http://xml.org/sax/features/external-parameter-entities"", false);
+    // Values from XMLConstants inlined for JDK 1.6 compatibility
+    setAttributeQuietly(factory, ""http://javax.xml.XMLConstants/property/accessExternalDTD"", """");
+    setAttributeQuietly(factory, ""http://javax.xml.XMLConstants/property/accessExternalSchema"", """");
+    setAttributeQuietly(factory, ""http://javax.xml.XMLConstants/property/accessExternalStylesheet"", """");
+  }
+
+  private static void setPropertyQuietly(Object factory, String name, Object value) {
+    try {
+      if (factory instanceof XMLReader) {
+        ((XMLReader) factory).setProperty(name, value);
+      } else if (factory instanceof XMLInputFactory) {
+        ((XMLInputFactory) factory).setProperty(name, value);
+      } else {
+        throw new Error(""Invalid factory class: "" + factory.getClass());
+      }
+    } catch (Exception ignore) {
+    }
+  }
+}",1,java,115.0,pgjdbc/src/main/java/org/postgresql/xml/DefaultPGXmlFactoryFactory.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -4,6 +4,7 @@
 import com.dotcms.business.WrapInTransaction;
 import com.dotcms.languagevariable.business.LanguageVariableAPI;
 import com.dotcms.rendering.velocity.util.VelocityUtil;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.dotcms.util.CollectionsUtils;
 import com.dotmarketing.business.APILocator;
@@ -22,6 +23,10 @@
 import com.liferay.portal.language.LanguageUtil;
 import com.liferay.portal.model.User;
 import com.liferay.util.StringPool;
+
+import static com.dotcms.util.CollectionsUtils.map;
+
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -247,13 +252,31 @@ public void saveLanguageKeys(final Language lang, final Map<String, String> gene
             factory.saveLanguageKeys(lang, generalKeys, specificKeys, toDeleteKeys);
             Logger.debug(this, ""Created language file for lang: "" + lang);
         } catch (DotDataException e) {
-
-            if ( Logger.isErrorEnabled(LanguageAPIImpl.class) ) {
-                Logger.error(LanguageAPIImpl.class, e.getMessage(), e);
-            }
+          Logger.error(LanguageAPIImpl.class, e.getMessage(), e);
         }
 	}
+	
+  @CloseDBIfOpened
+  @Override
+  public Map<String, String> getStringsAsMap(final Locale locale, final Collection<String> keys) {
+    final Map<String, String> messagesMap = new HashMap<>();
+
+    if (null != keys) {
+      final Language lang = APILocator.getLanguageAPI().getLanguage(locale.getLanguage(), locale.getCountry());
+      keys.forEach(messageKey -> {
+
+          String message = (lang != null) 
+              ? getStringKey(lang, messageKey)
+              : getStringFromPropertiesFile(locale, messageKey) ;
+          message = (message == null) ? messageKey : message;
+          messagesMap.put(messageKey, message);
+
+      });
+    }
+    return messagesMap;
+  }
+	
 	@CloseDBIfOpened
 	@Override
     public String getStringKey ( final Language lang, final String key ) {
@@ -262,25 +285,22 @@ public String getStringKey ( final Language lang, final String key ) {
         final String value = getLanguageVariableAPI().getLanguageVariableRespectingFrontEndRoles(key, lang.getId(), user);
-		// Language.properties file
-        return (UtilMethods.isNotSet(value) || value.equals(key)) ? this.getStringFromPropertiesFile(lang, key) : value;
+        final String countryCode = null == lang.getCountryCode()?"""":lang.getCountryCode();
+        return (UtilMethods.isNotSet(value) || value.equals(key)) ? this.getStringFromPropertiesFile(new Locale( lang.getLanguageCode(), countryCode ), key) : value;
     }
-    private String getStringFromPropertiesFile (final Language lang, final String key) {
-
+    private String getStringFromPropertiesFile (final Locale locale, final String key) {
         String value = null;
-
         try {
-        	final String countryCode = null == lang.getCountryCode()?"""":lang.getCountryCode();
-            value = LanguageUtil.get( new Locale( lang.getLanguageCode(), countryCode ), key );
+            value = LanguageUtil.get( locale, key );
         } catch ( LanguageException e ) {
             Logger.error( this, e.getMessage(), e );
         }
-
         return value;
     }
-	private User getUser() {
+    @VisibleForTesting
+	protected User getUser() {
 		User user = null;",1,java,34.0,dotCMS/src/main/java/com/dotmarketing/portlets/languagesmanager/business/LanguageAPIImpl.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -18,6 +18,10 @@ public final class V2 {
         public static final String UI_START_EVENT_TRIGGER = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-start-event-trigger.v2+json;charset=UTF-8"";
         public static final String UI_START_DRAFT_TRIGGER = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-start-draft-trigger.v2+json;charset=UTF-8"";
         public static final String UI_USER_PROFILE = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-user-profile.v2+json;charset=UTF-8"";
+        public static final String UI_DRAFT_READ = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-draft-read.v2+json;charset=UTF-8"";
+        public static final String UI_DRAFT_CREATE = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-draft-create.v2+json;charset=UTF-8"";
+        public static final String UI_DRAFT_UPDATE = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-draft-update.v2+json;charset=UTF-8"";
+        public static final String UI_DRAFT_DELETE = ""application/vnd.uk.gov.hmcts.ccd-data-store-api.ui-draft-delete.v2+json;charset=UTF-8"";
 
     }
 }
",1,java,5.0,V2.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -33,6 +33,7 @@ import org.jooby.scope.RequestScoped;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.net.UrlEscapers;
 import com.google.inject.Key;
 import com.google.inject.TypeLiteral;
 
@@ -69,6 +70,11 @@ public interface Request extends Registry {
       return req.path();
     }
 
+    @Override
+    public String path(final boolean escape) {
+      return req.path(escape);
+    }
+
     @Override
     public boolean matches(final String pattern) {
       return req.matches(pattern);
@@ -134,16 +140,31 @@ public interface Request extends Registry {
       return req.params();
     }
 
+    @Override
+    public Mutant params(final String... xss) {
+      return req.params(xss);
+    }
+
     @Override
     public <T> T params(final Class<T> type) {
       return req.params(type);
     }
 
+    @Override
+    public <T> T params(final Class<T> type, final String... xss) {
+      return req.params(type, xss);
+    }
+
     @Override
     public Mutant param(final String name) {
       return req.param(name);
     }
 
+    @Override
+    public Mutant param(final String name, final String... xss) {
+      return req.param(name, xss);
+    }
+
     @Override
     public Upload file(final String name) {
       return req.file(name);
@@ -159,6 +180,11 @@ public interface Request extends Registry {
       return req.header(name);
     }
 
+    @Override
+    public Mutant header(final String name, final String... xss) {
+      return req.header(name, xss);
+    }
+
     @Override
     public Map<String, Mutant> headers() {
       return req.headers();
@@ -389,7 +415,23 @@ public interface Request extends Registry {
    * @return The request URL pathname.
    */
   default String path() {
-    return route().path();
+    return path(false);
+  }
+
+  /**
+   * Escape the path using {@link UrlEscapers#urlFragmentEscaper()}.
+   *
+   * Given:
+   *
+   * <pre>{@code
+   *  http://domain.com/404<h1>X</h1> {@literal ->} /404%3Ch1%3EX%3C/h1%3E
+   * }</pre>
+   *
+   * @return The request URL pathname.
+   */
+  default String path(final boolean escape) {
+    String path = route().path();
+    return escape ? UrlEscapers.urlFragmentEscaper().escape(path) : path;
   }
 
   /**
@@ -573,6 +615,22 @@ public interface Request extends Registry {
    */
   Mutant params();
 
+  /**
+   * Get all the available parameters. A HTTP parameter can be provided in any of
+   * these forms:
+   *
+   * <ul>
+   * <li>Path parameter, like: <code>/path/:name</code> or <code>/path/{name}</code></li>
+   * <li>Query parameter, like: <code>?name=jooby</code></li>
+   * <li>Body parameter when <code>Content-Type</code> is
+   * <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code></li>
+   * </ul>
+   *
+   * @param xss Xss filter to apply.
+   * @return All the parameters.
+   */
+  Mutant params(String... xss);
+
   /**
    * Short version of <code>params().to(type)</code>.
    *
@@ -584,6 +642,18 @@ public interface Request extends Registry {
     return params().to(type);
   }
 
+  /**
+   * Short version of <code>params(xss).to(type)</code>.
+   *
+   * @param type Object type.
+   * @param xss Xss filter to apply.
+   * @param <T> Value type.
+   * @return Instance of object.
+   */
+  default <T> T params(final Class<T> type, final String... xss) {
+    return params(xss).to(type);
+  }
+
   /**
    * Get a HTTP request parameter under the given name. A HTTP parameter can be provided in any of
    * these forms:
@@ -613,6 +683,36 @@ public interface Request extends Registry {
    */
   Mutant param(String name);
 
+  /**
+   * Get a HTTP request parameter under the given name. A HTTP parameter can be provided in any of
+   * these forms:
+   * <ul>
+   * <li>Path parameter, like: <code>/path/:name</code> or <code>/path/{name}</code></li>
+   * <li>Query parameter, like: <code>?name=jooby</code></li>
+   * <li>Body parameter when <code>Content-Type</code> is
+   * <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code></li>
+   * </ul>
+   *
+   * The order of precedence is: <code>path</code>, <code>query</code> and <code>body</code>. For
+   * example a pattern like: <code>GET /path/:name</code> for <code>/path/jooby?name=rocks</code>
+   * produces:
+   *
+   * <pre>
+   *  assertEquals(""jooby"", req.param(name).value());
+   *
+   *  assertEquals(""jooby"", req.param(name).toList().get(0));
+   *  assertEquals(""rocks"", req.param(name).toList().get(1));
+   * </pre>
+   *
+   * Uploads can be retrieved too when <code>Content-Type</code> is <code>multipart/form-data</code>
+   * see {@link Upload} for more information.
+   *
+   * @param name A parameter's name.
+   * @param xss Xss filter to apply.
+   * @return A HTTP request parameter.
+   */
+  Mutant param(String name, String... xss);
+
   /**
    * Get a file {@link Upload} with the given name. The request must be a POST with
    * <code>multipart/form-data</code> content-type.
@@ -643,6 +743,15 @@ public interface Request extends Registry {
    */
   Mutant header(String name);
 
+  /**
+   * Get a HTTP header and apply the XSS escapers.
+   *
+   * @param name A header's name.
+   * @param xss Xss escapers.
+   * @return A HTTP request header.
+   */
+  Mutant header(final String name, final String... xss);
+
   /**
    * @return All the headers.
    */
",1,java,33.0,Request.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -31,15 +31,9 @@ import java.util.Map;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
 
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.Day;
@@ -54,6 +48,7 @@ import net.sf.mpxj.ProjectFile;
 import net.sf.mpxj.ProjectProperties;
 import net.sf.mpxj.RelationType;
 import net.sf.mpxj.Task;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.ganttdesigner.schema.Gantt;
 import net.sf.mpxj.ganttdesigner.schema.GanttDesignerRemark;
 import net.sf.mpxj.listener.ProjectListener;
@@ -83,6 +78,11 @@ public final class GanttDesignerReader extends AbstractProjectReader
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_taskMap = new HashMap<>();
@@ -95,19 +95,7 @@ public final class GanttDesignerReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Gantt gantt = (Gantt) unmarshaller.unmarshal(doc);
+         Gantt gantt = (Gantt) UnmarshalHelper.unmarshal(CONTEXT, stream);
 
          readProjectProperties(gantt);
          readCalendar(gantt);
",1,java,22.0,GanttDesignerReader.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -178,26 +178,19 @@ private AsymmetricCipherKeyPair genKeyPair()
         for (int h = numLayer - 1; h >= 0; h--)
         {
-            GMSSRootCalc tree = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);
-            try
-            {
-                // on lowest layer no lower root is available, so just call
-                // the method with null as first parameter
-                if (h == numLayer - 1)
-                {
-                    tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);
-                }
-                else
-                // otherwise call the method with the former computed root
-                // value
-                {
-                    tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);
-                }
+            GMSSRootCalc tree;
+            // on lowest layer no lower root is available, so just call
+            // the method with null as first parameter
+            if (h == numLayer - 1)
+            {
+                tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);
             }
-            catch (Exception e1)
+            else
+            // otherwise call the method with the former computed root
+            // value
             {
-                e1.printStackTrace();
+                tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);
             }",1,java,19.0,core/src/main/java/org/bouncycastle/pqc/crypto/gmss/GMSSKeyPairGenerator.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -33,7 +33,6 @@ public class UrlBean {
     private URI baseURI;
     private URI baseQueryURI;
     private URI currentURI;
-    private String stateChecker;
     public UrlBean(RealmModel realm, Theme theme, URI baseURI, URI baseQueryURI, URI currentURI, String stateChecker) {
         this.realm = realm.getName();
@@ -41,7 +40,6 @@ public class UrlBean {
         this.baseURI = baseURI;
         this.baseQueryURI = baseQueryURI;
         this.currentURI = currentURI;
-        this.stateChecker = stateChecker;
     }
     public String getApplicationsUrl() {
@@ -73,7 +71,7 @@ public class UrlBean {
     }
     public String getSessionsLogoutUrl() {
-        return Urls.accountSessionsLogoutPage(baseQueryURI, realm, stateChecker).toString();
+        return Urls.accountSessionsLogoutPage(baseQueryURI, realm).toString();
     }
     public String getRevokeClientUrl() {
@@ -81,7 +79,7 @@ public class UrlBean {
     }
     public String getTotpRemoveUrl() {
-        return Urls.accountTotpRemove(baseQueryURI, realm, stateChecker).toString();
+        return Urls.accountTotpRemove(baseQueryURI, realm).toString();
     }
     public String getLogoutUrl() {",1,java,6.0,UrlBean.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -1,18 +1,30 @@
 package com.ctrip.framework.apollo.portal.component;
 import com.ctrip.framework.apollo.common.exception.ServiceException;
-import com.ctrip.framework.apollo.portal.environment.PortalMetaDomainService;
 import com.ctrip.framework.apollo.core.dto.ServiceDTO;
-import com.ctrip.framework.apollo.portal.environment.Env;
+import com.ctrip.framework.apollo.portal.component.config.PortalConfig;
 import com.ctrip.framework.apollo.portal.constant.TracerEventType;
+import com.ctrip.framework.apollo.portal.environment.Env;
+import com.ctrip.framework.apollo.portal.environment.PortalMetaDomainService;
 import com.ctrip.framework.apollo.tracer.Tracer;
 import com.ctrip.framework.apollo.tracer.spi.Transaction;
+import com.google.common.base.Strings;
+import com.google.common.collect.Maps;
+import com.google.gson.Gson;
+import com.google.gson.reflect.TypeToken;
+import java.lang.reflect.Type;
+import java.net.SocketTimeoutException;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.PostConstruct;
 import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.conn.HttpHostConnectException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.context.annotation.Lazy;
 import org.springframework.core.ParameterizedTypeReference;
+import org.springframework.http.HttpEntity;
+import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;
 import org.springframework.http.ResponseEntity;
 import org.springframework.stereotype.Component;
@@ -22,10 +34,6 @@
 import org.springframework.web.util.DefaultUriBuilderFactory;
 import org.springframework.web.util.UriTemplateHandler;
-import javax.annotation.PostConstruct;
-import java.net.SocketTimeoutException;
-import java.util.List;
-
@@ -36,20 +44,31 @@
   private UriTemplateHandler uriTemplateHandler = new DefaultUriBuilderFactory();
+  private Gson gson = new Gson();
+  /**
+   * Admin service access tokens in ""PortalDB.ServerConfig""
+   */
+  private static final Type ACCESS_TOKENS = new TypeToken<Map<String, String>>(){}.getType();
+
   private RestTemplate restTemplate;
   private final RestTemplateFactory restTemplateFactory;
   private final AdminServiceAddressLocator adminServiceAddressLocator;
   private final PortalMetaDomainService portalMetaDomainService;
+  private final PortalConfig portalConfig;
+  private volatile String lastAdminServiceAccessTokens;
+  private volatile Map<Env, String> adminServiceAccessTokenMap;
   public RetryableRestTemplate(
       final @Lazy RestTemplateFactory restTemplateFactory,
       final @Lazy AdminServiceAddressLocator adminServiceAddressLocator,
-      final PortalMetaDomainService portalMetaDomainService
+      final PortalMetaDomainService portalMetaDomainService,
+      final PortalConfig portalConfig
   ) {
     this.restTemplateFactory = restTemplateFactory;
     this.adminServiceAddressLocator = adminServiceAddressLocator;
     this.portalMetaDomainService = portalMetaDomainService;
+    this.portalConfig = portalConfig;
   }
@@ -95,11 +114,12 @@ public void delete(Env env, String path, Object... urlVariables) throws RestClie
     ct.addData(""Env"", env);
     List<ServiceDTO> services = getAdminServices(env, ct);
+    HttpHeaders extraHeaders = assembleExtraHeaders(env);
     for (ServiceDTO serviceDTO : services) {
       try {
-        T result = doExecute(method, serviceDTO, path, request, responseType, uriVariables);
+        T result = doExecute(method, extraHeaders, serviceDTO, path, request, responseType, uriVariables);
         ct.setStatus(Transaction.SUCCESS);
         ct.complete();
@@ -137,12 +157,13 @@ public void delete(Env env, String path, Object... urlVariables) throws RestClie
     ct.addData(""Env"", env);
     List<ServiceDTO> services = getAdminServices(env, ct);
+    HttpEntity<Void> entity = new HttpEntity<>(assembleExtraHeaders(env));
     for (ServiceDTO serviceDTO : services) {
       try {
         ResponseEntity<T> result =
-            restTemplate.exchange(parseHost(serviceDTO) + path, HttpMethod.GET, null, reference, uriVariables);
+            restTemplate.exchange(parseHost(serviceDTO) + path, HttpMethod.GET, entity, reference, uriVariables);
         ct.setStatus(Transaction.SUCCESS);
         ct.complete();
@@ -171,6 +192,18 @@ public void delete(Env env, String path, Object... urlVariables) throws RestClie
   }
+  private HttpHeaders assembleExtraHeaders(Env env) {
+    String adminServiceAccessToken = getAdminServiceAccessToken(env);
+
+    if (!Strings.isNullOrEmpty(adminServiceAccessToken)) {
+      HttpHeaders headers = new HttpHeaders();
+      headers.add(HttpHeaders.AUTHORIZATION, adminServiceAccessToken);
+      return headers;
+    }
+
+    return null;
+  }
+
   private List<ServiceDTO> getAdminServices(Env env, Transaction ct) {
     List<ServiceDTO> services = adminServiceAddressLocator.getServiceList(env);
@@ -188,23 +221,61 @@ public void delete(Env env, String path, Object... urlVariables) throws RestClie
     return services;
   }
-  private <T> T doExecute(HttpMethod method, ServiceDTO service, String path, Object request,
-                          Class<T> responseType,
-                          Object... uriVariables) {
+  private String getAdminServiceAccessToken(Env env) {
+    String accessTokens = portalConfig.getAdminServiceAccessTokens();
+
+    if (Strings.isNullOrEmpty(accessTokens)) {
+      return null;
+    }
+
+    if (!accessTokens.equals(lastAdminServiceAccessTokens)) {
+      synchronized (this) {
+        adminServiceAccessTokenMap = parseAdminServiceAccessTokens(accessTokens);
+        lastAdminServiceAccessTokens = accessTokens;
+      }
+    }
+
+    return adminServiceAccessTokenMap.get(env);
+  }
+
+  private Map<Env, String> parseAdminServiceAccessTokens(String accessTokens) {
+    Map<Env, String> tokenMap = Maps.newHashMap();
+    try {
+      // try to parse
+      Map<String, String> map = gson.fromJson(accessTokens, ACCESS_TOKENS);
+      map.forEach((env, token) -> {
+        if (Env.exists(env)) {
+          tokenMap.put(Env.valueOf(env), token);
+        }
+      });
+    } catch (Exception e) {
+      logger.error(""Wrong format of admin service access tokens: {}"", accessTokens, e);
+    }
+    return tokenMap;
+  }
+  private <T> T doExecute(HttpMethod method, HttpHeaders extraHeaders, ServiceDTO service, String path, Object request,
+                          Class<T> responseType, Object... uriVariables) {
     T result = null;
     switch (method) {
       case GET:
-        result = restTemplate.getForObject(parseHost(service) + path, responseType, uriVariables);
-        break;
       case POST:
-        result =
-            restTemplate.postForEntity(parseHost(service) + path, request, responseType, uriVariables).getBody();
-        break;
       case PUT:
-        restTemplate.put(parseHost(service) + path, request, uriVariables);
-        break;
       case DELETE:
-        restTemplate.delete(parseHost(service) + path, uriVariables);
+        HttpEntity entity;
+        if (request instanceof HttpEntity) {
+          entity = (HttpEntity) request;
+          if (!CollectionUtils.isEmpty(extraHeaders)) {
+            HttpHeaders headers = new HttpHeaders();
+            headers.addAll(entity.getHeaders());
+            headers.addAll(extraHeaders);
+            entity = new HttpEntity<>(entity.getBody(), headers);
+          }
+        } else {
+          entity = new HttpEntity<>(request, extraHeaders);
+        }
+        result = restTemplate
+            .exchange(parseHost(service) + path, method, entity, responseType, uriVariables)
+            .getBody();
         break;
       default:
         throw new UnsupportedOperationException(String.format(""unsupported http method(method=%s)"", method));",1,java,98.0,apollo-portal/src/main/java/com/ctrip/framework/apollo/portal/component/RetryableRestTemplate.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -45,12 +45,12 @@ public AbstractBlockCipherBean(
   protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)
   {
     final BlockCipherAdapter cipher = newCipher(header, mode);
-    final byte[] headerBytes = header.encode();
     int outOff;
     final int inOff;
     final int length;
     final byte[] output;
     if (mode) {
+      final byte[] headerBytes = header.encode();
       final int outSize = headerBytes.length + cipher.getOutputSize(input.length);
       output = new byte[outSize];
       System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);
@@ -58,12 +58,12 @@ public AbstractBlockCipherBean(
       outOff = headerBytes.length;
       length = input.length;
     } else {
-      length = input.length - headerBytes.length;
+      outOff = 0;
+      inOff = header.getLength();
+      length = input.length - inOff;
       final int outSize = cipher.getOutputSize(length);
       output = new byte[outSize];
-      inOff = headerBytes.length;
-      outOff = 0;
     }
     outOff += cipher.processBytes(input, inOff, length, output, outOff);
     outOff += cipher.doFinal(output, outOff);
@@ -85,7 +85,7 @@ protected void process(
   {
     final BlockCipherAdapter cipher = newCipher(header, mode);
     final int outSize = cipher.getOutputSize(StreamUtil.CHUNK_SIZE);
-    final byte[] outBuf = new byte[outSize > StreamUtil.CHUNK_SIZE ? outSize : StreamUtil.CHUNK_SIZE];
+    final byte[] outBuf = new byte[Math.max(outSize, StreamUtil.CHUNK_SIZE)];
     StreamUtil.pipeAll(
       input,
       output,",1,java,8.0,src/main/java/org/cryptacular/bean/AbstractBlockCipherBean.java
3dd86d04e8b90ba309819317d19e7260d414d9e7,apache/activemq,train,"@@ -1,96 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.activemq.util;
-
-import java.io.IOException;
-import java.nio.file.FileSystems;
-
-import javax.servlet.Filter;
-import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
-import javax.servlet.ServletException;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletRequestWrapper;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-
-public class FilenameGuardFilter implements Filter {
-
-    private static final Logger LOG = LoggerFactory.getLogger(FilenameGuardFilter.class);
-    
-    public void destroy() {
-        // nothing to destroy
-    }
-
-    public void init(FilterConfig config) throws ServletException {
-        // nothing to init
-    }
-
-    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-        if (request instanceof HttpServletRequest) {
-            HttpServletRequest httpRequest = (HttpServletRequest)request;
-            GuardedHttpServletRequest guardedRequest = new GuardedHttpServletRequest(httpRequest);
-            chain.doFilter(guardedRequest, response);
-        } else {
-            chain.doFilter(request, response);
-        }
-    }
-
-    private static class GuardedHttpServletRequest extends HttpServletRequestWrapper {
-
-        public GuardedHttpServletRequest(HttpServletRequest httpRequest) {
-            super(httpRequest);
-        }
-
-        private String guard(String filename) {
-            String guarded = filename.replace("":"", ""_"");
-            guarded = FileSystems.getDefault().getPath(guarded).normalize().toString();
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(""guarded "" + filename + "" to "" + guarded);
-            }
-            return guarded;
-        }
-
-        @Override
-        public String getParameter(String name) {
-            if (name.equals(""Destination"")) {
-                return guard(super.getParameter(name));
-            } else {
-                return super.getParameter(name);
-            }
-        }
-
-        @Override
-        public String getPathInfo() {
-            return guard(super.getPathInfo());
-        }
-
-        @Override
-        public String getPathTranslated() {
-            return guard(super.getPathTranslated());
-        }
-
-        @Override
-        public String getRequestURI() {
-            return guard(super.getRequestURI());
-        }
-    }
-}",1,java,63.0,FilenameGuardFilter.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -20,7 +20,7 @@
 import org.bouncycastle.crypto.DataLengthException;
 import org.bouncycastle.crypto.InvalidCipherTextException;
 import org.bouncycastle.crypto.Mac;
-import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.AESEngine;
 import org.bouncycastle.crypto.engines.AESWrapEngine;
 import org.bouncycastle.crypto.engines.RFC3211WrapEngine;
 import org.bouncycastle.crypto.engines.RFC5649WrapEngine;
@@ -61,7 +61,7 @@ public ECB()
             {
                 public BlockCipher get()
                 {
-                    return new AESFastEngine();
+                    return new AESEngine();
                 }
             });
         }
@@ -72,7 +72,7 @@ public BlockCipher get()
     {
         public CBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), 128);
+            super(new CBCBlockCipher(new AESEngine()), 128);
         }
     }
@@ -81,7 +81,7 @@ public CBC()
     {
         public CFB()
         {
-            super(new BufferedBlockCipher(new CFBBlockCipher(new AESFastEngine(), 128)), 128);
+            super(new BufferedBlockCipher(new CFBBlockCipher(new AESEngine(), 128)), 128);
         }
     }
@@ -90,7 +90,7 @@ public CFB()
     {
         public OFB()
         {
-            super(new BufferedBlockCipher(new OFBBlockCipher(new AESFastEngine(), 128)), 128);
+            super(new BufferedBlockCipher(new OFBBlockCipher(new AESEngine(), 128)), 128);
         }
     }
@@ -99,7 +99,7 @@ public OFB()
     {
         public GCM()
         {
-            super(new GCMBlockCipher(new AESFastEngine()));
+            super(new GCMBlockCipher(new AESEngine()));
         }
     }
@@ -108,7 +108,7 @@ public GCM()
     {
         public CCM()
         {
-            super(new CCMBlockCipher(new AESFastEngine()), false, 16);
+            super(new CCMBlockCipher(new AESEngine()), false, 16);
         }
     }
@@ -117,7 +117,7 @@ public CCM()
     {
         public AESCMAC()
         {
-            super(new CMac(new AESFastEngine()));
+            super(new CMac(new AESEngine()));
         }
     }
@@ -126,7 +126,7 @@ public AESCMAC()
     {
         public AESGMAC()
         {
-            super(new GMac(new GCMBlockCipher(new AESFastEngine())));
+            super(new GMac(new GCMBlockCipher(new AESEngine())));
         }
     }
@@ -141,7 +141,7 @@ public AESCCMMAC()
         private static class CCMMac
             implements Mac
         {
-            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESFastEngine());
+            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESEngine());
             private int macLength = 8;
@@ -200,7 +200,7 @@ public void reset()
     {
         public Poly1305()
         {
-            super(new org.bouncycastle.crypto.macs.Poly1305(new AESFastEngine()));
+            super(new org.bouncycastle.crypto.macs.Poly1305(new AESEngine()));
         }
     }
@@ -227,7 +227,7 @@ public Wrap()
     {
         public RFC3211Wrap()
         {
-            super(new RFC3211WrapEngine(new AESFastEngine()), 16);
+            super(new RFC3211WrapEngine(new AESEngine()), 16);
         }
     }
@@ -236,7 +236,7 @@ public RFC3211Wrap()
     {
         public RFC5649Wrap()
         {
-            super(new RFC5649WrapEngine(new AESFastEngine()));
+            super(new RFC5649WrapEngine(new AESEngine()));
         }
     }
@@ -248,7 +248,7 @@ public RFC5649Wrap()
     {
         public PBEWithAESCBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()));
+            super(new CBCBlockCipher(new AESEngine()));
         }
     }
@@ -260,7 +260,7 @@ public PBEWithAESCBC()
     {
         public PBEWithSHA1AESCBC128()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 128, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 128, 16);
         }
     }
@@ -269,7 +269,7 @@ public PBEWithSHA1AESCBC128()
     {
         public PBEWithSHA1AESCBC192()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 192, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 192, 16);
         }
     }
@@ -278,7 +278,7 @@ public PBEWithSHA1AESCBC192()
     {
         public PBEWithSHA1AESCBC256()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 256, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 256, 16);
         }
     }
@@ -290,7 +290,7 @@ public PBEWithSHA1AESCBC256()
     {
         public PBEWithSHA256AESCBC128()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 128, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 128, 16);
         }
     }
@@ -299,7 +299,7 @@ public PBEWithSHA256AESCBC128()
     {
         public PBEWithSHA256AESCBC192()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 192, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 192, 16);
         }
     }
@@ -308,7 +308,7 @@ public PBEWithSHA256AESCBC192()
     {
         public PBEWithSHA256AESCBC256()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 256, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 256, 16);
         }
     }",1,java,40.0,AES.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -17,9 +17,10 @@
 package com.googlecode.wicket.kendo.ui.widget.tabs;
 import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import org.apache.wicket.event.IEvent;
-import com.googlecode.wicket.jquery.core.ajax.AjaxPayload;
+import com.googlecode.wicket.jquery.core.ajax.HandlerPayload;
 import com.googlecode.wicket.kendo.ui.form.button.AjaxButton;
 import com.googlecode.wicket.kendo.ui.widget.NavigationPanel;
@@ -103,15 +104,15 @@ public class TabbedPanelNavigator extends NavigationPanel // NOSONAR
-	 * Provides a {@link AjaxPayload} designed to reload the {@link TabbedPanelNavigator}
+	 * Provides a {@link HandlerPayload} designed to reload the {@link TabbedPanelNavigator}
-	public static class RefreshPayload extends AjaxPayload
+	public static class RefreshPayload extends HandlerPayload
 	{
 		private final int index;
-		public RefreshPayload(int index, AjaxRequestTarget target)
+		public RefreshPayload(int index, IPartialPageRequestHandler handler)
 		{
-			super(target);
+			super(handler);
 			this.index = index;
 		}",1,java,9.0,TabbedPanelNavigator.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -64,8 +64,10 @@ public class QueryRunner {
     public QueryRunner(Elide elide) {
         this.elide = elide;
 
-        PersistentResourceFetcher fetcher = new PersistentResourceFetcher(elide.getElideSettings());
-        ModelBuilder builder = new ModelBuilder(elide.getElideSettings().getDictionary(), fetcher);
+        NonEntityDictionary nonEntityDictionary = new NonEntityDictionary();
+        PersistentResourceFetcher fetcher = new PersistentResourceFetcher(elide.getElideSettings(),
+                nonEntityDictionary);
+        ModelBuilder builder = new ModelBuilder(elide.getElideSettings().getDictionary(), nonEntityDictionary, fetcher);
 
         this.api = new GraphQL(builder.build());
 
",1,java,6.0,QueryRunner.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -39,15 +39,9 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.ConstraintType;
 import net.sf.mpxj.DateRange;
@@ -73,6 +67,7 @@
 import net.sf.mpxj.TimeUnit;
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.planner.schema.Allocation;
 import net.sf.mpxj.planner.schema.Allocations;
@@ -114,6 +109,11 @@
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
@@ -129,21 +129,7 @@
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project plannerProject = (Project) unmarshaller.unmarshal(doc);
+         Project plannerProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, stream);
          readProjectProperties(plannerProject);
          readCalendars(plannerProject);",1,java,24.0,src/main/java/net/sf/mpxj/planner/PlannerReader.java
1117a37b01a1058897a34e11ff5156e465efb69,apache/storm,train,"@@ -86,6 +86,7 @@ public class LocalizedResource extends LocallyCachedBlob {
     private final IAdvancedFSOps fsOps;
     private final String user;
     private final Map<String, Object> conf;
+    private final boolean symLinksDisabled;
     private long size = -1;
@@ -95,6 +96,7 @@ public class LocalizedResource extends LocallyCachedBlob {
         Path base = getLocalUserFileCacheDir(localBaseDir, user);
         this.baseDir = uncompressed ? getCacheDirForArchives(base) : getCacheDirForFiles(base);
         this.conf = conf;
+        this.symLinksDisabled = (boolean)conf.getOrDefault(Config.DISABLE_SYMLINKS, false);
         this.user = user;
         this.fsOps = fsOps;
         versionFilePath = constructVersionFileName(baseDir, key);
@@ -273,7 +275,7 @@ public class LocalizedResource extends LocallyCachedBlob {
             }
         }
         if (uncompressed) {
-            ServerUtils.unpack(downloadFile.toFile(), finalLocation.toFile());
+            ServerUtils.unpack(downloadFile.toFile(), finalLocation.toFile(), symLinksDisabled);
             LOG.debug(""Uncompressed {} to: {}"", downloadFile, finalLocation);
         }
         setBlobPermissions(conf, user, finalLocation);",1,java,4.0,LocalizedResource.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -0,0 +1,307 @@
+/* See LICENSE for licensing and NOTICE for copyright. */
+package org.cryptacular;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import javax.crypto.SecretKey;
+import org.bouncycastle.crypto.digests.SHA256Digest;
+import org.bouncycastle.crypto.macs.HMac;
+import org.cryptacular.util.ByteUtil;
+
+/**
+ * Cleartext header prepended to ciphertext providing data required for decryption.
+ *
+ * <p>Data format:</p>
+ *
+ * <pre>
+     +---------+---------+---+----------+-------+------+
+     | Version | KeyName | 0 | NonceLen | Nonce | HMAC |
+     +---------+---------+---+----------+-------+------+
+     |                                                 |
+     +--- 4 ---+--- x ---+ 1 +--- 1 ----+-- y --+- 32 -+
+ * </pre>
+ *
+ * <p>Where fields are defined as follows:</p>
+ *
+ * <ul>
+ *   <li>Version - Header version format as a negative number (4-byte integer). Current version is -2.</li>
+ *   <li>KeyName - Symbolic key name encoded as UTF-8 bytes (variable length)</li>
+ *   <li>0 - Null byte signifying the end of the symbolic key name</li>
+ *   <li>NonceLen - Nonce length in bytes (1-byte unsigned integer)</li>
+ *   <li>Nonce - Nonce bytes (variable length)</li>
+ *   <li>HMAC - HMAC-256 over preceding fields (32 bytes)</li>
+ * </ul>
+ *
+ * <p>The last two fields provide support for multiple keys at the encryption provider. A common case for multiple
+ * keys is key rotation; by tagging encrypted data with a key name, an old key may be retrieved by name to decrypt
+ * outstanding data which will be subsequently re-encrypted with a new key.</p>
+ *
+ * @author  Middleware Services
+ */
+public class CiphertextHeaderV2 extends CiphertextHeader
+{
+  /** Header version format. */
+  private static final int VERSION = -2;
+
+  /** Size of HMAC algorithm output in bytes. */
+  private static final int HMAC_SIZE = 32;
+
+  /** Function to resolve a key from a symbolic key name. */
+  private Function<String, SecretKey> keyLookup;
+
+
+  /**
+   * Creates a new instance with a nonce and named key.
+   *
+   * @param  nonce  Nonce bytes.
+   * @param  keyName  Key name.
+   */
+  public CiphertextHeaderV2(final byte[] nonce, final String keyName)
+  {
+    super(nonce, keyName);
+    if (keyName == null || keyName.isEmpty()) {
+      throw new IllegalArgumentException(""Key name is required"");
+    }
+  }
+
+
+  /**
+   * Sets the function to resolve keys from {@link #keyName}.
+   *
+   * @param  keyLookup  Key lookup function.
+   */
+  public void setKeyLookup(final Function<String, SecretKey> keyLookup)
+  {
+    this.keyLookup = keyLookup;
+  }
+
+
+  @Override
+  public byte[] encode()
+  {
+    final SecretKey key = keyLookup != null ? keyLookup.apply(keyName) : null;
+    if (key == null) {
+      throw new IllegalStateException(""Could not resolve secret key to generate header HMAC"");
+    }
+    return encode(key);
+  }
+
+
+  /**
+   * Encodes the header into bytes.
+   *
+   * @param  hmacKey  Key used to generate header HMAC.
+   *
+   * @return  Byte representation of header.
+   */
+  public byte[] encode(final SecretKey hmacKey)
+  {
+    final ByteBuffer bb = ByteBuffer.allocate(length);
+    bb.order(ByteOrder.BIG_ENDIAN);
+    bb.putInt(VERSION);
+    bb.put(ByteUtil.toBytes(keyName));
+    bb.put((byte) 0);
+    bb.put(ByteUtil.toUnsignedByte(nonce.length));
+    bb.put(nonce);
+    if (hmacKey != null) {
+      final byte[] hmac = hmac(bb.array(), 0, bb.limit() - HMAC_SIZE);
+      bb.put(hmac);
+    }
+    return bb.array();
+  }
+
+
+  /**
+   * @return  Length of this header encoded as bytes.
+   */
+  protected int computeLength()
+  {
+    return 4 + ByteUtil.toBytes(keyName).length + 2 + nonce.length + HMAC_SIZE;
+  }
+
+
+  /**
+   * Creates a header from encrypted data containing a cleartext header prepended to the start.
+   *
+   * @param  data  Encrypted data with prepended header data.
+   * @param  keyLookup  Function used to look up the secret key from the symbolic key name in the header.
+   *
+   * @return  Decoded header.
+   *
+   * @throws  EncodingException  when ciphertext header cannot be decoded.
+   */
+  public static CiphertextHeaderV2 decode(final byte[] data, final Function<String, SecretKey> keyLookup)
+      throws EncodingException
+  {
+    final ByteBuffer bb = ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN);
+    return decodeInternal(
+      ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN),
+      keyLookup,
+      ByteBuffer -> bb.getInt(),
+      ByteBuffer -> bb.get(),
+      (ByteBuffer, output) -> bb.get(output));
+  }
+
+
+  /**
+   * Creates a header from encrypted data containing a cleartext header prepended to the start.
+   *
+   * @param  input  Input stream that is positioned at the start of ciphertext header data.
+   * @param  keyLookup  Function used to look up the secret key from the symbolic key name in the header.
+   *
+   * @return  Decoded header.
+   *
+   * @throws  EncodingException  when ciphertext header cannot be decoded.
+   * @throws  StreamException  on stream IO errors.
+   */
+  public static CiphertextHeaderV2 decode(final InputStream input, final Function<String, SecretKey> keyLookup)
+      throws EncodingException, StreamException
+  {
+    return decodeInternal(
+      input, keyLookup, ByteUtil::readInt, CiphertextHeaderV2::readByte, CiphertextHeaderV2::readInto);
+  }
+
+
+  /**
+   * Internal header decoding routine.
+   *
+   * @param  <T>  Type of input source.
+   * @param  source  Source of header data (input stream or byte buffer).
+   * @param  keyLookup  Function to look up key from symbolic key name in header.
+   * @param  readIntFn  Function that produces a 4-byte integer from the input source.
+   * @param  readByteFn  Function that produces a byte from the input source.
+   * @param  readBytesConsumer  Function that fills a byte array from the input source.
+   *
+   * @return  Decoded header.
+   */
+  private static <T> CiphertextHeaderV2 decodeInternal(
+      final T source,
+      final Function<String, SecretKey> keyLookup,
+      final Function<T, Integer> readIntFn,
+      final Function<T, Byte> readByteFn,
+      final BiConsumer<T, byte[]> readBytesConsumer)
+  {
+    final SecretKey key;
+    final String keyName;
+    final byte[] nonce;
+    final byte[] hmac;
+    try {
+      final int version = readIntFn.apply(source);
+      if (version != VERSION) {
+        throw new EncodingException(""Unsupported ciphertext header version"");
+      }
+      final ByteArrayOutputStream out = new ByteArrayOutputStream(100);
+      byte b = 0;
+      int count = 0;
+      while ((b = readByteFn.apply(source)) != 0) {
+        out.write(b);
+        if (out.size() > MAX_KEYNAME_LEN) {
+          throw new EncodingException(""Bad ciphertext header: maximum nonce length exceeded"");
+        }
+        count++;
+      }
+      keyName = ByteUtil.toString(out.toByteArray(), 0, count);
+      key = keyLookup.apply(keyName);
+      if (key == null) {
+        throw new IllegalStateException(""Symbolic key name mentioned in header was not found"");
+      }
+      final int nonceLen = ByteUtil.toInt(readByteFn.apply(source));
+      nonce = new byte[nonceLen];
+      readBytesConsumer.accept(source, nonce);
+      hmac = new byte[HMAC_SIZE];
+      readBytesConsumer.accept(source, hmac);
+    } catch (IndexOutOfBoundsException | BufferUnderflowException e) {
+      throw new EncodingException(""Bad ciphertext header"");
+    }
+    final CiphertextHeaderV2 header = new CiphertextHeaderV2(nonce, keyName);
+    final byte[] encoded = header.encode(key);
+    if (!arraysEqual(hmac, 0, encoded, encoded.length - HMAC_SIZE, HMAC_SIZE)) {
+      throw new EncodingException(""Ciphertext header HMAC verification failed"");
+    }
+    header.setKeyLookup(keyLookup);
+    return header;
+  }
+
+
+  /**
+   * Generates an HMAC-256 over the given input byte array.
+   *
+   * @param  input  Input bytes.
+   * @param  offset  Starting position in input byte array.
+   * @param  length  Number of bytes in input to consume.
+   *
+   * @return  HMAC as byte array.
+   */
+  private static byte[] hmac(final byte[] input, final int offset, final int length)
+  {
+    final HMac hmac = new HMac(new SHA256Digest());
+    final byte[] output = new byte[HMAC_SIZE];
+    hmac.update(input, offset, length);
+    hmac.doFinal(output, 0);
+    return output;
+  }
+
+
+  /**
+   * Read <code>output.length</code> bytes from the input stream into the output buffer.
+   *
+   * @param  input  Input stream.
+   * @param  output  Output buffer.
+   */
+  private static void readInto(final InputStream input, final byte[] output)
+  {
+    try {
+      input.read(output);
+    } catch (IOException e) {
+      throw new StreamException(e);
+    }
+  }
+
+
+  /**
+   * Read a single byte from the input stream.
+   *
+   * @param  input  Input stream.
+   *
+   * @return  Byte read from input stream.
+   */
+  private static byte readByte(final InputStream input)
+  {
+    try {
+      return (byte) input.read();
+    } catch (IOException e) {
+      throw new StreamException(e);
+    }
+  }
+
+
+  /**
+   * Determines if two byte array ranges are equal bytewise.
+   *
+   * @param  a  First array to compare.
+   * @param  aOff  Offset into first array.
+   * @param  b  Second array to compare.
+   * @param  bOff  Offset into second array.
+   * @param  length  Number of bytes to compare.
+   *
+   * @return  True if every byte in the given range is equal, false otherwise.
+   */
+  private static boolean arraysEqual(final byte[] a, final int aOff, final byte[] b, final int bOff, final int length)
+  {
+    if (length + aOff > a.length || length + bOff > b.length) {
+      return false;
+    }
+    for (int i = 0; i < length; i++) {
+      if (a[i + aOff] != b[i + bOff]) {
+        return false;
+      }
+    }
+    return true;
+  }
+}",1,java,164.0,src/main/java/org/cryptacular/CiphertextHeaderV2.java
c7d59bd718881fb678ebdeba825b8eb832044e23,eclipse/rdf4j,train,"@@ -25,10 +25,9 @@ import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.DefaultHandler;
 
 /**
- * An XML parser that generates ""simple"" SAX-like events from a limited subset of XML documents. The
- * SimpleSAXParser can parse simple XML documents; it doesn't support processing instructions or elements that
- * contain both sub-element and character data; character data is only supported in the ""leaves"" of the XML
- * element tree.
+ * An XML parser that generates ""simple"" SAX-like events from a limited subset of XML documents. The SimpleSAXParser can
+ * parse simple XML documents; it doesn't support processing instructions or elements that contain both sub-element and
+ * character data; character data is only supported in the ""leaves"" of the XML element tree.
  * <h3>Example:</h3>
  * <p>
  * Parsing the following XML:
@@ -59,290 +58,271 @@ import org.xml.sax.helpers.DefaultHandler;
  */
 public class SimpleSAXParser {
 
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	/**
-	 * The XMLReader to use for parsing the XML.
-	 */
-	private XMLReader xmlReader;
-
-	/**
-	 * The listener to report the events to.
-	 */
-	private SimpleSAXListener listener;
-
-	/**
-	 * Flag indicating whether leading and trailing whitespace in text elements should be preserved.
-	 */
-	private boolean preserveWhitespace = false;
-
-	/**
-	 * A Locator indicating a position in the text that is currently being parsed by the SAX parser.
-	 */
-	private Locator locator;
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new SimpleSAXParser that will use the supplied <tt>XMLReader</tt> for parsing the XML. One
-	 * must set a <tt>SimpleSAXListener</tt> on this object before calling one of the <tt>parse()</tt>
-	 * methods.
-	 * 
-	 * @param xmlReader
-	 *        The XMLReader to use for parsing.
-	 * @see #setListener
-	 */
-	public SimpleSAXParser(XMLReader xmlReader) {
-		super();
-		this.xmlReader = xmlReader;
-	}
-
-	/**
-	 * Creates a new SimpleSAXParser that will try to create a new <tt>XMLReader</tt> using
-	 * <tt>info.aduna.xml.XMLReaderFactory</tt> for parsing the XML. One must set a <tt>SimpleSAXListener</tt>
-	 * on this object before calling one of the <tt>parse()</tt> methods.
-	 * 
-	 * @throws SAXException
-	 *         If the SimpleSAXParser was unable to create an XMLReader.
-	 * @see #setListener
-	 * @see org.xml.sax.XMLReader
-	 * @see org.eclipse.rdf4j.common.xml.XMLReaderFactory
-	 */
-	public SimpleSAXParser()
-		throws SAXException
-	{
-		this(XMLReaderFactory.createXMLReader());
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	/**
-	 * Sets the (new) listener that should receive any events from this parser. This listener will replace any
-	 * previously set listener.
-	 * 
-	 * @param listener
-	 *        The (new) listener for events from this parser.
-	 */
-	public void setListener(SimpleSAXListener listener) {
-		this.listener = listener;
-	}
-
-	/**
-	 * Gets the listener that currently will receive any events from this parser.
-	 * 
-	 * @return The listener for events from this parser.
-	 */
-	public SimpleSAXListener getListener() {
-		return listener;
-	}
-
-	public Locator getLocator() {
-		return locator;
-	}
-
-	/**
-	 * Sets whether leading and trailing whitespace characters in text elements should be preserved. Such
-	 * whitespace characters are discarded by default.
-	 */
-	public void setPreserveWhitespace(boolean preserveWhitespace) {
-		this.preserveWhitespace = preserveWhitespace;
-	}
-
-	/**
-	 * Checks whether leading and trailing whitespace characters in text elements are preserved. Defaults to
-	 * <tt>false</tt>.
-	 */
-	public boolean isPreserveWhitespace() {
-		return preserveWhitespace;
-	}
-
-	/**
-	 * Parses the content of the supplied <tt>File</tt> as XML.
-	 * 
-	 * @param file
-	 *        The file containing the XML to parse.
-	 */
-	public void parse(File file)
-		throws SAXException, IOException
-	{
-		InputStream in = new FileInputStream(file);
-		try {
-			parse(in);
-		}
-		finally {
-			try {
-				in.close();
-			}
-			catch (IOException ignore) {
-			}
-		}
-	}
-
-	/**
-	 * Parses the content of the supplied <tt>InputStream</tt> as XML.
-	 * 
-	 * @param in
-	 *        An <tt>InputStream</tt> containing XML data.
-	 */
-	public void parse(InputStream in)
-		throws SAXException, IOException
-	{
-		parse(new InputSource(in));
-	}
-
-	/**
-	 * Parses the content of the supplied <tt>Reader</tt> as XML.
-	 * 
-	 * @param reader
-	 *        A <tt>Reader</tt> containing XML data.
-	 */
-	public void parse(Reader reader)
-		throws SAXException, IOException
-	{
-		parse(new InputSource(reader));
-	}
-
-	/**
-	 * Parses the content of the supplied <tt>InputSource</tt> as XML.
-	 * 
-	 * @param inputSource
-	 *        An <tt>InputSource</tt> containing XML data.
-	 */
-	public synchronized void parse(InputSource inputSource)
-		throws SAXException, IOException
-	{
-		xmlReader.setContentHandler(new SimpleSAXDefaultHandler());
-		xmlReader.parse(inputSource);
-	}
-
-	/*-------------------------------------*
-	 * Inner class SimpleSAXDefaultHandler *
-	 *-------------------------------------*/
-
-	class SimpleSAXDefaultHandler extends DefaultHandler {
-
-		/*-----------*
-		 * Variables *
-		 *-----------*/
-
-		/**
-		 * StringBuilder used to collect text during parsing.
-		 */
-		private StringBuilder charBuf = new StringBuilder(512);
-
-		/**
-		 * The tag name of a deferred start tag.
-		 */
-		private String deferredStartTag = null;
-
-		/**
-		 * The attributes of a deferred start tag.
-		 */
-		private Map<String, String> deferredAttributes = null;
-
-		/*--------------*
-		 * Constructors *
-		 *--------------*/
-
-		public SimpleSAXDefaultHandler() {
-			super();
-		}
-
-		/*---------*
-		 * Methods *
-		 *---------*/
-
-		// overrides DefaultHandler.startDocument()
-		public void startDocument()
-			throws SAXException
-		{
-			listener.startDocument();
-		}
-
-		// overrides DefaultHandler.endDocument()
-		public void endDocument()
-			throws SAXException
-		{
-			listener.endDocument();
-		}
-
-		// overrides DefaultHandler.characters()
-		public void characters(char[] ch, int start, int length)
-			throws SAXException
-		{
-			charBuf.append(ch, start, length);
-		}
-
-		// overrides DefaultHandler.startElement()
-		public void startElement(String namespaceURI, String localName, String qName, Attributes attributes)
-			throws SAXException
-		{
-			// Report any deferred start tag
-			if (deferredStartTag != null) {
-				reportDeferredStartElement();
-			}
-
-			// Make current tag new deferred start tag
-			deferredStartTag = localName;
-
-			// Copy attributes to deferredAttributes
-			int attCount = attributes.getLength();
-			if (attCount == 0) {
-				deferredAttributes = Collections.emptyMap();
-			}
-			else {
-				deferredAttributes = new LinkedHashMap<String, String>(attCount * 2);
-
-				for (int i = 0; i < attCount; i++) {
-					deferredAttributes.put(attributes.getQName(i), attributes.getValue(i));
-				}
-			}
-
-			// Clear character buffer
-			charBuf.setLength(0);
-		}
-
-		private void reportDeferredStartElement()
-			throws SAXException
-		{
-			listener.startTag(deferredStartTag, deferredAttributes, """");
-			deferredStartTag = null;
-			deferredAttributes = null;
-		}
-
-		// overrides DefaultHandler.endElement()
-		public void endElement(String namespaceURI, String localName, String qName)
-			throws SAXException
-		{
-			if (deferredStartTag != null) {
-				// Check if any character data has been collected in the charBuf
-				String text = charBuf.toString();
-				if (!preserveWhitespace) {
-					text = text.trim();
-				}
-
-				// Report deferred start tag
-				listener.startTag(deferredStartTag, deferredAttributes, text);
-				deferredStartTag = null;
-				deferredAttributes = null;
-			}
-
-			// Report the end tag
-			listener.endTag(localName);
-
-			// Clear character buffer
-			charBuf.setLength(0);
-		}
-
-		@Override
-		public void setDocumentLocator(Locator loc) {
-			locator = loc;
-		}
-	}
+  /*-----------*
+   * Variables *
+   *-----------*/
+
+  /**
+   * The XMLReader to use for parsing the XML.
+   */
+  private XMLReader xmlReader;
+
+  /**
+   * The listener to report the events to.
+   */
+  private SimpleSAXListener listener;
+
+  /**
+   * Flag indicating whether leading and trailing whitespace in text elements should be preserved.
+   */
+  private boolean preserveWhitespace = false;
+
+  /**
+   * A Locator indicating a position in the text that is currently being parsed by the SAX parser.
+   */
+  private Locator locator;
+
+  /*--------------*
+   * Constructors *
+   *--------------*/
+
+  /**
+   * Creates a new SimpleSAXParser that will use the supplied <tt>XMLReader</tt> for parsing the XML. One must set a
+   * <tt>SimpleSAXListener</tt> on this object before calling one of the <tt>parse()</tt> methods.
+   * 
+   * @param xmlReader
+   *        The XMLReader to use for parsing.
+   * @see #setListener
+   */
+  public SimpleSAXParser(XMLReader xmlReader) {
+    super();
+    this.xmlReader = xmlReader;
+  }
+
+  /**
+   * Creates a new SimpleSAXParser that will try to create a new <tt>XMLReader</tt> using
+   * <tt>info.aduna.xml.XMLReaderFactory</tt> for parsing the XML. One must set a <tt>SimpleSAXListener</tt> on this
+   * object before calling one of the <tt>parse()</tt> methods.
+   * 
+   * @throws SAXException
+   *         If the SimpleSAXParser was unable to create an XMLReader.
+   * @see #setListener
+   * @see org.xml.sax.XMLReader
+   * @see org.eclipse.rdf4j.common.xml.XMLReaderFactory
+   */
+  public SimpleSAXParser() throws SAXException {
+    this(XMLReaderFactory.createXMLReader());
+  }
+
+  /*---------*
+   * Methods *
+   *---------*/
+
+  /**
+   * Sets the (new) listener that should receive any events from this parser. This listener will replace any previously
+   * set listener.
+   * 
+   * @param listener
+   *        The (new) listener for events from this parser.
+   */
+  public void setListener(SimpleSAXListener listener) {
+    this.listener = listener;
+  }
+
+  /**
+   * Gets the listener that currently will receive any events from this parser.
+   * 
+   * @return The listener for events from this parser.
+   */
+  public SimpleSAXListener getListener() {
+    return listener;
+  }
+
+  public Locator getLocator() {
+    return locator;
+  }
+
+  /**
+   * Sets whether leading and trailing whitespace characters in text elements should be preserved. Such whitespace
+   * characters are discarded by default.
+   */
+  public void setPreserveWhitespace(boolean preserveWhitespace) {
+    this.preserveWhitespace = preserveWhitespace;
+  }
+
+  /**
+   * Checks whether leading and trailing whitespace characters in text elements are preserved. Defaults to
+   * <tt>false</tt>.
+   */
+  public boolean isPreserveWhitespace() {
+    return preserveWhitespace;
+  }
+
+  /**
+   * Parses the content of the supplied <tt>File</tt> as XML.
+   * 
+   * @param file
+   *        The file containing the XML to parse.
+   */
+  public void parse(File file) throws SAXException, IOException {
+    InputStream in = new FileInputStream(file);
+    try {
+      parse(in);
+    } finally {
+      try {
+        in.close();
+      } catch (IOException ignore) {
+      }
+    }
+  }
+
+  /**
+   * Parses the content of the supplied <tt>InputStream</tt> as XML.
+   * 
+   * @param in
+   *        An <tt>InputStream</tt> containing XML data.
+   */
+  public void parse(InputStream in) throws SAXException, IOException {
+    parse(new InputSource(in));
+  }
+
+  /**
+   * Parses the content of the supplied <tt>Reader</tt> as XML.
+   * 
+   * @param reader
+   *        A <tt>Reader</tt> containing XML data.
+   */
+  public void parse(Reader reader) throws SAXException, IOException {
+    parse(new InputSource(reader));
+  }
+
+  /**
+   * Parses the content of the supplied <tt>InputSource</tt> as XML.
+   * 
+   * @param inputSource
+   *        An <tt>InputSource</tt> containing XML data.
+   */
+  public synchronized void parse(InputSource inputSource) throws SAXException, IOException {
+    xmlReader.setContentHandler(new SimpleSAXDefaultHandler());
+    // Via https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet
+    xmlReader.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
+    // This may not be strictly required as DTDs shouldn't be allowed at all, per previous line.
+    xmlReader.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
+    xmlReader.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
+    xmlReader.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
+    xmlReader.parse(inputSource);
+  }
+
+  /*-------------------------------------*
+   * Inner class SimpleSAXDefaultHandler *
+   *-------------------------------------*/
+
+  class SimpleSAXDefaultHandler extends DefaultHandler {
+
+    /*-----------*
+     * Variables *
+     *-----------*/
+
+    /**
+     * StringBuilder used to collect text during parsing.
+     */
+    private StringBuilder charBuf = new StringBuilder(512);
+
+    /**
+     * The tag name of a deferred start tag.
+     */
+    private String deferredStartTag = null;
+
+    /**
+     * The attributes of a deferred start tag.
+     */
+    private Map<String, String> deferredAttributes = null;
+
+    /*--------------*
+     * Constructors *
+     *--------------*/
+
+    public SimpleSAXDefaultHandler() {
+      super();
+    }
+
+    /*---------*
+     * Methods *
+     *---------*/
+
+    // overrides DefaultHandler.startDocument()
+    public void startDocument() throws SAXException {
+      listener.startDocument();
+    }
+
+    // overrides DefaultHandler.endDocument()
+    public void endDocument() throws SAXException {
+      listener.endDocument();
+    }
+
+    // overrides DefaultHandler.characters()
+    public void characters(char[] ch, int start, int length) throws SAXException {
+      charBuf.append(ch, start, length);
+    }
+
+    // overrides DefaultHandler.startElement()
+    public void startElement(String namespaceURI, String localName, String qName, Attributes attributes)
+        throws SAXException {
+      // Report any deferred start tag
+      if (deferredStartTag != null) {
+        reportDeferredStartElement();
+      }
+
+      // Make current tag new deferred start tag
+      deferredStartTag = localName;
+
+      // Copy attributes to deferredAttributes
+      int attCount = attributes.getLength();
+      if (attCount == 0) {
+        deferredAttributes = Collections.emptyMap();
+      } else {
+        deferredAttributes = new LinkedHashMap<String, String>(attCount * 2);
+
+        for (int i = 0; i < attCount; i++) {
+          deferredAttributes.put(attributes.getQName(i), attributes.getValue(i));
+        }
+      }
+
+      // Clear character buffer
+      charBuf.setLength(0);
+    }
+
+    private void reportDeferredStartElement() throws SAXException {
+      listener.startTag(deferredStartTag, deferredAttributes, """");
+      deferredStartTag = null;
+      deferredAttributes = null;
+    }
+
+    // overrides DefaultHandler.endElement()
+    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
+      if (deferredStartTag != null) {
+        // Check if any character data has been collected in the charBuf
+        String text = charBuf.toString();
+        if (!preserveWhitespace) {
+          text = text.trim();
+        }
+
+        // Report deferred start tag
+        listener.startTag(deferredStartTag, deferredAttributes, text);
+        deferredStartTag = null;
+        deferredAttributes = null;
+      }
+
+      // Report the end tag
+      listener.endTag(localName);
+
+      // Clear character buffer
+      charBuf.setLength(0);
+    }
+
+    @Override
+    public void setDocumentLocator(Locator loc) {
+      locator = loc;
+    }
+  }
 }
",1,java,234.0,SimpleSAXParser.java
ce5c3e8079d64929abb76ec3ec7ac7c71a4a26b6,dotCMS/core,train,"@@ -110,14 +110,13 @@ public void discardConflicts(final String endpointId) throws DotDataException {
     private void discardConflicts(final String endpointId, IntegrityType type)
             throws DotDataException {
-        DotConnect dc = new DotConnect();
+
         final String resultsTableName = type.getResultsTableName();
-        try {
-            dc.executeStatement(""delete from "" + resultsTableName + "" where endpoint_id = '""
-                    + endpointId + ""'"");
-        } catch (SQLException e) {
-            throw new DotDataException(e.getMessage(), e);
-        }
+        DotConnect dc = new DotConnect();
+        dc.setSQL(""delete from "" + resultsTableName + "" where endpoint_id = ?"")
+        .addParam(endpointId)
+        .loadResult();
+
     }",1,java,11.0,dotCMS/src/main/java/com/dotcms/integritycheckers/AbstractIntegrityChecker.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -37,15 +37,9 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.Day;
@@ -68,6 +62,7 @@
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.DebugLogPrintWriter;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.phoenix.schema.Project;
 import net.sf.mpxj.phoenix.schema.Project.Layouts.Layout;
@@ -112,6 +107,11 @@
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_activityMap = new HashMap<>();
          m_activityCodeValues = new HashMap<>();
@@ -134,19 +134,7 @@
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(new SkipNulInputStream(stream)));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project phoenixProject = (Project) unmarshaller.unmarshal(doc);
+         Project phoenixProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, new SkipNulInputStream(stream));
          Storepoint storepoint = getCurrentStorepoint(phoenixProject);
          readProjectProperties(phoenixProject.getSettings(), storepoint);
          readCalendars(storepoint);",1,java,22.0,src/main/java/net/sf/mpxj/phoenix/PhoenixReader.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -223,6 +223,10 @@ public boolean isManageAppMasterPermissionEnabled() {
     return getBooleanProperty(SystemRoleManagerService.MANAGE_APP_MASTER_LIMIT_SWITCH_KEY, false);
   }
+  public String getAdminServiceAccessTokens() {
+    return getValue(""admin-service.access.tokens"");
+  }
+",1,java,4.0,apollo-portal/src/main/java/com/ctrip/framework/apollo/portal/component/config/PortalConfig.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,kiegroup/jbpm-designer,train,"@@ -1,63 +0,0 @@
-package org.jbpm.designer.util;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-
-import org.apache.commons.httpclient.ConnectTimeoutException;
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.protocol.ProtocolSocketFactory;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class OSProtocolSocketFactory implements ProtocolSocketFactory {
-
-    private static Logger log = LoggerFactory.getLogger(OSProtocolSocketFactory.class);
-
-    public OSProtocolSocketFactory() {
-    }
-
-    @Override
-    public Socket createSocket(String host,
-                               int port,
-                               InetAddress localAddress,
-                               int localPort) throws IOException, UnknownHostException {
-        if (log.isDebugEnabled()) {
-            log.debug(""createSocket called. host = "" + host + "", port = "" + port
-                    + "", ignoring localAddress = "" + ((localAddress != null) ? localAddress.toString() : ""null"")
-                    + "", ignoring localPort = "" + localPort);
-        }
-
-        Socket socket = null;
-        try {
-            socket = new Socket(host, port);
-            log.debug(""Socket created"");
-        }
-        catch (IOException e) {
-            log.error(""Error creating socket: "" + e.getMessage());
-            throw e;
-        }
-        return socket;
-    }
-
-    @Override
-    public Socket createSocket(String host, int port, InetAddress localAddress,
-                               int localPort, HttpConnectionParams params) throws IOException,
-            UnknownHostException, ConnectTimeoutException {
-
-        log.debug(""createSocket called with HttpConnectionParams -- ignoring the timeout value and proceeding"");
-
-        return this.createSocket(host, port, localAddress, localPort);
-    }
-
-    @Override
-    public Socket createSocket(String host, int port) throws IOException,
-            UnknownHostException,IOException {
-
-        log.debug(""createSocket called with just host and port. proceeding.."");
-
-        return this.createSocket(host, port, null, 0);
-    }
-
-}
\ No newline at end of file
",1,java,50.0,OSProtocolSocketFactory.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -60,15 +60,15 @@ public class RouteImpl implements Route, Route.Filter {
       final List<MediaType> produces) {
     return fromStatus((req, rsp, chain) -> {
       if (!rsp.status().isPresent()) {
-        throw new Err(Status.NOT_FOUND, path);
+        throw new Err(Status.NOT_FOUND, req.path(true));
       }
     }, method, path, ""404"", produces);
   }
 
   public static RouteImpl fromStatus(final Filter filter, final String method,
       final String path, final String name, final List<MediaType> produces) {
-    return new RouteImpl(filter, new Route.Definition(method, path, filter)
-        .name(name), method, path, produces, NO_VARS, null, Source.UNKNOWN) {
+    return new RouteImpl(filter, new Route.Definition(method, path, filter).name(name), method,
+        path, produces, NO_VARS, null, Source.UNKNOWN) {
       @Override
       public boolean apply(final String filter) {
         return true;
",1,java,6.0,RouteImpl.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -18,6 +18,7 @@ package com.googlecode.wicket.jquery.core.ajax;
 import org.apache.wicket.Component;
 import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import org.apache.wicket.feedback.FeedbackMessage;
@@ -33,15 +34,15 @@ import org.apache.wicket.feedback.FeedbackMessage;
+ * 		IPartialPageRequestHandler handler = payload.getHandler();
- * 		AjaxRequestTarget target = payload.getTarget();
- * 		target.add(feedback);
+ * 		handler.add(feedback);
@@ -51,7 +52,7 @@ import org.apache.wicket.feedback.FeedbackMessage;
-public class FeedbackPayload extends AjaxPayload
+public class FeedbackPayload extends HandlerPayload
 {
 	private final String message;
 	private final int level;
@@ -59,23 +60,23 @@ public class FeedbackPayload extends AjaxPayload
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link AjaxRequestTarget}
-	public FeedbackPayload(AjaxRequestTarget target)
+	public FeedbackPayload(IPartialPageRequestHandler handler)
 	{
-		this(target, FeedbackMessage.UNDEFINED, null);
+		this(handler, FeedbackMessage.UNDEFINED, null);
 	}
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link AjaxRequestTarget}
-	public FeedbackPayload(AjaxRequestTarget target, int level, String message)
+	public FeedbackPayload(IPartialPageRequestHandler handler, int level, String message)
 	{
-		super(target);
+		super(handler);
 		this.level = level;
 		this.message = message;",1,java,11.0,FeedbackPayload.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -9,10 +9,11 @@
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
+import org.postgresql.xml.DefaultPGXmlFactoryFactory;
+import org.postgresql.xml.PGXmlFactoryFactory;
-import org.xml.sax.ErrorHandler;
 import org.xml.sax.InputSource;
-import org.xml.sax.SAXParseException;
+import org.xml.sax.XMLReader;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -27,7 +28,6 @@
 import java.sql.SQLXML;
 import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLOutputFactory;
 import javax.xml.stream.XMLStreamException;
@@ -77,6 +77,13 @@ private PgSQLXML(BaseConnection conn, String data, boolean initialized) {
     this.freed = false;
   }
+  private PGXmlFactoryFactory getXmlFactoryFactory() throws SQLException {
+    if (conn != null) {
+      return conn.getXmlFactoryFactory();
+    }
+    return DefaultPGXmlFactoryFactory.INSTANCE;
+  }
+
   @Override
   public synchronized void free() {
     freed = true;
@@ -132,18 +139,17 @@ public synchronized Reader getCharacterStream() throws SQLException {
     try {
       if (sourceClass == null || DOMSource.class.equals(sourceClass)) {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        DocumentBuilder builder = factory.newDocumentBuilder();
-        builder.setErrorHandler(new NonPrintingErrorHandler());
+        DocumentBuilder builder = getXmlFactoryFactory().newDocumentBuilder();
         InputSource input = new InputSource(new StringReader(data));
         return (T) new DOMSource(builder.parse(input));
       } else if (SAXSource.class.equals(sourceClass)) {
+        XMLReader reader = getXmlFactoryFactory().createXMLReader();
         InputSource is = new InputSource(new StringReader(data));
-        return (T) new SAXSource(is);
+        return (T) new SAXSource(reader, is);
       } else if (StreamSource.class.equals(sourceClass)) {
         return (T) new StreamSource(new StringReader(data));
       } else if (StAXSource.class.equals(sourceClass)) {
-        XMLInputFactory xif = XMLInputFactory.newInstance();
+        XMLInputFactory xif = getXmlFactoryFactory().newXMLInputFactory();
         XMLStreamReader xsr = xif.createXMLStreamReader(new StringReader(data));
         return (T) new StAXSource(xsr);
       }
@@ -191,8 +197,7 @@ public synchronized Writer setCharacterStream() throws SQLException {
       return (T) domResult;
     } else if (SAXResult.class.equals(resultClass)) {
       try {
-        SAXTransformerFactory transformerFactory =
-            (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+        SAXTransformerFactory transformerFactory = getXmlFactoryFactory().newSAXTransformerFactory();
         TransformerHandler transformerHandler = transformerFactory.newTransformerHandler();
         stringWriter = new StringWriter();
         transformerHandler.setResult(new StreamResult(stringWriter));
@@ -209,7 +214,7 @@ public synchronized Writer setCharacterStream() throws SQLException {
     } else if (StAXResult.class.equals(resultClass)) {
       stringWriter = new StringWriter();
       try {
-        XMLOutputFactory xof = XMLOutputFactory.newInstance();
+        XMLOutputFactory xof = getXmlFactoryFactory().newXMLOutputFactory();
         XMLStreamWriter xsw = xof.createXMLStreamWriter(stringWriter);
         active = true;
         return (T) new StAXResult(xsw);
@@ -272,7 +277,7 @@ private void ensureInitialized() throws SQLException {
       try {
-        TransformerFactory factory = TransformerFactory.newInstance();
+        TransformerFactory factory = getXmlFactoryFactory().newTransformerFactory();
         Transformer transformer = factory.newTransformer();
         DOMSource domSource = new DOMSource(domResult.getNode());
         StringWriter stringWriter = new StringWriter();
@@ -298,18 +303,4 @@ private void initialize() throws SQLException {
     }
     initialized = true;
   }
-
-  // Don't clutter System.err with errors the user can't silence.
-  // If something bad really happens an exception will be thrown.
-  static class NonPrintingErrorHandler implements ErrorHandler {
-    public void error(SAXParseException e) {
-    }
-
-    public void fatalError(SAXParseException e) {
-    }
-
-    public void warning(SAXParseException e) {
-    }
-  }
-
 }",1,java,36.0,pgjdbc/src/main/java/org/postgresql/jdbc/PgSQLXML.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -17,18 +17,19 @@
 package com.googlecode.wicket.kendo.ui.dataviz.chart;
 import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import org.apache.wicket.util.io.IClusterable;
-import com.googlecode.wicket.jquery.core.ajax.AjaxPayload;
+import com.googlecode.wicket.jquery.core.ajax.HandlerPayload;
- * Provides a convenient {@link AjaxPayload} that can be used to broadcast a point information
+ * Provides a convenient {@link HandlerPayload} that can be used to broadcast a point information
-public class ChartPayload extends AjaxPayload implements IClusterable
+public class ChartPayload extends HandlerPayload implements IClusterable // NOSONAR
 {
 	private static final long serialVersionUID = 1L;
@@ -40,15 +41,15 @@ public class ChartPayload extends AjaxPayload implements IClusterable
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public ChartPayload(AjaxRequestTarget target, String seriesName, String seriesField, String category, long value)
+	public ChartPayload(IPartialPageRequestHandler handler, String seriesName, String seriesField, String category, long value)
 	{
-		super(target);
+		super(handler);
 		this.value = value;
 		this.category = category;",1,java,9.0,ChartPayload.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -86,26 +86,25 @@ private XMSSPrivateKeyParameters(Builder builder)
             position += rootSize;
             byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);
-            BDS bdsImport = null;
             try
             {
-                bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary);
+                BDS bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary, BDS.class);
+                bdsImport.setXMSS(builder.xmss);
+                bdsImport.validate();
+                if (bdsImport.getIndex() != index)
+                {
+                    throw new IllegalStateException(""serialized BDS has wrong index"");
+                }
+                bdsState = bdsImport;
             }
             catch (IOException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
             catch (ClassNotFoundException e)
             {
-                e.printStackTrace();
-            }
-            bdsImport.setXMSS(builder.xmss);
-            bdsImport.validate();
-            if (bdsImport.getIndex() != index)
-            {
-                throw new IllegalStateException(""serialized BDS has wrong index"");
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
-            bdsState = bdsImport;
         }
         else
         {",1,java,21.0,XMSSPrivateKeyParameters.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -13,6 +13,7 @@
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import org.springframework.http.HttpHeaders;
@@ -37,7 +38,7 @@ public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain
     HttpServletRequest request = (HttpServletRequest) req;
     HttpServletResponse response = (HttpServletResponse) resp;
-    String token = request.getHeader(""Authorization"");
+    String token = request.getHeader(HttpHeaders.AUTHORIZATION);
     Long consumerId = consumerAuthUtil.getConsumerId(token);",1,java,3.0,apollo-portal/src/main/java/com/ctrip/framework/apollo/openapi/filter/ConsumerAuthenticationFilter.java
a37b43cca82f108a8e3f5c2803a9b50911a60979,apache/activemq,train,"@@ -25,9 +25,9 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
+import javax.jms.IllegalStateException;
 import javax.jms.JMSException;
-import org.apache.activemq.DestinationDoesNotExistException;
 import org.apache.activemq.advisory.AdvisorySupport;
 import org.apache.activemq.broker.ConnectionContext;
 import org.apache.activemq.broker.ConsumerBrokerExchange;
@@ -50,6 +50,7 @@ import org.apache.activemq.filter.DestinationMap;
 import org.apache.activemq.security.SecurityContext;
 import org.apache.activemq.thread.TaskRunnerFactory;
 import org.apache.activemq.usage.SystemUsage;
+import org.apache.activemq.DestinationDoesNotExistException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -66,6 +67,7 @@ public abstract class AbstractRegion implements Region {
     protected final SystemUsage usageManager;
     protected final DestinationFactory destinationFactory;
     protected final DestinationStatistics destinationStatistics;
+    protected final RegionStatistics regionStatistics = new RegionStatistics();
     protected final RegionBroker broker;
     protected boolean autoCreateDestinations = true;
     protected final TaskRunnerFactory taskRunnerFactory;
@@ -124,7 +126,16 @@ public abstract class AbstractRegion implements Region {
         } finally {
             destinationsLock.readLock().unlock();
         }
-        destinations.clear();
+
+        destinationsLock.writeLock().lock();
+        try {
+            destinations.clear();
+            regionStatistics.getAdvisoryDestinations().reset();
+            regionStatistics.getDestinations().reset();
+            regionStatistics.getAllDestinations().reset();
+        } finally {
+            destinationsLock.writeLock().unlock();
+        }
     }
     @Override
@@ -136,6 +147,10 @@ public abstract class AbstractRegion implements Region {
             Destination dest = destinations.get(destination);
             if (dest == null) {
                 if (destination.isTemporary() == false || createIfTemporary) {
+                    // Limit the number of destinations that can be created if
+                    // maxDestinations has been set on a policy
+                    validateMaxDestinations(destination);
+
                     LOG.debug(""{} adding destination: {}"", broker.getBrokerName(), destination);
                     dest = createDestination(context, destination);
@@ -145,6 +160,7 @@ public abstract class AbstractRegion implements Region {
                     }
                     dest.start();
                     destinations.put(destination, dest);
+                    updateRegionDestCounts(destination, 1);
                     destinationMap.put(destination, dest);
                     addSubscriptionsForDestination(context, dest);
                 }
@@ -269,6 +285,8 @@ public abstract class AbstractRegion implements Region {
         try {
             Destination dest = destinations.remove(destination);
             if (dest != null) {
+                updateRegionDestCounts(destination, -1);
+
                 for (Iterator<Subscription> iter = subscriptions.values().iterator(); iter.hasNext();) {
@@ -693,7 +711,10 @@ public abstract class AbstractRegion implements Region {
                     destination = destinationInterceptor.intercept(destination);
                 }
                 getDestinationMap().put(key, destination);
-                destinations.put(key, destination);
+                Destination prev = destinations.put(key, destination);
+                if (prev == null) {
+                    updateRegionDestCounts(key, 1);
+                }
             }
         } finally {
             destinationsLock.writeLock().unlock();",1,java,22.0,AbstractRegion.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -0,0 +1,104 @@
+/*
+ * file:       UnmarshalHelper.java
+ * author:     Jon Iles
+ * copyright:  (c) Packwood Software 2020
+ * date:       29/08/2020
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package net.sf.mpxj.common;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.UnmarshallerHandler;
+import javax.xml.bind.ValidationEvent;
+import javax.xml.bind.ValidationEventHandler;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.sax.SAXSource;
+
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLFilter;
+
+/**
+ * Utility methods wrapping JAXB unmarshal.
+ */
+public final class UnmarshalHelper
+{
+   /**
+    * Unmarshal from an input stream.
+    *
+    * @param context JAXB context
+    * @param stream input stream
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputStream stream) throws JAXBException, SAXException, ParserConfigurationException
+   {
+      return context.createUnmarshaller().unmarshal(new SAXSource(XmlReaderHelper.createXmlReader(), new InputSource(stream)));
+   }
+
+   /**
+    * Unmarshall from an input stream and apply a filter.
+    *
+    * @param context JAXB context
+    * @param stream input stream
+    * @param filter XMLFilter instance
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputStream stream, XMLFilter filter) throws JAXBException, SAXException, ParserConfigurationException, IOException
+   {
+      return unmarshal(context, new InputSource(stream), filter, false);
+   }
+
+   /**
+    * Unmarshall from an input source and apply a filter, optionally ignore validation errors.
+    *
+    * @param context JAXB context
+    * @param source input source
+    * @param filter XMLFilter instance
+    * @param ignoreValidationErrors true if validation errors are ignored
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputSource source, XMLFilter filter, boolean ignoreValidationErrors) throws JAXBException, SAXException, ParserConfigurationException, IOException
+   {
+      Unmarshaller unmarshaller = context.createUnmarshaller();
+
+      if (ignoreValidationErrors)
+      {
+         unmarshaller.setEventHandler(new ValidationEventHandler()
+         {
+            @Override public boolean handleEvent(ValidationEvent event)
+            {
+               return true;
+            }
+         });
+      }
+
+      UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
+      filter.setParent(XmlReaderHelper.createXmlReader());
+      filter.setContentHandler(unmarshallerHandler);
+      filter.parse(source);
+
+      return unmarshallerHandler.getResult();
+   }
+
+}",1,java,45.0,src/main/java/net/sf/mpxj/common/UnmarshalHelper.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2020, PostgreSQL Global Development Group
+ * See the LICENSE file in the project root for more information.
+ */
+
+package org.postgresql.xml;
+
+import org.xml.sax.EntityResolver;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+public class EmptyStringEntityResolver implements EntityResolver {
+  public static final EmptyStringEntityResolver INSTANCE = new EmptyStringEntityResolver();
+
+  @Override
+  public InputSource resolveEntity(String publicId, String systemId)
+      throws SAXException, IOException {
+    return new InputSource(new StringReader(""""));
+  }
+}",1,java,15.0,pgjdbc/src/main/java/org/postgresql/xml/EmptyStringEntityResolver.java
a37b43cca82f108a8e3f5c2803a9b50911a60979,apache/activemq,train,"@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.activemq.broker.region;
+
+import org.apache.activemq.management.CountStatisticImpl;
+import org.apache.activemq.management.StatsImpl;
+
+/**
+ * The J2EE Statistics for the Connection.
+ *
+ *
+ */
+public class RegionStatistics extends StatsImpl {
+
+    private CountStatisticImpl advisoryDestinations;
+    private CountStatisticImpl destinations;
+    private CountStatisticImpl allDestinations;
+
+    public RegionStatistics() {
+        this(true);
+    }
+
+    public RegionStatistics(boolean enabled) {
+
+        advisoryDestinations = new CountStatisticImpl(""advisoryTopics"", ""The number of advisory destinations in the region"");
+        destinations = new CountStatisticImpl(""destinations"", ""The number of regular (non-adivsory) destinations in the region"");
+        allDestinations = new CountStatisticImpl(""allDestinations"", ""The total number of destinations, including advisory destinations, in the region"");
+
+        addStatistic(""advisoryDestinations"", advisoryDestinations);
+        addStatistic(""destinations"", destinations);
+        addStatistic(""allDestinations"", allDestinations);
+
+        this.setEnabled(enabled);
+    }
+
+    public CountStatisticImpl getAdvisoryDestinations() {
+        return advisoryDestinations;
+    }
+
+    public CountStatisticImpl getDestinations() {
+        return destinations;
+    }
+
+    public CountStatisticImpl getAllDestinations() {
+        return allDestinations;
+    }
+
+    public void reset() {
+        super.reset();
+        advisoryDestinations.reset();
+        destinations.reset();
+        allDestinations.reset();
+    }
+
+    public void setEnabled(boolean enabled) {
+        super.setEnabled(enabled);
+        advisoryDestinations.setEnabled(enabled);
+        destinations.setEnabled(enabled);
+        allDestinations.setEnabled(enabled);
+    }
+
+    public void setParent(RegionStatistics parent) {
+        if (parent != null) {
+            advisoryDestinations.setParent(parent.getAdvisoryDestinations());
+            destinations.setParent(parent.getDestinations());
+            allDestinations.setParent(parent.getAllDestinations());
+        } else {
+            advisoryDestinations.setParent(null);
+            destinations.setParent(null);
+            allDestinations.setParent(null);
+        }
+    }
+
+}",1,java,53.0,RegionStatistics.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,train,"@@ -0,0 +1,87 @@
+package com.ctrip.framework.apollo.adminservice.filter;
+
+import com.ctrip.framework.apollo.biz.config.BizConfig;
+import com.google.common.base.Splitter;
+import com.google.common.base.Strings;
+import java.io.IOException;
+import java.util.List;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.http.HttpHeaders;
+
+public class AdminServiceAuthenticationFilter implements Filter {
+
+  private static final Logger logger = LoggerFactory
+      .getLogger(AdminServiceAuthenticationFilter.class);
+  private static final Splitter ACCESS_TOKEN_SPLITTER = Splitter.on("","").omitEmptyStrings()
+      .trimResults();
+
+  private final BizConfig bizConfig;
+  private volatile String lastAccessTokens;
+  private volatile List<String> accessTokenList;
+
+  public AdminServiceAuthenticationFilter(BizConfig bizConfig) {
+    this.bizConfig = bizConfig;
+  }
+
+  @Override
+  public void init(FilterConfig filterConfig) throws ServletException {
+
+  }
+
+  @Override
+  public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
+      throws IOException, ServletException {
+    if (bizConfig.isAdminServiceAccessControlEnabled()) {
+      HttpServletRequest request = (HttpServletRequest) req;
+      HttpServletResponse response = (HttpServletResponse) resp;
+
+      String token = request.getHeader(HttpHeaders.AUTHORIZATION);
+
+      if (!checkAccessToken(token)) {
+        logger.warn(""Invalid access token: {} for uri: {}"", token, request.getRequestURI());
+        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, ""Unauthorized"");
+        return;
+      }
+    }
+
+    chain.doFilter(req, resp);
+  }
+
+  private boolean checkAccessToken(String token) {
+    String accessTokens = bizConfig.getAdminServiceAccessTokens();
+
+    // if user forget to configure access tokens, then default to pass
+    if (Strings.isNullOrEmpty(accessTokens)) {
+      return true;
+    }
+
+    // no need to check
+    if (Strings.isNullOrEmpty(token)) {
+      return false;
+    }
+
+    // update cache
+    if (!accessTokens.equals(lastAccessTokens)) {
+      synchronized (this) {
+        accessTokenList = ACCESS_TOKEN_SPLITTER.splitToList(accessTokens);
+        lastAccessTokens = accessTokens;
+      }
+    }
+
+    return accessTokenList.contains(token);
+  }
+
+  @Override
+  public void destroy() {
+
+  }
+}",1,java,67.0,apollo-adminservice/src/main/java/com/ctrip/framework/apollo/adminservice/filter/AdminServiceAuthenticationFilter.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -55,16 +55,12 @@ public class DefaultGetCaseViewFromDraftOperation extends AbstractDefaultGetCase
 
     @Override
     public CaseView execute(String draftId) {
-        throw new UnsupportedOperationException(""Method not implemented"");
-    }
-
-    @Override
-    public CaseView execute(String jurisdictionId, String caseTypeId, String draftId) {
-
-        final CaseType caseType = getCaseType(jurisdictionId, caseTypeId);
         final DraftResponse draftResponse = draftGateway.get(draftId);
 
         final CaseDetails caseDetails = draftResponseToCaseDetailsBuilder.build(draftResponse);
+
+        CaseType caseType = getCaseType(draftResponse.getCaseTypeId());
+
         final CaseViewTrigger resumeTrigger = buildResumeTriggerFromDraft(draftResponse);
 
         final CaseTabCollection caseTabCollection = getCaseTabCollection(draftResponse.getCaseTypeId());
",1,java,6.0,DefaultGetCaseViewFromDraftOperation.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -11,6 +11,7 @@
 import org.bouncycastle.crypto.params.DHParameters;
 import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
 import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.jcajce.provider.asymmetric.dh.BCDHPublicKey;
@@ -22,6 +23,10 @@ static public AsymmetricKeyParameter generatePublicKeyParameter(
         PublicKey    key)
         throws InvalidKeyException
     {
+        if (key instanceof BCDHPublicKey)
+        {
+            return ((BCDHPublicKey)key).engineGetKeyParameters();
+        }
         if (key instanceof DHPublicKey)
         {
             DHPublicKey    k = (DHPublicKey)key;",1,java,6.0,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/util/DHUtil.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -44,6 +44,7 @@ import org.keycloak.models.UserModel;
 import org.keycloak.models.UserSessionModel;
 import org.keycloak.models.utils.CredentialValidation;
 import org.keycloak.models.utils.FormMessage;
+import org.keycloak.models.utils.KeycloakModelUtils;
 import org.keycloak.protocol.oidc.utils.RedirectUtils;
 import org.keycloak.services.ForbiddenException;
 import org.keycloak.services.ServicesLogger;
@@ -343,15 +344,15 @@ public class AccountFormService extends AbstractSecuredLocalService {
     }
     @Path(""totp-remove"")
-    @GET
-    public Response processTotpRemove(@QueryParam(""stateChecker"") String stateChecker) {
+    @POST
+    public Response processTotpRemove(final MultivaluedMap<String, String> formData) {
         if (auth == null) {
             return login(""totp"");
         }
         auth.require(AccountRoles.MANAGE_ACCOUNT);
-        csrfCheck(stateChecker);
+        csrfCheck(formData);
         UserModel user = auth.getUser();
         session.userCredentialManager().disableCredentialType(realm, user, CredentialModel.OTP);
@@ -364,14 +365,14 @@ public class AccountFormService extends AbstractSecuredLocalService {
     @Path(""sessions-logout"")
-    @GET
-    public Response processSessionsLogout(@QueryParam(""stateChecker"") String stateChecker) {
+    @POST
+    public Response processSessionsLogout(final MultivaluedMap<String, String> formData) {
         if (auth == null) {
             return login(""sessions"");
         }
         auth.require(AccountRoles.MANAGE_ACCOUNT);
-        csrfCheck(stateChecker);
+        csrfCheck(formData);
         UserModel user = auth.getUser();
@@ -588,19 +589,21 @@ public class AccountFormService extends AbstractSecuredLocalService {
         return account.setPasswordSet(true).setSuccess(Messages.ACCOUNT_PASSWORD_UPDATED).createResponse(AccountPages.PASSWORD);
     }
-    @Path(""federated-identity-update"")
-    @GET
-    public Response processFederatedIdentityUpdate(@QueryParam(""action"") String action,
-                                                   @QueryParam(""provider_id"") String providerId,
-                                                   @QueryParam(""stateChecker"") String stateChecker) {
+    @Path(""identity"")
+    @POST
+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
+    public Response processFederatedIdentityUpdate(final MultivaluedMap<String, String> formData) {
         if (auth == null) {
             return login(""identity"");
         }
         auth.require(AccountRoles.MANAGE_ACCOUNT);
-        csrfCheck(stateChecker);
+        csrfCheck(formData);
         UserModel user = auth.getUser();
+        String action = formData.getFirst(""action"");
+        String providerId = formData.getFirst(""providerId"");
+
         if (Validation.isEmpty(providerId)) {
             setReferrerOnPage();
             return account.setError(Messages.MISSING_IDENTITY_PROVIDER).createResponse(AccountPages.FEDERATED_IDENTITY);",1,java,26.0,AccountFormService.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2020, Verizon Inc.
+ * Licensed under the Apache License, Version 2.0
+ * See LICENSE file in project root for terms.
+ */
+package com.yahoo.elide.graphql.containers;
+
+import com.yahoo.elide.graphql.Environment;
+import com.yahoo.elide.graphql.NonEntityDictionary;
+import com.yahoo.elide.graphql.PersistentResourceFetcher;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+/**
+ * Container for models not managed by Elide.
+ */
+@AllArgsConstructor
+public class NonEntityContainer implements GraphQLContainer {
+    @Getter private final Object nonEntity;
+
+    @Override
+    public Object processFetch(Environment context, PersistentResourceFetcher fetcher) {
+        NonEntityDictionary nonEntityDictionary = fetcher.getNonEntityDictionary();
+
+        String fieldName = context.field.getName();
+
+        //There is no Elide security for models not managed by Elide.
+        Object object = nonEntityDictionary.getValue(nonEntity, fieldName, context.requestScope);
+
+        if (object == null) {
+            return null;
+        }
+
+        if (nonEntityDictionary.hasBinding(object.getClass())) {
+            return new NonEntityContainer(object);
+        }
+
+        if (object instanceof Map) {
+            return ((Map<Object, Object>) object).entrySet().stream()
+                    .map(MapEntryContainer::new)
+                    .collect(Collectors.toList());
+        }
+
+        if (object instanceof Collection) {
+            Class<?> innerType = nonEntityDictionary.getParameterizedType(nonEntity.getClass(), fieldName);
+
+            if (nonEntityDictionary.hasBinding(innerType)) {
+                return ((Collection) object).stream()
+                        .map(NonEntityContainer::new)
+                        .collect(Collectors.toList());
+            }
+        }
+
+        return object;
+    }
+}
",1,java,40.0,NonEntityContainer.java
ce5c3e8079d64929abb76ec3ec7ac7c71a4a26b6,dotCMS/core,train,"@@ -1,15 +1,27 @@
 package com.dotcms.util;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.servlet.http.HttpServletRequest;
+import com.dotmarketing.beans.Host;
+import com.dotmarketing.business.APILocator;
+import com.dotmarketing.util.Config;
 import com.dotmarketing.util.Logger;
+import com.dotmarketing.util.SecurityLogger;
+import com.dotmarketing.util.UtilMethods;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
 import com.liferay.util.Xss;
+import io.vavr.control.Try;
+
- * This class exposes utility routines related to security aspects of dotCMS
- * that can be used by several pieces of the system.
+ * This class exposes utility routines related to security aspects of dotCMS that can be used by
+ * several pieces of the system.
@@ -18,121 +30,258 @@
 public class SecurityUtils {
-	/**
-	 * Contains the different delay strategies that can be used to halt the
-	 * normal flow of a request or thread:
-	 * <ul>
-	 * <li>{@code POW}: (Default strategy) Causes the thread to sleep for the
-	 * <b>seconds</b> specified by raising the seed value to the power of 2.</li>
-	 * <li>{@code TIME_MIN}: Causes the thread to sleep for the <b>minutes</b>
-	 * specified in the seed value.</li>
-	 * <li>{@code TIME_SEC}: Causes the thread to sleep for the <b>seconds</b>
-	 * specified in the seed value.</li>
-	 * <li>{@code TIME_MILLS}: Causes the thread to sleep for the
-	 * <b>milliseconds</b> specified in the seed value.</li>
-	 * </ul>
-	 * 
-	 * @author Jose Castro
-	 * @version 3.7
-	 * @since Aug 11, 2016
-	 *
-	 */
-	public enum DelayStrategy {
-		POW, TIME_MILLS, TIME_SEC, TIME_MIN
-	}
-	
-	/**
-	 * 
-	 * @param request
-	 * @param referer
-	 * @return
-	 * @throws IllegalArgumentException
-	 */
-	public static String stripReferer ( HttpServletRequest request, String referer ) throws IllegalArgumentException {
-
-    	if(referer==null) return referer;
-
-        String ref = referer;
-        
-        ref = Xss.strip(ref);
-        
-        if(ref.contains(""%0d"") || ref.contains(""%0a""))
-            ref = ""/"";
-        
-        return ref;
+  /**
+   * Contains the different delay strategies that can be used to halt the normal flow of a request or
+   * thread:
+   * <ul>
+   * <li>{@code POW}: (Default strategy) Causes the thread to sleep for the <b>seconds</b> specified
+   * by raising the seed value to the power of 2.</li>
+   * <li>{@code TIME_MIN}: Causes the thread to sleep for the <b>minutes</b> specified in the seed
+   * value.</li>
+   * <li>{@code TIME_SEC}: Causes the thread to sleep for the <b>seconds</b> specified in the seed
+   * value.</li>
+   * <li>{@code TIME_MILLS}: Causes the thread to sleep for the <b>milliseconds</b> specified in the
+   * seed value.</li>
+   * </ul>
+   * 
+   * @author Jose Castro
+   * @version 3.7
+   * @since Aug 11, 2016
+   *
+   */
+  public enum DelayStrategy {
+    POW, TIME_MILLS, TIME_SEC, TIME_MIN
+  }
+
+  /**
+   * 
+   * @param request
+   * @param referer
+   * @return
+   * @throws IllegalArgumentException
+   */
+  public static String stripReferer(HttpServletRequest request, String referer) throws IllegalArgumentException {
+
+    if (referer == null)
+      return referer;
+
+    String ref = referer;
+
+    ref = Xss.strip(ref);
+
+    if (ref.contains(""%0d"") || ref.contains(""%0a""))
+      ref = ""/"";
+
+    return ref;
+  }
+
+  /**
+   * This is a useful mechanism for dealing with DoS and similar security attacks in which it might be
+   * adequate to temporarily pause a request for a specific time before letting it continue. This is
+   * particularly useful to deal with multiple failed login attempts, in which the attacker can be
+   * penalized for it. Different security strategies can be added in order to counter-attack these
+   * threats.
+   * <p>
+   * By default, the approach consists of taking a seed value and raising it to the power of 2. The
+   * result will represent the seconds that a given request will have to wait before moving on. For
+   * example, during a failed authentication, the {@code seed} can be the number of failed login
+   * attempts. This way, the more times hackers fail to authenticate, the more time they will have to
+   * wait to try it again.
+   * 
+   * @param seed - The number of times that a user has tried to log in and failed.
+   * @param delayStrategy - The delay strategy used after a failed login.
+   */
+  public static void delayRequest(long seed, final DelayStrategy delayStrategy) {
+    seed = Math.abs(seed);
+    if (delayStrategy.equals(DelayStrategy.TIME_MIN)) {
+      try {
+
+        Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" minutes"");
+
+        TimeUnit.MINUTES.sleep(seed);
+      } catch (NumberFormatException e) {
+        // Invalid number, defaults to no thread sleep
+      } catch (InterruptedException e) {
+        // Sleep was interrupted, just ignore it
+      }
+    } else if (delayStrategy.equals(DelayStrategy.TIME_SEC)) {
+      try {
+
+        Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" seconds"");
+
+        TimeUnit.SECONDS.sleep(seed);
+      } catch (NumberFormatException e) {
+        // Invalid number, defaults to no thread sleep
+      } catch (InterruptedException e) {
+        // Sleep was interrupted, just ignore it
+      }
+    } else if (delayStrategy.equals(DelayStrategy.TIME_MILLS)) {
+      try {
+
+        Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" milliseconds"");
+
+        TimeUnit.MILLISECONDS.sleep(seed);
+      } catch (NumberFormatException e) {
+        // Invalid number, defaults to no thread sleep
+      } catch (InterruptedException e) {
+        // Sleep was interrupted, just ignore it
+      }
+    } else {
+      // Default strategy: DelayStrategy.POW
+      if (seed > 0) {
+        final long sleepTime = (long) Math.pow(seed, 2);
+        try {
+
+          Logger.debug(SecurityUtils.class, ""Sleeping "" + sleepTime + "" seconds"");
+          TimeUnit.SECONDS.sleep(sleepTime);
+        } catch (InterruptedException e) {
+          // Sleep was interrupted, just ignore it
+        }
+      }
     }
-	/**
-	 * This is a useful mechanism for dealing with DoS and similar security
-	 * attacks in which it might be adequate to temporarily pause a request for
-	 * a specific time before letting it continue. This is particularly useful
-	 * to deal with multiple failed login attempts, in which the attacker can be
-	 * penalized for it. Different security strategies can be added in order to 
-	 * counter-attack these threats.
-	 * <p>
-	 * By default, the approach consists of taking a seed value and raising it
-	 * to the power of 2. The result will represent the seconds that a given
-	 * request will have to wait before moving on. For example, during a failed
-	 * authentication, the {@code seed} can be the number of failed login
-	 * attempts. This way, the more times hackers fail to authenticate, the more
-	 * time they will have to wait to try it again.
-	 * 
-	 * @param seed
-	 *            - The number of times that a user has tried to log in and
-	 *            failed.
-	 * @param delayStrategy
-	 *            - The delay strategy used after a failed login.
-	 */
-	public static void delayRequest(long seed, final DelayStrategy delayStrategy) {
-		seed = Math.abs(seed);
-		if (delayStrategy.equals(DelayStrategy.TIME_MIN)) {
-			try {
-
-				Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" minutes"");
-
-				TimeUnit.MINUTES.sleep(seed);
-			} catch (NumberFormatException e) {
-				// Invalid number, defaults to no thread sleep
-			} catch (InterruptedException e) {
-				// Sleep was interrupted, just ignore it
-			}
-		} else if (delayStrategy.equals(DelayStrategy.TIME_SEC)) {
-			try {
-
-				Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" seconds"");
-
-				TimeUnit.SECONDS.sleep(seed);
-			} catch (NumberFormatException e) {
-				// Invalid number, defaults to no thread sleep
-			} catch (InterruptedException e) {
-				// Sleep was interrupted, just ignore it
-			}
-		} else if (delayStrategy.equals(DelayStrategy.TIME_MILLS)) {
-			try {
-
-				Logger.debug(SecurityUtils.class, ""Sleeping "" + seed + "" milliseconds"");
-
-				TimeUnit.MILLISECONDS.sleep(seed);
-			} catch (NumberFormatException e) {
-				// Invalid number, defaults to no thread sleep
-			} catch (InterruptedException e) {
-				// Sleep was interrupted, just ignore it
-			}
-		} else {
-			// Default strategy: DelayStrategy.POW
-			if (seed > 0) {
-				final long sleepTime = (long) Math.pow(seed, 2);
-				try {
-
-					Logger.debug(SecurityUtils.class, ""Sleeping "" + sleepTime + "" seconds"");
-					TimeUnit.SECONDS.sleep(sleepTime);
-				} catch (InterruptedException e) {
-					// Sleep was interrupted, just ignore it
-				}
-			}
-		}
-
-		Logger.debug(SecurityUtils.class, ""Leaving the delayRequest"");
-	}
+    Logger.debug(SecurityUtils.class, ""Leaving the delayRequest"");
+  }
+
+  /**
+   * This method takes a request and makes sure that it is coming the same origin as
+   * the referer or origin headers, e.g. a known source. It is
+   * intended to help mitigate agsinst XSS and CSRF attacks
+   * 
+   * @param request
+   * @return
+   */
+  public boolean validateReferer(HttpServletRequest request) {
+    
+    final String uri = request.getRequestURI() ==null ? ""/"" : request.getRequestURI().toLowerCase();
+    final String url = request.getServerName() + uri;
+    final String urlHost = hostFromUrl(url);
+    final String incomingReferer = (request.getHeader(""Origin"")!=null) ? request.getHeader(""Origin"") :  request.getHeader(""referer"");
+    final String refererHost = hostFromUrl(incomingReferer);
+    
+    // good: we allow CSS because css @import statements do not send referers
+    if(refererHost == null && uri.endsWith("".css"")) {
+      return true;
+    }
+    
+    // good: the url host == the refererHost
+    if (urlHost.equalsIgnoreCase(refererHost)) {
+        return true;
+    }
+    
+    // good: uri is on the ignore list
+    if(this.loadIgnorePaths()
+        .stream()
+        .anyMatch(
+            path->(path.endsWith(""*"") && uri.startsWith(path.substring(0, path.lastIndexOf('*'))) || 
+            uri.equals(path)))) {
+      return true;
+    }
+
+    
+    // good: the referer is a host that is being served from dotCMS
+    if(isRefererOneOfOurHosts(refererHost)) {
+      return true;
+    }
+
+    // good: if the urlHost should be ignored (this should almost never happen)
+    if(this.loadIgnoreHosts().contains(urlHost)) {
+      return true;
+    }
+
+    Try.run(()-> SecurityLogger.logInfo(SecurityUtils.class, ""InvalidReferer, ip:"" + request.getRemoteAddr() +"", url:"" + request.getRequestURL() + "", referer:"" + incomingReferer));
+    Try.run(()-> Logger.info(SecurityUtils.class, ""InvalidReferer, ip:"" + request.getRemoteAddr() +"", url:"" + request.getRequestURL() + "", referer:"" + incomingReferer));
+    return false;
+  }
+  
+  @VisibleForTesting
+  protected String getPortalHost() {
+    return hostFromUrl(APILocator.getCompanyAPI().getDefaultCompany().getPortalURL());
+  }
+  
+  @VisibleForTesting
+  protected boolean resolveHost(String refererHost) {
+    Host foundHost = Try.of(()->APILocator.getHostAPI().findByName(refererHost, APILocator.getUserAPI().getSystemUser(), false)).getOrNull();
+    if (!UtilMethods.isSet(foundHost)) {
+      foundHost = Try.of(()->APILocator.getHostAPI().findByAlias(refererHost, APILocator.getUserAPI().getSystemUser(), false)).getOrNull();
+    }
+    return UtilMethods.isSet(foundHost);
+  }
+  
+  /**
+   * Checks if the referer matches a hostname that is being served by dotCMS. 
+   * As a security precaution, this will return false for the default host shipped
+   * with dotCMS : demo.dotcms.com
+   * @param refererHost
+   * @return
+   */
+  private boolean isRefererOneOfOurHosts(final String refererHost) {
+    // disallow links from our open demo
+    if(refererHost==null) {
+      return false;
+    }
+    // allow referers 
+    if (refererHost.equalsIgnoreCase(hostFromUrl(getPortalHost()))) {
+      return true;
+    }
+
+    return resolveHost(refererHost) ;
+  }
+  
+  
+  /**
+   * get the hostname portion of a url string
+   * @param url
+   * @return
+   */
+  private String hostFromUrl(final String url) {
+    if(url==null) return null;
+    return Try.of(() -> {
+      return (url.contains(""://"")) ? new URL(url.trim()).getHost().toLowerCase() : new URL(""http://"" + url.trim()).getHost().toLowerCase();
+    }).getOrNull();
+  }
+  
+  
+  private static List<String> IGNORE_REFERER_FOR_HOSTS = null;
+
+  private static List<String> IGNORE_REFERER_FOR_PATHS = null;
+  /**
+   * Load Ignore paths
+   * @return
+   */
+  @VisibleForTesting
+  protected List<String> loadIgnorePaths() {
+    if (IGNORE_REFERER_FOR_PATHS == null) {
+      List<String> ignorePathsStartingWith = new ArrayList<>();
+      String[] paths = Config.getStringArrayProperty(""IGNORE_REFERER_FOR_PATHS"", new String[0] );
+      for (String path : paths) {
+        if (UtilMethods.isSet(path)) {
+          ignorePathsStartingWith.add(path.toLowerCase().trim());
+        }
+      }
+      IGNORE_REFERER_FOR_PATHS = ImmutableList.copyOf(ignorePathsStartingWith);
+    }
+    return IGNORE_REFERER_FOR_PATHS;
+  }
+  
+  /**
+   * Load Ignore hosts
+   * @return
+   */
+  @VisibleForTesting
+  protected List<String> loadIgnoreHosts() {
+    if (IGNORE_REFERER_FOR_HOSTS == null) {
+      List<String> ignoreHostsStartingWith = new ArrayList<>();
+      String[] paths = Config.getStringArrayProperty(""IGNORE_REFERER_FOR_HOSTS"", new String[0] );
+      for (String path : paths) {
+        if (UtilMethods.isSet(path)) {
+          ignoreHostsStartingWith.add(path.toLowerCase().trim());
+        }
+      }
+      IGNORE_REFERER_FOR_HOSTS = ImmutableList.copyOf(ignoreHostsStartingWith);
+    }
+    return IGNORE_REFERER_FOR_HOSTS;
+  }
+  
 }",1,java,188.0,dotCMS/src/main/java/com/dotcms/util/SecurityUtils.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -44,22 +44,15 @@ public RainbowParameters()
     public RainbowParameters(int[] vi)
     {
         this.vi = vi;
-        try
-        {
-            checkParams();
-        }
-        catch (Exception e)
-        {
-            e.printStackTrace();
-        }
+
+        checkParams();
     }
     private void checkParams()
-        throws Exception
     {
         if (vi == null)
         {
-            throw new Exception(""no layers defined."");
+            throw new IllegalArgumentException(""no layers defined."");
         }
         if (vi.length > 1)
         {
@@ -67,14 +60,14 @@ private void checkParams()
             {
                 if (vi[i] >= vi[i + 1])
                 {
-                    throw new Exception(
+                    throw new IllegalArgumentException(
                         ""v[i] has to be smaller than v[i+1]"");
                 }
             }
         }
         else
         {
-            throw new Exception(
+            throw new IllegalArgumentException(
                 ""Rainbow needs at least 1 layer, such that v1 < v2."");
         }
     }",1,java,16.0,core/src/main/java/org/bouncycastle/pqc/crypto/rainbow/RainbowParameters.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,kiegroup/jbpm-designer,train,"@@ -2,18 +2,33 @@ package org.jbpm.designer.server.service;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.util.*;
-import javax.annotation.PostConstruct;
+import java.net.MalformedURLException;
+import java.net.Socket;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
 import javax.enterprise.context.ApplicationScoped;
 import javax.enterprise.event.Event;
 import javax.enterprise.inject.Instance;
 import javax.inject.Inject;
 
 import org.apache.commons.codec.binary.Base64;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.protocol.Protocol;
+import org.apache.http.HttpEntity;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.DefaultBHttpClientConnection;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.util.EntityUtils;
 import org.jboss.errai.bus.server.annotations.Service;
 import org.jbpm.designer.repository.Asset;
 import org.jbpm.designer.repository.AssetBuilderFactory;
@@ -22,9 +37,10 @@ import org.jbpm.designer.repository.UriUtils;
 import org.jbpm.designer.repository.impl.AssetBuilder;
 import org.jbpm.designer.service.BPMN2DataServices;
 import org.jbpm.designer.service.DesignerAssetService;
-import org.jbpm.designer.util.OSProtocolSocketFactory;
 import org.jbpm.designer.util.Utils;
 import org.json.JSONArray;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.uberfire.backend.server.util.Paths;
 import org.uberfire.backend.vfs.Path;
 import org.uberfire.mvp.PlaceRequest;
@@ -35,6 +51,8 @@ import org.uberfire.workbench.events.ResourceOpenedEvent;
 @ApplicationScoped
 public class DefaultDesignerAssetService implements DesignerAssetService {
 
+    private static Logger logger = LoggerFactory.getLogger(DefaultDesignerAssetService.class);
+
     @Inject
     private Repository repository;
     
@@ -46,6 +64,9 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
 
     @Inject
     private Event<ResourceOpenedEvent> resourceOpenedEvent;
+   
+    // socket buffer size in bytes: can be tuned for performance
+    private final static int socketBufferSize = 8 * 1024;
 
     public static final String PROCESS_STUB = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?> \n"" +
     ""<bpmn2:definitions xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" xmlns=\""http://www.omg.org/bpmn20\"" xmlns:bpmn2=\""http://www.omg.org/spec/BPMN/20100524/MODEL\"" xmlns:bpmndi=\""http://www.omg.org/spec/BPMN/20100524/DI\"" xmlns:bpsim=\""http://www.bpsim.org/schemas/1.0\"" xmlns:dc=\""http://www.omg.org/spec/DD/20100524/DC\"" xmlns:drools=\""http://www.jboss.org/drools\"" \n"" +
@@ -63,11 +84,6 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
     ""</bpmn2:definitions>"";
 
 
-    @PostConstruct
-    public void configure() {
-        Protocol.registerProtocol(""http"", new Protocol(""http"", new OSProtocolSocketFactory(), 80));
-    }
-
     @Override
     public Map<String, String> getEditorParameters( final Path path,
                                   final String editorID,
@@ -132,9 +148,6 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
         resourceOpenedEvent.fire(new ResourceOpenedEvent( path, sessionInfo ));
 
         return editorParamsMap;
-//        String editorURL = hostInfo + ""/editor/?uuid="" + path.toURI() + ""&profile=jbpm&pp=&editorid="" + editorID + ""&readonly="" + readOnly +
-//                ""&activenodes="" + encodedActiveNodesParam + ""&completednodes="" + encodedCompletedNodesParam;
-//        return getEditorResponse( editorURL, encodedProcessSource );
     }
 
     @Override
@@ -163,31 +176,74 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
 
     private String getEditorResponse( String urlpath,
                                       String encProcessSrc ) {
-        HttpClient httpclient = new HttpClient();
-
-        PostMethod authMethod = new PostMethod( urlpath );
-        NameValuePair[] data = { new NameValuePair( ""j_username"", ""admin"" ),
-                new NameValuePair( ""j_password"", ""admin"" ) };
-        authMethod.setRequestBody( data );
+        CloseableHttpClient httpClient = HttpClientBuilder.create().build();
+    
+        // convert string to url in order to get host and port
+        URL url;
+        try { 
+            url = new URL(urlpath);
+        } catch( MalformedURLException murle ) { 
+            logger.error( ""Incorrect URL: "" + murle.getMessage(), murle );
+            return null;
+        }
+       
+        // configure socket to ignore local addresses (this constructur instead of full constructor)
+        Socket socket;
         try {
-            httpclient.executeMethod( authMethod );
-        } catch ( IOException e ) {
+            socket = new Socket(url.getHost(), url.getPort());
+        DefaultBHttpClientConnection conn = new DefaultBHttpClientConnection(socketBufferSize);
+        conn.bind(socket);
+        } catch( Exception  e ) {
             e.printStackTrace();
+        }
+      
+        // TODO: tiho, if it's possible to do preemptive basic authentication here (which it is?, I think?), please let me know. 
+        // Then you can do everything in one request, which will improve performance.. :) -- mriet
+       
+        // setup form authentication
+        List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+        formParams.add(new BasicNameValuePair(""j_username"", ""admin""));
+        formParams.add(new BasicNameValuePair(""j_password"", ""admin""));
+        UrlEncodedFormEntity formEntity;
+        try {
+            formEntity = new UrlEncodedFormEntity(formParams);
+        } catch( UnsupportedEncodingException uee ) {
+            logger.error(""Could not encode authentication parameters into request body"", uee);
+            return null;
+        }
+       
+        // do form authentication
+        HttpPost authMethod = new HttpPost(urlpath);
+        authMethod.setEntity(formEntity);
+        try {
+            httpClient.execute(authMethod);
+        } catch (IOException ioe) {
+            logger.error(""Could not initialize form-based authentication"", ioe);
             return null;
         } finally {
             authMethod.releaseConnection();
         }
-
-        PostMethod theMethod = new PostMethod( urlpath );
-        theMethod.setParameter( ""processsource"", encProcessSrc );
-        StringBuffer sb = new StringBuffer();
+       
+        // create post method and add query parameter
+        HttpPost theMethod = new HttpPost( urlpath );
+        BasicHttpParams params = new BasicHttpParams();
+        params.setParameter( ""processsource"", encProcessSrc );
+        theMethod.setParams(params);
+        
+        // execute post method and return response content
         try {
-            httpclient.executeMethod( theMethod );
-            sb.append( theMethod.getResponseBodyAsString() );
-            return sb.toString();
-
+            // post
+            CloseableHttpResponse response = httpClient.execute( theMethod );
+            
+            // extract content
+            HttpEntity respEntity = response.getEntity();
+            String responseBody = null;
+            if( respEntity != null ) { 
+                responseBody = EntityUtils.toString(respEntity);
+            }
+            return responseBody;
         } catch ( Exception e ) {
-            e.printStackTrace();
+            logger.error(""Could not do POST method and retrieve content: "" + e.getMessage(), e);
             return null;
         } finally {
             theMethod.releaseConnection();
@@ -200,9 +256,9 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
             location = location.replaceFirst( ""/"", """" );
         }
         location = location.replaceAll( ""/"", ""."" );
-
+            
         if(location.length() > 0) {
-            String[] locationParts = location.split(""\\."");
+       String[] locationParts = location.split(""\\."");
             location = locationParts[0];
         }
 
",1,java,91.0,DefaultDesignerAssetService.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -17,7 +17,7 @@
 package com.googlecode.wicket.kendo.ui.utils;
 import org.apache.wicket.Component;
-import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import com.googlecode.wicket.jquery.core.IJQueryWidget.JQueryWidget;
 import com.googlecode.wicket.kendo.ui.effect.KendoEffect;
@@ -43,39 +43,39 @@ public class KendoEffectUtils
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void reload(AjaxRequestTarget target, Component component)
+	public static void reload(IPartialPageRequestHandler handler, Component component)
 	{
-		KendoEffectUtils.reload(target, component, KendoEffectUtils.effect);
+		KendoEffectUtils.reload(handler, component, KendoEffectUtils.effect);
 	}
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void reload(AjaxRequestTarget target, Component component, KendoEffect effect)
+	public static void reload(IPartialPageRequestHandler handler, Component component, KendoEffect effect)
 	{
-		KendoEffectUtils.reload(target, component, effect, false);
+		KendoEffectUtils.reload(handler, component, effect, false);
 	}
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void reload(AjaxRequestTarget target, Component component, KendoEffect effect, boolean reverse)
+	public static void reload(IPartialPageRequestHandler handler, Component component, KendoEffect effect, boolean reverse)
 	{
 		String selector = JQueryWidget.getSelector(component);
-		target.add(component);
-		target.appendJavaScript(String.format(""kendo.fx(jQuery('%s')).%s.%s();"", selector, effect, !reverse ? ""play"" : ""reverse""));
+		handler.add(component);
+		handler.appendJavaScript(String.format(""kendo.fx(jQuery('%s')).%s.%s();"", selector, effect, !reverse ? ""play"" : ""reverse""));
 	}
 }",1,java,16.0,KendoEffectUtils.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -155,16 +155,9 @@ public int hashCode()
         for (i = 0; i < mDegree; i++)
         {
-            try
-            {
-                a[i] = new GF2Polynomial(matrix[i]);
-                inv[i] = new GF2Polynomial(mDegree);
-                inv[i].setBit(mDegree - 1 - i);
-            }
-            catch (RuntimeException BDNEExc)
-            {
-                BDNEExc.printStackTrace();
-            }
+            a[i] = new GF2Polynomial(matrix[i]);
+            inv[i] = new GF2Polynomial(mDegree);
+            inv[i].setBit(mDegree - 1 - i);
         }",1,java,13.0,GF2nField.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -1,9 +1,5 @@
 package com.dotcms.util;
-import com.dotmarketing.business.APILocator;
-import com.dotmarketing.portlets.languagesmanager.model.Language;
-import com.liferay.util.LocaleUtil;
-
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Collection;
@@ -12,7 +8,8 @@
 import javax.servlet.http.HttpServletRequest;
-import static com.dotcms.util.CollectionsUtils.map;
+import com.dotmarketing.business.APILocator;
+import com.liferay.util.LocaleUtil;
@@ -76,29 +73,11 @@ private I18NUtil() {}
-    public Map<String, String> getMessagesMap (final Locale locale, final Collection<String> messagesKey) {
-
-        final Map<String, String> messagesMap = map();
-
-        if (null != messagesKey) {
-            final Language lang = APILocator.getLanguageAPI().getLanguage(locale.getLanguage(), locale.getCountry());
-            messagesKey.forEach(
-                    messageKey -> {
+    public Map<String, String> getMessagesMap (final Locale locale, final Collection<String> keys) {
-                        try {
-                            
-                            messagesMap.put(messageKey,
-                                    APILocator.getLanguageAPI().getStringKey(lang, messageKey));
-                        } catch (Exception e) {
-                            messagesMap.put(messageKey,
-                                    messageKey);
-                        }
-                    }
-            );
-        }
+          return APILocator.getLanguageAPI().getStringsAsMap(locale, keys); 
-        return messagesMap;
     } // getMessagesMap.",1,java,25.0,dotCMS/src/main/java/com/dotcms/util/I18NUtil.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -0,0 +1,60 @@
+/*
+ * Copyright 2020, Yahoo Inc.
+ * Licensed under the Apache License, Version 2.0
+ * See LICENSE file in project root for terms.
+ */
+
+package example;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.Currency;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@JsonDeserialize(using = Price.PriceDeserializer.class)
+public class Price {
+    private BigDecimal units;
+    private Currency currency;
+
+    public static class PriceDeserializer extends StdDeserializer<Price> {
+        public PriceDeserializer() {
+            super(Price.class);
+        }
+
+
+        @Override
+        public Price deserialize(JsonParser parser, DeserializationContext ctxt) throws IOException {
+            JsonNode node = parser.getCodec().readTree(parser);
+            if (node == null) {
+                return null;
+            }
+
+            JsonNode unitNode = node.get(""units"");
+
+            if (unitNode == null) {
+                return null;
+            }
+
+            JsonNode currencyNode = node.get(""currency"");
+
+            if (currencyNode == null) {
+                return new Price(new BigDecimal(unitNode.asInt()), null);
+            }
+
+            Currency currency = Currency.getInstance(node.get(""currency"").get(""currencyCode"").asText(""""));
+
+            return new Price(new BigDecimal(unitNode.asInt()), currency);
+        }
+    }
+}
",1,java,43.0,Price.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -75,6 +75,7 @@ public boolean verify(String s, SSLSession sslSession) {
                 return true;
             }
         };
+        acceptAnyCertificate = Boolean.getBoolean(ASYNC_CLIENT + ""acceptAnyCertificate"");
     }
     void configureExecutors() {
@@ -165,11 +166,6 @@ public AsyncHttpClientConfigBean setSslContext(SSLContext sslContext) {
         return this;
     }
-    public AsyncHttpClientConfigBean setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
-        this.sslEngineFactory = sslEngineFactory;
-        return this;
-    }
-
     public AsyncHttpClientConfigBean setProviderConfig(AsyncHttpProviderConfig<?, ?> providerConfig) {
         this.providerConfig = providerConfig;
         return this;
@@ -234,4 +230,9 @@ public AsyncHttpClientConfigBean setIoThreadMultiplier(int ioThreadMultiplier) {
         this.ioThreadMultiplier = ioThreadMultiplier;
         return this;
     }
+
+    public AsyncHttpClientConfigBean setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+        this.acceptAnyCertificate = acceptAnyCertificate;
+        return this;
+    }
 }",1,java,9.0,src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -24,7 +24,7 @@
 import org.bouncycastle.crypto.KeyEncoder;
 import org.bouncycastle.crypto.agreement.ECDHBasicAgreement;
 import org.bouncycastle.crypto.digests.SHA1Digest;
-import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.AESEngine;
 import org.bouncycastle.crypto.engines.DESedeEngine;
 import org.bouncycastle.crypto.engines.IESEngine;
 import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
@@ -538,7 +538,7 @@ public ECIESwithDESedeCBC()
     {
         public ECIESwithAESCBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), 16);
+            super(new CBCBlockCipher(new AESEngine()), 16);
         }
     }
 }",1,java,4.0,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/IESCipher.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -43,7 +43,7 @@ public class DefaultValidateCaseFieldsOperation implements ValidateCaseFieldsOpe
     }
 
     private boolean hasEventId(CaseType caseType, String eventId) {
-        return caseType.getEvents().stream().anyMatch(event -> event.getId().equals(eventId));
+        return caseType.hasEventId(eventId);
     }
 
     @Override
",1,java,2.0,DefaultValidateCaseFieldsOperation.java
f61e5daf299d6c37c7ad65744d02556c94a16a4,apache/storm,train,"@@ -861,52 +861,9 @@ public class Utils {
-    public static void unJar(File jarFile, File toDir)
-            throws IOException {
-        JarFile jar = new JarFile(jarFile);
-        try {
-            Enumeration<JarEntry> entries = jar.entries();
-            while (entries.hasMoreElements()) {
-                final JarEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = jar.getInputStream(entry);
-                    try {
-                        File file = new File(toDir, entry.getName());
-                        ensureDirectory(file.getParentFile());
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            copyBytes(in, out, 8192);
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            jar.close();
-        }
-    }
-
-    /**
-     * Copies from one stream to another.
-     *
-     * @param in InputStream to read from
-     * @param out OutputStream to write to
-     * @param buffSize the size of the buffer
-     */
-    public static void copyBytes(InputStream in, OutputStream out, int buffSize)
-            throws IOException {
-        PrintStream ps = out instanceof PrintStream ? (PrintStream)out : null;
-        byte buf[] = new byte[buffSize];
-        int bytesRead = in.read(buf);
-        while (bytesRead >= 0) {
-            out.write(buf, 0, bytesRead);
-            if ((ps != null) && ps.checkError()) {
-                throw new IOException(""Unable to write to output stream."");
-            }
-            bytesRead = in.read(buf);
+    public static void unJar(File jarFile, File toDir) throws IOException {
+        try (JarFile jar = new JarFile(jarFile)) {
+            extractZipFile(jar, toDir, null);
         }
     }
@@ -930,20 +887,17 @@ public class Utils {
+     * @param symlinksDisabled true if symlinks should be disabled, else false.
-    public static void unTar(File inFile, File untarDir) throws IOException {
-        if (!untarDir.mkdirs()) {
-            if (!untarDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create "" + untarDir);
-            }
-        }
+    public static void unTar(File inFile, File untarDir, boolean symlinksDisabled) throws IOException {
+        ensureDirectory(untarDir);
         boolean gzipped = inFile.toString().endsWith(""gz"");
-        if (isOnWindows()) {
+        if (Utils.isOnWindows() || symlinksDisabled) {
-            unTarUsingJava(inFile, untarDir, gzipped);
+            unTarUsingJava(inFile, untarDir, gzipped, symlinksDisabled);
         } else {
@@ -980,7 +934,9 @@ public class Utils {
     }
     private static void unTarUsingJava(File inFile, File untarDir,
-                                       boolean gzipped) throws IOException {
+                                       boolean gzipped, boolean symlinksDisabled) throws IOException {
+        final String base = untarDir.getCanonicalPath();
+        LOG.trace(""java untar {} to {}"", inFile, base);
         InputStream inputStream = null;
         try {
             if (gzipped) {
@@ -991,7 +947,7 @@ public class Utils {
             }
             try (TarArchiveInputStream tis = new TarArchiveInputStream(inputStream)) {
                 for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null; ) {
-                    unpackEntries(tis, entry, untarDir);
+                    unpackEntries(tis, entry, untarDir, base, symlinksDisabled);
                     entry = tis.getNextTarEntry();
                 }
             }
@@ -1003,35 +959,82 @@ public class Utils {
     }
     private static void unpackEntries(TarArchiveInputStream tis,
-                                      TarArchiveEntry entry, File outputDir) throws IOException {
+                                      TarArchiveEntry entry, File outputDir, final String base,
+                                      boolean symlinksDisabled) throws IOException {
+        File target = new File(outputDir, entry.getName());
+        String found = target.getCanonicalPath();
+        if (!found.startsWith(base)) {
+            LOG.error(""Invalid location {} is outside of {}"", found, base);
+            return;
+        }
         if (entry.isDirectory()) {
-            File subDir = new File(outputDir, entry.getName());
-            if (!subDir.mkdirs() && !subDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                        + outputDir);
-            }
+            LOG.trace(""Extracting dir {}"", target);
+            ensureDirectory(target);
             for (TarArchiveEntry e : entry.getDirectoryEntries()) {
-                unpackEntries(tis, e, subDir);
+                unpackEntries(tis, e, target, base, symlinksDisabled);
             }
-            return;
+        } else if (entry.isSymbolicLink()) {
+            if (symlinksDisabled) {
+                LOG.info(""Symlinks disabled skipping {}"", target);
+            } else {
+                Path src = target.toPath();
+                Path dest = Paths.get(entry.getLinkName());
+                LOG.trace(""Extracting sym link {} to {}"", target, dest);
+                // Create symbolic link relative to tar parent dir
+                Files.createSymbolicLink(src, dest);
+            }
+        } else if (entry.isFile()) {
+            LOG.trace(""Extracting file {}"", target);
+            ensureDirectory(target.getParentFile());
+            try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
+                IOUtils.copy(tis, outputStream);
+            }
+        } else {
+            LOG.error(""{} is not a currently supported tar entry type."", entry);
         }
-        File outputFile = new File(outputDir, entry.getName());
-        if (!outputFile.getParentFile().exists()) {
-            if (!outputFile.getParentFile().mkdirs()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                                      + outputDir);
+
+        Path p = target.toPath();
+        if (Files.exists(p)) {
+            try {
+                //We created it so lets chmod it properly
+                int mode = entry.getMode();
+                Files.setPosixFilePermissions(p, parsePerms(mode));
+            } catch (UnsupportedOperationException e) {
+                //Ignored the file system we are on does not support this, so don't do it.
             }
         }
-        int count;
-        byte data[] = new byte[2048];
-        BufferedOutputStream outputStream = new BufferedOutputStream(
-                new FileOutputStream(outputFile));
+    }
-        while ((count = tis.read(data)) != -1) {
-            outputStream.write(data, 0, count);
+    private static Set<PosixFilePermission> parsePerms(int mode) {
+        Set<PosixFilePermission> ret = new HashSet<>();
+        if ((mode & 0001) > 0) {
+            ret.add(PosixFilePermission.OTHERS_EXECUTE);
+        }
+        if ((mode & 0002) > 0) {
+            ret.add(PosixFilePermission.OTHERS_WRITE);
+        }
+        if ((mode & 0004) > 0) {
+            ret.add(PosixFilePermission.OTHERS_READ);
+        }
+        if ((mode & 0010) > 0) {
+            ret.add(PosixFilePermission.GROUP_EXECUTE);
         }
-        outputStream.flush();
-        outputStream.close();
+        if ((mode & 0020) > 0) {
+            ret.add(PosixFilePermission.GROUP_WRITE);
+        }
+        if ((mode & 0040) > 0) {
+            ret.add(PosixFilePermission.GROUP_READ);
+        }
+        if ((mode & 0100) > 0) {
+            ret.add(PosixFilePermission.OWNER_EXECUTE);
+        }
+        if ((mode & 0200) > 0) {
+            ret.add(PosixFilePermission.OWNER_WRITE);
+        }
+        if ((mode & 0400) > 0) {
+            ret.add(PosixFilePermission.OWNER_READ);
+        }
+        return ret;
     }
     public static boolean isOnWindows() {
@@ -1045,16 +1048,21 @@ public class Utils {
         return Paths.get(path).isAbsolute();
     }
-    public static void unpack(File localrsrc, File dst) throws IOException {
+    public static void unpack(File localrsrc, File dst, boolean symLinksDisabled) throws IOException {
         String lowerDst = localrsrc.getName().toLowerCase();
-        if (lowerDst.endsWith("".jar"")) {
+        if (lowerDst.endsWith("".jar"") ||
+            lowerDst.endsWith(""_jar"")) {
             unJar(localrsrc, dst);
-        } else if (lowerDst.endsWith("".zip"")) {
+        } else if (lowerDst.endsWith("".zip"") ||
+            lowerDst.endsWith(""_zip"")) {
             unZip(localrsrc, dst);
         } else if (lowerDst.endsWith("".tar.gz"") ||
-                lowerDst.endsWith("".tgz"") ||
-                lowerDst.endsWith("".tar"")) {
-            unTar(localrsrc, dst);
+            lowerDst.endsWith(""_tar_gz"") ||
+            lowerDst.endsWith("".tgz"") ||
+            lowerDst.endsWith(""_tgz"") ||
+            lowerDst.endsWith("".tar"") ||
+            lowerDst.endsWith(""_tar"")) {
+            unTar(localrsrc, dst, symLinksDisabled);
         } else {
             LOG.warn(""Cannot unpack "" + localrsrc);
             if (!localrsrc.renameTo(dst)) {
@@ -1067,6 +1075,35 @@ public class Utils {
         }
     }
+    private static void extractZipFile(ZipFile zipFile, File toDir, String prefix) throws IOException {
+        ensureDirectory(toDir);
+        final String base = toDir.getCanonicalPath();
+
+        Enumeration<? extends ZipEntry> entries = zipFile.entries();
+        while (entries.hasMoreElements()) {
+            ZipEntry entry = entries.nextElement();
+            if (!entry.isDirectory()) {
+                if (prefix != null && !entry.getName().startsWith(prefix)) {
+                    //No need to extract it, it is not what we are looking for.
+                    continue;
+                }
+                File file = new File(toDir, entry.getName());
+                String found = file.getCanonicalPath();
+                if (!found.startsWith(base)) {
+                    LOG.error(""Invalid location {} is outside of {}"", found, base);
+                    continue;
+                }
+
+                try (InputStream in = zipFile.getInputStream(entry)) {
+                    ensureDirectory(file.getParentFile());
+                    try (OutputStream out = new FileOutputStream(file)) {
+                        IOUtils.copy(in, out);
+                    }
+                }
+            }
+        }
+    }
+
     public static boolean canUserReadBlob(ReadableBlobMeta meta, String user) {
         SettableBlobMeta settable = meta.get_settable();
         for (AccessControl acl : settable.get_acl()) {
@@ -1397,45 +1434,12 @@ public class Utils {
-     * @param unzipDir The unzip directory where to unzip the zip file.
+     * @param toDir The unzip directory where to unzip the zip file.
-    public static void unZip(File inFile, File unzipDir) throws IOException {
-        Enumeration<? extends ZipEntry> entries;
-        ZipFile zipFile = new ZipFile(inFile);
-
-        try {
-            entries = zipFile.entries();
-            while (entries.hasMoreElements()) {
-                ZipEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = zipFile.getInputStream(entry);
-                    try {
-                        File file = new File(unzipDir, entry.getName());
-                        if (!file.getParentFile().mkdirs()) {
-                            if (!file.getParentFile().isDirectory()) {
-                                throw new IOException(""Mkdirs failed to create "" +
-                                                      file.getParentFile().toString());
-                            }
-                        }
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            byte[] buffer = new byte[8192];
-                            int i;
-                            while ((i = in.read(buffer)) != -1) {
-                                out.write(buffer, 0, i);
-                            }
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            zipFile.close();
-        }
+    public static void unZip(File inFile, File toDir) throws IOException {
+        try (ZipFile zipFile = new ZipFile(inFile)) {
+            extractZipFile(zipFile, toDir, null);        }
     }
@@ -1905,21 +1909,10 @@ public class Utils {
     public static void extractDirFromJar(String jarpath, String dir, File destdir) {
         _instance.extractDirFromJarImpl(jarpath, dir, destdir);
     }
-    
+
     public void extractDirFromJarImpl(String jarpath, String dir, File destdir) {
         try (JarFile jarFile = new JarFile(jarpath)) {
-            Enumeration<JarEntry> jarEnums = jarFile.entries();
-            while (jarEnums.hasMoreElements()) {
-                JarEntry entry = jarEnums.nextElement();
-                if (!entry.isDirectory() && entry.getName().startsWith(dir)) {
-                    File aFile = new File(destdir, entry.getName());
-                    aFile.getParentFile().mkdirs();
-                    try (FileOutputStream out = new FileOutputStream(aFile);
-                         InputStream in = jarFile.getInputStream(entry)) {
-                        IOUtils.copy(in, out);
-                    }
-                }
-            }
+            extractZipFile(jarFile, destdir, dir);
         } catch (IOException e) {
             LOG.info(""Could not extract {} from {}"", dir, jarpath);
         }",1,java,237.0,Utils.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -40,18 +40,10 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
-import javax.xml.bind.ValidationEvent;
-import javax.xml.bind.ValidationEventHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.AssignmentField;
 import net.sf.mpxj.Availability;
@@ -104,6 +96,7 @@
 import net.sf.mpxj.common.Pair;
 import net.sf.mpxj.common.SplitTaskFactory;
 import net.sf.mpxj.common.TimephasedWorkNormaliser;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.mpp.CustomFieldValueItem;
 import net.sf.mpxj.mspdi.schema.Project;
@@ -177,6 +170,11 @@ private Charset getCharset()
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
@@ -193,41 +191,9 @@ private Charset getCharset()
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
          DatatypeConverter.setParentFile(m_projectFile);
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         //
-         // If we are matching the behaviour of MS project, then we need to
-         // ignore validation warnings.
-         //
-         if (m_compatibleInput == true)
-         {
-            unmarshaller.setEventHandler(new ValidationEventHandler()
-            {
-               @Override public boolean handleEvent(ValidationEvent event)
-               {
-                  return (true);
-               }
-            });
-         }
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(new InputSource(new InputStreamReader(stream, getCharset())));
-         Project project = (Project) unmarshallerHandler.getResult();
+         Project project = (Project) UnmarshalHelper.unmarshal(CONTEXT, new InputSource(new InputStreamReader(stream, getCharset())), new NamespaceFilter(), !m_compatibleInput);
          HashMap<BigInteger, ProjectCalendar> calendarMap = new HashMap<>();",1,java,40.0,src/main/java/net/sf/mpxj/mspdi/MSPDIReader.java
0fc6b522487c061f89e8cdacf09f722d3f20589,apache/storm,train,"@@ -543,7 +543,7 @@ public class Localizer {
           out.close();
           in.close();
           if (uncompress) {
-            Utils.unpack(new File(downloadFile), new File(localFileWithVersion));
+            Utils.unpack(new File(downloadFile), new File(localFileWithVersion), (boolean)OR(_conf.get(Config.DISABLE_SYMLINKS), false));
             LOG.debug(""uncompressed "" + downloadFile + "" to: "" + localFileWithVersion);
           }",1,java,2.0,Localizer.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -40,18 +40,10 @@ import java.util.UUID;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
-import javax.xml.bind.ValidationEvent;
-import javax.xml.bind.ValidationEventHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.AssignmentField;
 import net.sf.mpxj.Availability;
@@ -104,6 +96,7 @@ import net.sf.mpxj.common.NumberHelper;
 import net.sf.mpxj.common.Pair;
 import net.sf.mpxj.common.SplitTaskFactory;
 import net.sf.mpxj.common.TimephasedWorkNormaliser;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.mpp.CustomFieldValueItem;
 import net.sf.mpxj.mspdi.schema.Project;
@@ -177,6 +170,11 @@ public final class MSPDIReader extends AbstractProjectReader
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
 
@@ -193,41 +191,9 @@ public final class MSPDIReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
          DatatypeConverter.setParentFile(m_projectFile);
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         //
-         // If we are matching the behaviour of MS project, then we need to
-         // ignore validation warnings.
-         //
-         if (m_compatibleInput == true)
-         {
-            unmarshaller.setEventHandler(new ValidationEventHandler()
-            {
-               @Override public boolean handleEvent(ValidationEvent event)
-               {
-                  return (true);
-               }
-            });
-         }
 
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(new InputSource(new InputStreamReader(stream, getCharset())));
-         Project project = (Project) unmarshallerHandler.getResult();
+         Project project = (Project) UnmarshalHelper.unmarshal(CONTEXT, new InputSource(new InputStreamReader(stream, getCharset())), new NamespaceFilter(), !m_compatibleInput);
 
          HashMap<BigInteger, ProjectCalendar> calendarMap = new HashMap<>();
 
",1,java,40.0,MSPDIReader.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,train,"@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) Will Sargent. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.Principal;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * A HostnameChecker proxy.
+ */
+public class ProxyHostnameChecker implements HostnameChecker {
+
+    public final static byte TYPE_TLS = 1;
+
+    private final Object checker = getHostnameChecker();
+
+    public ProxyHostnameChecker() {
+    }
+
+    private Object getHostnameChecker() {
+        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+        try {
+            final Class<Object> hostnameCheckerClass = (Class<Object>) classLoader.loadClass(""sun.security.util.HostnameChecker"");
+            final Method instanceMethod = hostnameCheckerClass.getMethod(""getInstance"", Byte.TYPE);
+            return instanceMethod.invoke(null, TYPE_TLS);
+        } catch (ClassNotFoundException e) {
+            throw new IllegalStateException(e);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            throw new IllegalStateException(e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public void match(String hostname, X509Certificate peerCertificate) throws CertificateException {
+        try {
+            final Class<?> hostnameCheckerClass = checker.getClass();
+            final Method checkMethod = hostnameCheckerClass.getMethod(""match"", String.class, X509Certificate.class);
+            checkMethod.invoke(checker, hostname, peerCertificate);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            Throwable t = e.getCause();
+            if (t instanceof CertificateException) {
+                throw (CertificateException) t;
+            } else {
+                throw new IllegalStateException(e);
+            }
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public boolean match(String hostname, Principal principal) {
+        try {
+            final Class<?> hostnameCheckerClass = checker.getClass();
+            final Method checkMethod = hostnameCheckerClass.getMethod(""match"", String.class, Principal.class);
+            return (Boolean) checkMethod.invoke(null, hostname, principal);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalStateException(e);
+        } catch (InvocationTargetException e) {
+            throw new IllegalStateException(e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+}",1,java,60.0,api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -44,22 +44,15 @@ public RainbowParameters()
     public RainbowParameters(int[] vi)
     {
         this.vi = vi;
-        try
-        {
-            checkParams();
-        }
-        catch (Exception e)
-        {
-            e.printStackTrace();
-        }
+
+        checkParams();
     }
     private void checkParams()
-        throws Exception
     {
         if (vi == null)
         {
-            throw new Exception(""no layers defined."");
+            throw new IllegalArgumentException(""no layers defined."");
         }
         if (vi.length > 1)
         {
@@ -67,14 +60,14 @@ private void checkParams()
             {
                 if (vi[i] >= vi[i + 1])
                 {
-                    throw new Exception(
+                    throw new IllegalArgumentException(
                         ""v[i] has to be smaller than v[i+1]"");
                 }
             }
         }
         else
         {
-            throw new Exception(
+            throw new IllegalArgumentException(
                 ""Rainbow needs at least 1 layer, such that v1 < v2."");
         }
     }",1,java,16.0,RainbowParameters.java
e6aa166246d1734f4798a9e31f78842f4c85c28b,jenkinsci/jenkins,train,"@@ -40,7 +40,7 @@
     public SecretRewriter() throws GeneralSecurityException {
         cipher = Secret.getCipher(""AES"");
-        key = Secret.getLegacyKey();
+        key = HistoricalSecrets.getLegacyKey();
     }
@@ -62,7 +62,7 @@ private String tryRewrite(String s) throws IOException, InvalidKeyException {
             return s;   // not a valid base64
         }
         cipher.init(Cipher.DECRYPT_MODE, key);
-        Secret sec = Secret.tryDecrypt(cipher, in);
+        Secret sec = HistoricalSecrets.tryDecrypt(cipher, in);
         if(sec!=null) // matched
             return sec.getEncryptedValue(); // replace by the new encrypted value
         else // not encrypted with the legacy key. leave it unmodified",1,java,4.0,core/src/main/java/hudson/util/SecretRewriter.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -11,6 +11,7 @@
 import org.bouncycastle.crypto.params.DHParameters;
 import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
 import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.jcajce.provider.asymmetric.dh.BCDHPublicKey;
@@ -22,6 +23,10 @@ static public AsymmetricKeyParameter generatePublicKeyParameter(
         PublicKey    key)
         throws InvalidKeyException
     {
+        if (key instanceof BCDHPublicKey)
+        {
+            return ((BCDHPublicKey)key).engineGetKeyParameters();
+        }
         if (key instanceof DHPublicKey)
         {
             DHPublicKey    k = (DHPublicKey)key;",1,java,6.0,DHUtil.java
c19cc705688cfffa4fe735e0edbe84862b6c135f,jenkinsci/jenkins,train,"@@ -23,6 +23,7 @@
 package hudson.model;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import hudson.FilePath;
 import hudson.Util;
 import java.io.IOException;
@@ -36,9 +37,12 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.StringTokenizer;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletResponse;
 import jenkins.model.Jenkins;
@@ -64,6 +68,9 @@ import org.kohsuke.stapler.StaplerResponse;
 public final class DirectoryBrowserSupport implements HttpResponse {
+    // escape hatch for SECURITY-904 to keep legacy behavior
+    @SuppressFBWarnings(value = ""MS_SHOULD_BE_FINAL"", justification = ""Accessible via System Groovy Scripts"")
+    public static boolean ALLOW_SYMLINK_ESCAPE = Boolean.getBoolean(DirectoryBrowserSupport.class.getName() + "".allowSymlinkEscape"");
     public final ModelObject owner;
@@ -212,13 +219,19 @@ public final class DirectoryBrowserSupport implements HttpResponse {
         String base = _base.toString();
         String rest = _rest.toString();
+        if(!ALLOW_SYMLINK_ESCAPE && (root.supportIsDescendant() && !root.isDescendant(base))){
+            LOGGER.log(Level.WARNING, ""Trying to access a file outside of the directory, target: ""+ base);
+            rsp.sendError(HttpServletResponse.SC_FORBIDDEN, ""Trying to access a file outside of the directory, target: "" + base);
+            return;
+        }
+
         VirtualFile baseFile = root.child(base);
         if(baseFile.isDirectory()) {
             if(zip) {
                 rsp.setContentType(""application/zip"");
-                zip(rsp.getOutputStream(), baseFile, rest);
+                zip(rsp, root, baseFile, rest);
                 return;
             }
             if (plain) {
@@ -246,8 +259,8 @@ public final class DirectoryBrowserSupport implements HttpResponse {
             }
             List<List<Path>> glob = null;
-
-            if(rest.length()>0) {
+            boolean patternUsed = rest.length() > 0;
+            if(patternUsed) {
                 glob = patternScan(baseFile, rest, createBackRef(restSize));
             } else
@@ -257,13 +270,15 @@ public final class DirectoryBrowserSupport implements HttpResponse {
             }
             if(glob!=null) {
+                List<List<Path>> filteredGlob = keepReadabilityOnlyOnDescendants(baseFile, patternUsed, glob);
+                
                 req.setAttribute(""it"", this);
                 List<Path> parentPaths = buildParentPath(base,restSize);
                 req.setAttribute(""parentPath"",parentPaths);
                 req.setAttribute(""backPath"", createBackRef(restSize));
                 req.setAttribute(""topPath"", createBackRef(parentPaths.size()+restSize));
-                req.setAttribute(""files"", glob);
+                req.setAttribute(""files"", filteredGlob);
                 req.setAttribute(""icon"", icon);
                 req.setAttribute(""path"", path);
                 req.setAttribute(""pattern"",rest);
@@ -319,6 +334,57 @@ public final class DirectoryBrowserSupport implements HttpResponse {
             rsp.serveFile(req, in, lastModified, -1, length, baseFile.getName() );
         }
     }
+    
+    private List<List<Path>> keepReadabilityOnlyOnDescendants(VirtualFile root, boolean patternUsed, List<List<Path>> pathFragmentsList){
+        Stream<List<Path>> pathFragmentsStream = pathFragmentsList.stream().map((List<Path> pathFragments) -> {
+            List<Path> mappedFragments = new ArrayList<>(pathFragments.size());
+            String relativePath = """";
+            for (int i = 0; i < pathFragments.size(); i++) {
+                Path current = pathFragments.get(i);
+                if (i == 0) {
+                    relativePath = current.title;
+                } else {
+                    relativePath += ""/"" + current.title;
+                }
+            
+                if (!current.isReadable) {
+                    if (patternUsed) {
+                        // we do not want to leak information about existence of folders / files satisfying the pattern inside that folder
+                        return null;
+                    }
+                    mappedFragments.add(current);
+                    return mappedFragments;
+                } else {
+                    if (isDescendant(root, relativePath)) {
+                        mappedFragments.add(current);
+                    } else {
+                        if (patternUsed) {
+                            // we do not want to leak information about existence of folders / files satisfying the pattern inside that folder
+                            return null;
+                        }
+                        mappedFragments.add(Path.createNotReadableVersionOf(current));
+                        return mappedFragments;
+                    }
+                }
+            }
+            return mappedFragments;
+        });
+    
+        if (patternUsed) {
+            pathFragmentsStream = pathFragmentsStream.filter(Objects::nonNull);
+        }
+        
+        return pathFragmentsStream.collect(Collectors.toList());
+    }
+
+    private boolean isDescendant(VirtualFile root, String relativePath){
+        try {
+            return ALLOW_SYMLINK_ESCAPE || !root.supportIsDescendant() || root.isDescendant(relativePath);
+        }
+        catch (IOException e) {
+            return false;
+        }
+    }
     private String getPath(StaplerRequest req) {
         String path = req.getRestOfPath();
@@ -352,7 +418,8 @@ public final class DirectoryBrowserSupport implements HttpResponse {
         return buf.toString();
     }
-    private static void zip(OutputStream outputStream, VirtualFile dir, String glob) throws IOException {
+    private static void zip(StaplerResponse rsp, VirtualFile root, VirtualFile dir, String glob) throws IOException, InterruptedException {
+        OutputStream outputStream = rsp.getOutputStream();
         try (ZipOutputStream zos = new ZipOutputStream(outputStream)) {
             zos.setEncoding(System.getProperty(""file.encoding"")); // TODO JENKINS-20663 make this overridable via query parameter
             for (String n : dir.list(glob.length() == 0 ? ""**"" : glob)) {
@@ -363,18 +430,24 @@ public final class DirectoryBrowserSupport implements HttpResponse {
                 } else {
                     relativePath = n;
                 }
-                // In ZIP archives ""All slashes MUST be forward slashes"" (http://pkware.com/documents/casestudies/APPNOTE.TXT)
-                // TODO On Linux file names can contain backslashes which should not treated as file separators.
-                //      Unfortunately, only the file separator char of the master is known (File.separatorChar)
-                //      but not the file separator char of the (maybe remote) ""dir"".
-                ZipEntry e = new ZipEntry(relativePath.replace('\\', '/'));
-                VirtualFile f = dir.child(n);
-                e.setTime(f.lastModified());
-                zos.putNextEntry(e);
-                try (InputStream in = f.open()) {
-                    IOUtils.copy(in, zos);
+
+                String targetFile = dir.toString().substring(root.toString().length()) + n;
+                if (!ALLOW_SYMLINK_ESCAPE && root.supportIsDescendant() && !root.isDescendant(targetFile)) {
+                    LOGGER.log(Level.INFO, ""Trying to access a file outside of the directory: "" + root + "", illicit target: "" + targetFile);
+                } else {
+                    // In ZIP archives ""All slashes MUST be forward slashes"" (http://pkware.com/documents/casestudies/APPNOTE.TXT)
+                    // TODO On Linux file names can contain backslashes which should not treated as file separators.
+                    //      Unfortunately, only the file separator char of the master is known (File.separatorChar)
+                    //      but not the file separator char of the (maybe remote) ""dir"".
+                    ZipEntry e = new ZipEntry(relativePath.replace('\\', '/'));
+                    VirtualFile f = dir.child(n);
+                    e.setTime(f.lastModified());
+                    zos.putNextEntry(e);
+                    try (InputStream in = f.open()) {
+                        IOUtils.copy(in, zos);
+                    }
+                    zos.closeEntry();
                 }
-                zos.closeEntry();
             }
         }
     }
@@ -446,6 +519,10 @@ public final class DirectoryBrowserSupport implements HttpResponse {
             return size;
         }
+        public static Path createNotReadableVersionOf(Path that){
+            return new Path(that.href, that.title, that.isFolder, that.size, false);
+        }
+
         private static final long serialVersionUID = 1L;
     }",1,java,88.0,DirectoryBrowserSupport.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -18,13 +18,12 @@
 import com.ning.http.client.filter.IOExceptionFilter;
 import com.ning.http.client.filter.RequestFilter;
 import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.util.AllowAllHostnameVerifier;
+import com.ning.http.util.DefaultHostnameVerifier;
 import com.ning.http.util.ProxyUtils;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import java.security.GeneralSecurityException;
+import javax.net.ssl.SSLSession;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
@@ -68,7 +67,6 @@
     protected ExecutorService applicationThreadPool;
     protected ProxyServerSelector proxyServerSelector;
     protected SSLContext sslContext;
-    protected SSLEngineFactory sslEngineFactory;
     protected AsyncHttpProviderConfig<?, ?> providerConfig;
     protected ConnectionsPool<?, ?> connectionsPool;
     protected Realm realm;
@@ -86,6 +84,7 @@
     protected boolean useRelativeURIsWithSSLProxies;
     protected int maxConnectionLifeTimeInMs;
     protected boolean rfc6265CookieEncoding;
+    protected boolean acceptAnyCertificate;
     protected AsyncHttpClientConfig() {
     }
@@ -107,7 +106,6 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   ExecutorService applicationThreadPool,
                                   ProxyServerSelector proxyServerSelector,
                                   SSLContext sslContext,
-                                  SSLEngineFactory sslEngineFactory,
                                   AsyncHttpProviderConfig<?, ?> providerConfig,
                                   ConnectionsPool<?, ?> connectionsPool, Realm realm,
                                   List<RequestFilter> requestFilters,
@@ -122,7 +120,8 @@ private AsyncHttpClientConfig(int maxTotalConnections,
                                   int ioThreadMultiplier,
                                   boolean strict302Handling,
                                   boolean useRelativeURIsWithSSLProxies,
-                                  boolean rfc6265CookieEncoding) {
+                                  boolean rfc6265CookieEncoding,
+                                  boolean acceptAnyCertificate) {
         this.maxTotalConnections = maxTotalConnections;
         this.maxConnectionPerHost = maxConnectionPerHost;
@@ -138,7 +137,6 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.userAgent = userAgent;
         this.allowPoolingConnection = keepAlive;
         this.sslContext = sslContext;
-        this.sslEngineFactory = sslEngineFactory;
         this.providerConfig = providerConfig;
         this.connectionsPool = connectionsPool;
         this.realm = realm;
@@ -154,6 +152,7 @@ private AsyncHttpClientConfig(int maxTotalConnections,
         this.strict302Handling = strict302Handling;
         this.useRelativeURIsWithSSLProxies = useRelativeURIsWithSSLProxies;
         this.rfc6265CookieEncoding = rfc6265CookieEncoding;
+        this.acceptAnyCertificate = acceptAnyCertificate;
         if (applicationThreadPool == null) {
             this.applicationThreadPool = Executors.newCachedThreadPool();
@@ -321,28 +320,6 @@ public SSLContext getSSLContext() {
         return connectionsPool;
     }
-    /**
-     * Return an instance of {@link SSLEngineFactory} used for SSL connection.
-     *
-     * @return an instance of {@link SSLEngineFactory} used for SSL connection.
-     */
-    public SSLEngineFactory getSSLEngineFactory() {
-        if (sslEngineFactory == null) {
-            return new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() {
-                    if (sslContext != null) {
-                        SSLEngine sslEngine = sslContext.createSSLEngine();
-                        sslEngine.setUseClientMode(true);
-                        return sslEngine;
-                    } else {
-                        return null;
-                    }
-                }
-            };
-        }
-        return sslEngineFactory;
-    }
-
@@ -467,6 +444,17 @@ public boolean isValid() {
     public HostnameVerifier getHostnameVerifier() {
+        if (hostnameVerifier == null) {
+            synchronized (this) {
+                if (hostnameVerifier == null)
+                    hostnameVerifier = acceptAnyCertificate ? new HostnameVerifier() {
+                        @Override
+                        public boolean verify(String hostname, SSLSession session) {
+                            return true;
+                        }
+                    } : new DefaultHostnameVerifier();
+            }
+        }
         return hostnameVerifier;
     }
@@ -523,6 +511,10 @@ public boolean isRfc6265CookieEncoding() {
         return rfc6265CookieEncoding;
     }
+    public boolean isAcceptAnyCertificate() {
+        return acceptAnyCertificate;
+    }
+
@@ -547,7 +539,6 @@ public boolean isRfc6265CookieEncoding() {
         private ExecutorService applicationThreadPool;
         private ProxyServerSelector proxyServerSelector = null;
         private SSLContext sslContext;
-        private SSLEngineFactory sslEngineFactory;
         private AsyncHttpProviderConfig<?, ?> providerConfig;
         private ConnectionsPool<?, ?> connectionsPool;
         private Realm realm;
@@ -559,10 +550,11 @@ public boolean isRfc6265CookieEncoding() {
         private boolean allowSslConnectionPool = true;
         private boolean useRawUrl = false;
         private boolean removeQueryParamOnRedirect = true;
-        private HostnameVerifier hostnameVerifier = new AllowAllHostnameVerifier();
+        private HostnameVerifier hostnameVerifier = new DefaultHostnameVerifier();
         private int ioThreadMultiplier = 2;
         private boolean strict302Handling;
         private boolean rfc6265CookieEncoding;
+        private boolean acceptAnyCertificate = Boolean.getBoolean(ASYNC_CLIENT + ""acceptAnyCertificate"");
         public Builder() {
         }
@@ -600,6 +592,16 @@ public Builder setConnectionTimeoutInMs(int defaultConnectionTimeOutInMs) {
             return this;
         }
+        /**
+         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+         *
+         * @param connectTimeout the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can wait when connecting to a remote host
+         * @return a {@link Builder}
+         */
+        public Builder setConnectTimeout(int connectTimeout) {
+            return setConnectionTimeoutInMs(connectTimeout);
+        }
+
@@ -638,6 +640,17 @@ public Builder setIdleConnectionInPoolTimeoutInMs(int defaultIdleConnectionInPoo
             return this;
         }
+        /**
+         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+         *
+         * @param readTimeout
+         *         the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} can stay idle.
+         * @return a {@link Builder}
+         */
+        public Builder setReadTimeout(int readTimeout) {
+            return setIdleConnectionTimeoutInMs(readTimeout);
+        }
+
@@ -649,6 +662,16 @@ public Builder setRequestTimeoutInMs(int defaultRequestTimeoutInMs) {
             return this;
         }
+        /**
+         * Set the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+         *
+         * @param requestTimeout the maximum time in millisecond an {@link com.ning.http.client.AsyncHttpClient} wait for a response
+         * @return a {@link Builder}
+         */
+        public Builder setRequestTimeout(int requestTimeout) {
+            return setRequestTimeoutInMs(requestTimeout);
+        }
+
@@ -762,17 +785,6 @@ public Builder setProxyServer(ProxyServer proxyServer) {
             return this;
         }
-        /**
-         * Set the {@link SSLEngineFactory} for secure connection.
-         *
-         * @param sslEngineFactory the {@link SSLEngineFactory} for secure connection
-         * @return a {@link Builder}
-         */
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            this.sslEngineFactory = sslEngineFactory;
-            return this;
-        }
-
@@ -780,13 +792,6 @@ public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
         public Builder setSSLContext(final SSLContext sslContext) {
-            this.sslEngineFactory = new SSLEngineFactory() {
-                public SSLEngine newSSLEngine() throws GeneralSecurityException {
-                    SSLEngine sslEngine = sslContext.createSSLEngine();
-                    sslEngine.setUseClientMode(true);
-                    return sslEngine;
-                }
-            };
             this.sslContext = sslContext;
             return this;
         }
@@ -1043,6 +1048,11 @@ public Builder setMaxConnectionLifeTimeInMs(int maxConnectionLifeTimeInMs) {
            return this;
         }
+        public Builder setAcceptAnyCertificates(boolean acceptAnyCertificate) {
+            this.acceptAnyCertificate = acceptAnyCertificate;
+            return this;
+        }
+
@@ -1076,7 +1086,6 @@ public Builder(AsyncHttpClientConfig prototype) {
             realm = prototype.getRealm();
             defaultRequestTimeoutInMs = prototype.getRequestTimeoutInMs();
             sslContext = prototype.getSSLContext();
-            sslEngineFactory = prototype.getSSLEngineFactory();
             userAgent = prototype.getUserAgent();
             redirectEnabled = prototype.isRedirectEnabled();
             compressionEnabled = prototype.isCompressionEnabled();
@@ -1099,6 +1108,7 @@ public Builder(AsyncHttpClientConfig prototype) {
             hostnameVerifier = prototype.getHostnameVerifier();
             strict302Handling = prototype.isStrict302Handling();
             rfc6265CookieEncoding = prototype.isRfc6265CookieEncoding();
+            acceptAnyCertificate = prototype.acceptAnyCertificate;
         }
@@ -1160,7 +1170,6 @@ public Thread newThread(Runnable r) {
                     applicationThreadPool,
                     proxyServerSelector,
                     sslContext,
-                    sslEngineFactory,
                     providerConfig,
                     connectionsPool,
                     realm,
@@ -1176,7 +1185,8 @@ public Thread newThread(Runnable r) {
                     ioThreadMultiplier,
                     strict302Handling,
                     useRelativeURIsWithSSLProxies,
-                    rfc6265CookieEncoding);
+                    rfc6265CookieEncoding,
+                    acceptAnyCertificate);
         }
     }
 }",1,java,77.0,src/main/java/com/ning/http/client/AsyncHttpClientConfig.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,train,"@@ -17,6 +17,17 @@
 package org.apache.ignite.marshaller;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.internal.ClassSet;
+import org.apache.ignite.lang.IgnitePredicate;
 import org.apache.ignite.lang.IgniteProductVersion;
 import org.apache.ignite.marshaller.jdk.JdkMarshaller;
 import org.jetbrains.annotations.Nullable;
@@ -83,4 +94,110 @@ public class MarshallerUtils {
     public static IgniteProductVersion jobSenderVersion() {
         return JOB_SND_NODE_VER.get();
     }
+
+    /**
+     * Returns class name filter for marshaller.
+     *
+     * @return Class name filter for marshaller.
+     */
+    public static IgnitePredicate<String> classNameFilter(ClassLoader clsLdr) throws IgniteCheckedException {
+        ClassSet whiteList = classWhiteList(clsLdr);
+        ClassSet blackList = classBlackList(clsLdr);
+
+        return new IgnitePredicate<String>() {
+            @Override public boolean apply(String s) {
+                // Allows all primitive arrays and checks arrays' type.
+                if ((blackList != null || whiteList != null) && s.charAt(0) == '[') {
+                    if (s.charAt(1) == 'L' && s.length() > 2)
+                        s = s.substring(2, s.length() - 1);
+                    else
+                        return true;
+                }
+
+                return (blackList == null || !blackList.contains(s)) && (whiteList == null || whiteList.contains(s));
+            }
+        };
+    }
+
+    /**
+     * @param clsLdr Class loader.
+     * @return White list of classes.
+     */
+    private static ClassSet classWhiteList(ClassLoader clsLdr) throws IgniteCheckedException {
+        ClassSet clsSet = null;
+
+        String fileName = IgniteSystemProperties.getString(IgniteSystemProperties.IGNITE_MARSHALLER_WHITELIST);
+
+        if (fileName != null) {
+            clsSet = new ClassSet();
+
+            addClassNames(JDK_CLS_NAMES_FILE, clsSet, clsLdr);
+            addClassNames(CLS_NAMES_FILE, clsSet, clsLdr);
+            addClassNames(fileName, clsSet, clsLdr);
+        }
+
+        return clsSet;
+    }
+
+    /**
+     * @param clsLdr Class loader.
+     * @return Black list of classes.
+     */
+    private static ClassSet classBlackList(ClassLoader clsLdr) throws IgniteCheckedException {
+        ClassSet clsSet = null;
+
+        String blackListFileName = IgniteSystemProperties.getString(IgniteSystemProperties.IGNITE_MARSHALLER_BLACKLIST);
+
+        if (blackListFileName != null)
+            addClassNames(blackListFileName, clsSet = new ClassSet(), clsLdr);
+
+        return clsSet;
+    }
+
+    /**
+     * Reads class names from resource referred by given system property name and returns set of classes.
+     *
+     * @param fileName File name containing list of classes.
+     * @param clsSet Class set for update.
+     * @param clsLdr Class loader.
+     */
+    private static void addClassNames(
+        String fileName,
+        ClassSet clsSet,
+        ClassLoader clsLdr
+    ) throws IgniteCheckedException {
+        InputStream is = clsLdr.getResourceAsStream(fileName);
+
+        if (is == null) {
+            try {
+                is = new FileInputStream(new File(fileName));
+            }
+            catch (FileNotFoundException e) {
+                throw new IgniteCheckedException(""File "" + fileName + "" not found."");
+            }
+        }
+
+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
+            String line;
+
+            for (int i = 1; (line = reader.readLine()) != null; i++) {
+                String s = line.trim();
+
+                if (!s.isEmpty() && s.charAt(0) != '#' && s.charAt(0) != '[') {
+                    try {
+                        clsSet.add(s);
+                    }
+                    catch (IllegalArgumentException e) {
+                        throw new IgniteCheckedException(""Exception occurred while reading list of classes"" +
+                            ""[path="" + fileName + "", row="" + i + "", line="" + s + ']', e);
+                    }
+                }
+            }
+        }
+        catch (IOException e) {
+            throw new IgniteCheckedException(""Exception occurred while reading and creating list of classes "" +
+                ""[path="" + fileName + ']', e);
+        }
+    }
+
 }",1,java,79.0,MarshallerUtils.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -2,6 +2,7 @@ package uk.gov.hmcts.ccd.domain.model.draft;
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import lombok.ToString;
+import uk.gov.hmcts.ccd.domain.model.std.CaseDataContent;
 
 import java.time.LocalDateTime;
 
@@ -62,4 +63,9 @@ public class DraftResponse {
     public String getCaseTypeId() {
         return getDocument() != null ? getDocument().getCaseTypeId() : null;
     }
+
+    @JsonIgnore
+    public CaseDataContent getCaseDataContent() {
+        return getDocument() != null ? getDocument().getCaseDataContent() : null;
+    }
 }
",1,java,6.0,DraftResponse.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -82,7 +82,14 @@ protected PublicKey engineGeneratePublic(
     {
         if (keySpec instanceof DHPublicKeySpec)
         {
-            return new BCDHPublicKey((DHPublicKeySpec)keySpec);
+            try
+            {
+                return new BCDHPublicKey((DHPublicKeySpec)keySpec);
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new InvalidKeySpecException(e.getMessage(), e);
+            }
         }
         return super.engineGeneratePublic(keySpec);",1,java,9.0,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/KeyFactorySpi.java
566a8ddb885f0bef9bc848e60455c0aabbf0c1d3,jenkinsci/jenkins,train,"@@ -48,6 +48,10 @@ import hudson.util.XStream2;
 import java.io.File;
 import java.io.FileFilter;
 import java.io.IOException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.InvalidPathException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -464,6 +468,44 @@ public class User extends AbstractModelObject implements AccessControlled, Descr
                 }
             }
         }
+
+        File unsanitizedLegacyConfigFile = getUnsanitizedLegacyConfigFileFor(id);
+        if (unsanitizedLegacyConfigFile.exists() && !unsanitizedLegacyConfigFile.equals(configFile)) {
+            File ancestor = unsanitizedLegacyConfigFile.getParentFile();
+            if (!configFile.exists()) {
+                try {
+                    Files.createDirectory(configFile.getParentFile().toPath());
+                    Files.move(unsanitizedLegacyConfigFile.toPath(), configFile.toPath());
+                } catch (IOException | InvalidPathException e) {
+                    LOGGER.log(
+                            Level.WARNING,
+                            String.format(""Failed to migrate user record from %s to %s, see SECURITY-499 for more information"", idStrategy().legacyFilenameOf(id), idStrategy().filenameOf(id)),
+                            e);
+                }
+            }
+
+            // Don't clean up ancestors with other children; the directories should be cleaned up when the last child
+            // is migrated
+            File tmp = ancestor;
+            try {
+                while (!ancestor.equals(getRootDir())) {
+                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(ancestor.toPath())) {
+                        if (!stream.iterator().hasNext()) {
+                            tmp = ancestor;
+                            ancestor = tmp.getParentFile();
+                            Files.deleteIfExists(tmp.toPath());
+                        } else {
+                            break;
+                        }
+                    }
+                }
+            } catch (IOException | InvalidPathException e) {
+                if (LOGGER.isLoggable(Level.FINE)) {
+                    LOGGER.log(Level.FINE, ""Could not delete "" + tmp + "" when cleaning up legacy user directories"", e);
+                }
+            }
+        }
+
         if (u==null && (create || configFile.exists())) {
             User tmp = new User(id, fullName);
             User prev;
@@ -704,6 +746,10 @@ public class User extends AbstractModelObject implements AccessControlled, Descr
         });
     }
+    private static File getUnsanitizedLegacyConfigFileFor(String id) {
+        return new File(getRootDir(), idStrategy().legacyFilenameOf(id) + ""/config.xml"");
+    }
+",1,java,41.0,User.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -67,6 +67,7 @@ void configureDefaults() {
         removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
         strict302Handling = defaultStrict302Handling();
         hostnameVerifier = defaultHostnameVerifier();
+        acceptAnyCertificate = defaultAcceptAnyCertificate();
         if (defaultUseProxySelector()) {
             proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
@@ -173,11 +174,6 @@ public AsyncHttpClientConfigBean setSslContext(SSLContext sslContext) {
         return this;
     }
-    public AsyncHttpClientConfigBean setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
-        this.sslEngineFactory = sslEngineFactory;
-        return this;
-    }
-
     public AsyncHttpClientConfigBean setProviderConfig(AsyncHttpProviderConfig<?, ?> providerConfig) {
         this.providerConfig = providerConfig;
         return this;
@@ -242,4 +238,9 @@ public AsyncHttpClientConfigBean setIoThreadMultiplier(int ioThreadMultiplier) {
         this.ioThreadMultiplier = ioThreadMultiplier;
         return this;
     }
+
+    public AsyncHttpClientConfigBean setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+        this.acceptAnyCertificate = acceptAnyCertificate;
+        return this;
+    }
 }",1,java,9.0,src/main/java/com/ning/http/client/AsyncHttpClientConfigBean.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -40,6 +40,10 @@ public abstract class AbstractDefaultGetCaseViewOperation {
         }
     }
 
+    CaseType getCaseType(String caseTypeId) {
+        return caseTypeService.getCaseType(caseTypeId);
+    }
+
     CaseType getCaseType(String jurisdictionId, String caseTypeId) {
         return caseTypeService.getCaseTypeForJurisdiction(caseTypeId, jurisdictionId);
     }
",1,java,4.0,AbstractDefaultGetCaseViewOperation.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -0,0 +1,35 @@
+package uk.gov.hmcts.ccd.v2.internal.resource;
+
+import com.fasterxml.jackson.annotation.JsonUnwrapped;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+import lombok.NonNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.hateoas.ResourceSupport;
+import uk.gov.hmcts.ccd.domain.model.draft.DraftResponse;
+import uk.gov.hmcts.ccd.v2.internal.controller.UIDraftsController;
+
+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;
+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;
+
+@Data
+@EqualsAndHashCode(callSuper = true)
+@NoArgsConstructor
+public class UIDraftResource extends ResourceSupport {
+    private static final Logger LOG = LoggerFactory.getLogger(UIStartTriggerResource.class);
+
+    @JsonUnwrapped
+    private DraftResponse draftResponse;
+
+    public UIDraftResource(@NonNull DraftResponse draftResponse, String caseTypeId) {
+        copyProperties(draftResponse);
+
+        add(linkTo(methodOn(UIDraftsController.class).saveDraft(caseTypeId, draftResponse.getCaseDataContent())).withSelfRel());
+    }
+
+    private void copyProperties(DraftResponse draftResponse) {
+        this.draftResponse = draftResponse;
+    }
+}
",1,java,29.0,UIDraftResource.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -34,18 +34,26 @@
+ *
+ * @deprecated Superseded by {@link CiphertextHeaderV2}
+@Deprecated
 public class CiphertextHeader
 {
+  /** Maximum nonce length in bytes. */
+  protected static final int MAX_NONCE_LEN = 255;
+
+  /** Maximum key name length in bytes. */
+  protected static final int MAX_KEYNAME_LEN = 500;
-  private final byte[] nonce;
+  protected final byte[] nonce;
-  private String keyName;
+  protected final String keyName;
-  private int length;
+  protected final int length;
@@ -67,12 +75,17 @@ public CiphertextHeader(final byte[] nonce)
   public CiphertextHeader(final byte[] nonce, final String keyName)
   {
-    this.nonce = nonce;
-    this.length = 8 + nonce.length;
+    if (nonce.length > 255) {
+      throw new IllegalArgumentException(""Nonce exceeds size limit in bytes (255)"");
+    }
     if (keyName != null) {
-      this.length += 4 + keyName.getBytes().length;
-      this.keyName = keyName;
+      if (ByteUtil.toBytes(keyName).length > MAX_KEYNAME_LEN) {
+        throw new IllegalArgumentException(""Key name exceeds size limit in bytes (500)"");
+      }
     }
+    this.nonce = nonce;
+    this.keyName = keyName;
+    length = computeLength();
   }
@@ -127,6 +140,19 @@ public String getKeyName()
   }
+  /**
+   * @return  Length of this header encoded as bytes.
+   */
+  protected int computeLength()
+  {
+    int len = 8 + nonce.length;
+    if (keyName != null) {
+      len += 4 + keyName.getBytes().length;
+    }
+    return len;
+  }
+
+
@@ -143,17 +169,20 @@ public static CiphertextHeader decode(final byte[] data) throws EncodingExceptio
     final int length = bb.getInt();
     if (length < 0) {
-      throw new EncodingException(""Invalid ciphertext header length: "" + length);
+      throw new EncodingException(""Bad ciphertext header"");
     }
     final byte[] nonce;
     int nonceLen = 0;
     try {
       nonceLen = bb.getInt();
+      if (nonceLen > MAX_NONCE_LEN) {
+        throw new EncodingException(""Bad ciphertext header: maximum nonce length exceeded"");
+      }
       nonce = new byte[nonceLen];
       bb.get(nonce);
     } catch (IndexOutOfBoundsException | BufferUnderflowException e) {
-      throw new EncodingException(""Invalid nonce length: "" + nonceLen);
+      throw new EncodingException(""Bad ciphertext header"");
     }
     String keyName = null;
@@ -162,11 +191,14 @@ public static CiphertextHeader decode(final byte[] data) throws EncodingExceptio
       int keyLen = 0;
       try {
         keyLen = bb.getInt();
+        if (keyLen > MAX_KEYNAME_LEN) {
+          throw new EncodingException(""Bad ciphertext header: maximum key length exceeded"");
+        }
         b = new byte[keyLen];
         bb.get(b);
         keyName = new String(b);
       } catch (IndexOutOfBoundsException | BufferUnderflowException e) {
-        throw new EncodingException(""Invalid key length: "" + keyLen);
+        throw new EncodingException(""Bad ciphertext header"");
       }
     }
@@ -188,17 +220,20 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx
   {
     final int length = ByteUtil.readInt(input);
     if (length < 0) {
-      throw new EncodingException(""Invalid ciphertext header length: "" + length);
+      throw new EncodingException(""Bad ciphertext header"");
     }
     final byte[] nonce;
     int nonceLen = 0;
     try {
       nonceLen = ByteUtil.readInt(input);
+      if (nonceLen > MAX_NONCE_LEN) {
+        throw new EncodingException(""Bad ciphertext header: maximum nonce size exceeded"");
+      }
       nonce = new byte[nonceLen];
       input.read(nonce);
     } catch (ArrayIndexOutOfBoundsException e) {
-      throw new EncodingException(""Invalid nonce length: "" + nonceLen);
+      throw new EncodingException(""Bad ciphertext header"");
     } catch (IOException e) {
       throw new StreamException(e);
     }
@@ -209,10 +244,13 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx
       int keyLen = 0;
       try {
         keyLen = ByteUtil.readInt(input);
+        if (keyLen > MAX_KEYNAME_LEN) {
+          throw new EncodingException(""Bad ciphertext header: maximum key length exceeded"");
+        }
         b = new byte[keyLen];
         input.read(b);
       } catch (ArrayIndexOutOfBoundsException e) {
-        throw new EncodingException(""Invalid key length: "" + keyLen);
+        throw new EncodingException(""Bad ciphertext header"");
       } catch (IOException e) {
         throw new StreamException(e);
       }
@@ -221,4 +259,5 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx
     return new CiphertextHeader(nonce, keyName);
   }
+
 }",1,java,54.0,src/main/java/org/cryptacular/CiphertextHeader.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -24,7 +24,9 @@ import org.apache.wicket.ajax.AjaxRequestTarget;
+ * @deprecated use {@link HandlerPayload} instead
+@Deprecated
 public class AjaxPayload
 {
 	private final AjaxRequestTarget target;",1,java,2.0,AjaxPayload.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,train,"@@ -27,6 +27,7 @@ import javax.cache.configuration.Factory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
 import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.IgniteException;
 import org.apache.ignite.configuration.ConnectorConfiguration;
 import org.apache.ignite.configuration.IgniteConfiguration;
 import org.apache.ignite.internal.GridKernalContext;
@@ -46,6 +47,8 @@ import org.apache.ignite.internal.util.nio.GridNioServer;
 import org.apache.ignite.internal.util.nio.GridNioServerListener;
 import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;
 import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.lang.IgnitePredicate;
+import org.apache.ignite.marshaller.MarshallerUtils;
 import org.apache.ignite.plugin.PluginProvider;
 import org.apache.ignite.spi.IgnitePortProtocol;
 import org.jetbrains.annotations.Nullable;
@@ -149,7 +152,15 @@ public class GridTcpRestProtocol extends GridRestProtocolAdapter {
         marshMap.put(GridClientOptimizedMarshaller.ID, optMarsh);
         marshMap.put(GridClientZipOptimizedMarshaller.ID, new GridClientZipOptimizedMarshaller(optMarsh, providers));
-        marshMap.put(GridClientJdkMarshaller.ID, new GridClientJdkMarshaller());
+
+        try {
+            IgnitePredicate<String> clsFilter = MarshallerUtils.classNameFilter(this.getClass().getClassLoader());
+
+            marshMap.put(GridClientJdkMarshaller.ID, new GridClientJdkMarshaller(clsFilter));
+        }
+        catch (IgniteCheckedException e) {
+            throw new IgniteException(e);
+        }
         lsnr.marshallers(marshMap);
     }",1,java,11.0,GridTcpRestProtocol.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -20,6 +20,7 @@ import com.yahoo.elide.core.filter.expression.FilterExpression;
 import com.yahoo.elide.core.pagination.Pagination;
 import com.yahoo.elide.core.sort.Sorting;
 import com.yahoo.elide.graphql.containers.ConnectionContainer;
+import com.yahoo.elide.graphql.containers.MapEntryContainer;
 
 import com.google.common.collect.Sets;
 
@@ -29,6 +30,7 @@ import graphql.language.Field;
 import graphql.schema.DataFetcher;
 import graphql.schema.DataFetchingEnvironment;
 import graphql.schema.GraphQLType;
+import lombok.Getter;
 import lombok.extern.slf4j.Slf4j;
 
 import java.util.ArrayDeque;
@@ -53,8 +55,12 @@ import javax.ws.rs.core.MultivaluedHashMap;
 public class PersistentResourceFetcher implements DataFetcher<Object> {
     private final ElideSettings settings;
 
-    public PersistentResourceFetcher(ElideSettings settings) {
+    @Getter
+    private final NonEntityDictionary nonEntityDictionary;
+
+    public PersistentResourceFetcher(ElideSettings settings, NonEntityDictionary nonEntityDictionary) {
         this.settings = settings;
+        this.nonEntityDictionary = nonEntityDictionary;
     }
 
     /**
@@ -455,7 +461,14 @@ public class PersistentResourceFetcher implements DataFetcher<Object> {
         /* iterate through each attribute provided */
         for (Entity.Attribute attribute : attributes) {
             if (dictionary.isAttribute(entityClass, attribute.getName())) {
-                toUpdate.updateAttribute(attribute.getName(), attribute.getValue());
+                Class<?> attributeType = dictionary.getType(entityClass, attribute.getName());
+                Object attributeValue;
+                if (Map.class.isAssignableFrom(attributeType)) {
+                    attributeValue = MapEntryContainer.translateFromGraphQLMap(attribute);
+                } else {
+                    attributeValue = attribute.getValue();
+                }
+                toUpdate.updateAttribute(attribute.getName(), attributeValue);
             } else if (!Objects.equals(attribute.getName(), idFieldName)) {
                 throw new IllegalStateException(""Unrecognized attribute passed to 'data': "" + attribute.getName());
             }
",1,java,16.0,PersistentResourceFetcher.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,train,"@@ -15,6 +15,7 @@
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.util.DefaultHostnameVerifier;
 import org.asynchttpclient.util.ProxyUtils;
 import javax.net.ssl.HostnameVerifier;
@@ -70,12 +71,7 @@ void configureDefaults() {
         allowSslConnectionPool = true;
         useRawUrl = false;
         removeQueryParamOnRedirect = true;
-        hostnameVerifier = new HostnameVerifier() {
-
-            public boolean verify(String s, SSLSession sslSession) {
-                return true;
-            }
-        };
+        hostnameVerifier = new DefaultHostnameVerifier();
     }
     void configureExecutors() {",1,java,7.0,api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -155,16 +155,9 @@ public int hashCode()
         for (i = 0; i < mDegree; i++)
         {
-            try
-            {
-                a[i] = new GF2Polynomial(matrix[i]);
-                inv[i] = new GF2Polynomial(mDegree);
-                inv[i].setBit(mDegree - 1 - i);
-            }
-            catch (RuntimeException BDNEExc)
-            {
-                BDNEExc.printStackTrace();
-            }
+            a[i] = new GF2Polynomial(matrix[i]);
+            inv[i] = new GF2Polynomial(mDegree);
+            inv[i].setBit(mDegree - 1 - i);
         }",1,java,13.0,core/src/main/java/org/bouncycastle/pqc/math/linearalgebra/GF2nField.java
f268ab5a00302a89fd0d55cd58d0448402d209a4,jooby-project/jooby,train,"@@ -0,0 +1,47 @@
+package io.jooby;
+
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class Issue1366 {
+
+  @Test
+  public void issue1366() {
+    new JoobyRunner(app -> {
+      app.get(""/"", ctx -> {
+        throw new IllegalArgumentException(ctx.query(""n"").value());
+      });
+    }).ready(client -> {
+      client.get(""/?n=<script>alert</script>"", rsp -> {
+        assertEquals(""<!doctype html>\n""
+            + ""<html>\n""
+            + ""<head>\n""
+            + ""<meta charset=\""utf-8\"">\n""
+            + ""<style>\n""
+            + ""body {font-family: \""open sans\"",sans-serif; margin-left: 20px;}\n""
+            + ""h1 {font-weight: 300; line-height: 44px; margin: 25px 0 0 0;}\n""
+            + ""h2 {font-size: 16px;font-weight: 300; line-height: 44px; margin: 0;}\n""
+            + ""footer {font-weight: 300; line-height: 44px; margin-top: 10px;}\n""
+            + ""hr {background-color: #f7f7f9;}\n""
+            + ""div.trace {border:1px solid #e1e1e8; background-color: #f7f7f9;}\n""
+            + ""p {padding-left: 20px;}\n""
+            + ""p.tab {padding-left: 40px;}\n""
+            + ""</style>\n""
+            + ""<title>Bad Request (400)</title>\n""
+            + ""<body>\n""
+            + ""<h1>Bad Request</h1>\n""
+            + ""<hr>\n""
+            + ""<h2>message: &lt;script&gt;alert&lt;/script&gt;</h2>\n""
+            + ""<h2>status code: 400</h2>\n""
+            + ""</body>\n""
+            + ""</html>"", rsp.body().string());
+      });
+
+      client.header(""Accept"", ""application/json"");
+      client.get(""/?n=\""..\"""", rsp -> {
+        assertEquals(""{\""message\"":\""\\\""..\\\""\"",\""statusCode\"":400,\""reason\"":\""Bad Request\""}"", rsp.body().string());
+      });
+    });
+  }
+}
",1,java,43.0,Issue1366.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -68,21 +68,21 @@ private XMSSMTPrivateKeyParameters(Builder builder)
             byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);
-            BDSStateMap bdsImport = null;
             try
             {
-                bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary);
+                BDSStateMap bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary, BDSStateMap.class);
+
+                bdsImport.setXMSS(builder.xmss);
+                bdsState = bdsImport;
             }
             catch (IOException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
             catch (ClassNotFoundException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
-            bdsImport.setXMSS(builder.xmss);
-            bdsState = bdsImport;
         }
         else
         {
@@ -260,17 +260,14 @@ public XMSSMTPrivateKeyParameters build()
         XMSSUtil.copyBytesAtOffset(out, root, position);
-        byte[] bdsStateOut = null;
         try
         {
-            bdsStateOut = XMSSUtil.serialize(bdsState);
+            return Arrays.concatenate(out, XMSSUtil.serialize(bdsState));
         }
         catch (IOException e)
         {
-            e.printStackTrace();
-            throw new RuntimeException(""error serializing bds state"");
+            throw new IllegalStateException(""error serializing bds state: "" + e.getMessage(), e);
         }
-        return Arrays.concatenate(out, bdsStateOut);
     }
     public long getIndex()",1,java,18.0,XMSSMTPrivateKeyParameters.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,train,"@@ -23,6 +23,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.IgniteException;
 import org.apache.ignite.IgniteLogger;
 import org.apache.ignite.failure.FailureType;
 import org.apache.ignite.internal.client.GridClientException;
@@ -42,6 +44,8 @@ import org.apache.ignite.internal.processors.rest.client.message.GridRouterRespo
 import org.apache.ignite.internal.util.nio.GridNioServerListener;
 import org.apache.ignite.internal.util.nio.GridNioSession;
 import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.lang.IgnitePredicate;
+import org.apache.ignite.marshaller.MarshallerUtils;
 import org.apache.ignite.plugin.PluginProvider;
 import org.jetbrains.annotations.Nullable;
@@ -87,7 +91,15 @@ public abstract class GridTcpRouterNioListenerAdapter implements GridNioServerLi
         marshMap.put(GridClientOptimizedMarshaller.ID, optdMarsh);
         marshMap.put(GridClientZipOptimizedMarshaller.ID, new GridClientZipOptimizedMarshaller(optdMarsh, providers));
-        marshMap.put(GridClientJdkMarshaller.ID, new GridClientJdkMarshaller());
+
+        try {
+            IgnitePredicate<String> clsFilter = MarshallerUtils.classNameFilter(this.getClass().getClassLoader());
+
+            marshMap.put(GridClientJdkMarshaller.ID, new GridClientJdkMarshaller(clsFilter));
+        }
+        catch (IgniteCheckedException e) {
+            throw new IgniteException(e);
+        }
         init();
     }",1,java,12.0,GridTcpRouterNioListenerAdapter.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,train,"@@ -17,14 +17,10 @@
 package org.apache.ignite.internal;
-import java.io.BufferedReader;
 import java.io.Externalizable;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.io.InvalidObjectException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
@@ -196,6 +192,7 @@ import org.apache.ignite.lifecycle.LifecycleAware;
 import org.apache.ignite.lifecycle.LifecycleBean;
 import org.apache.ignite.lifecycle.LifecycleEventType;
 import org.apache.ignite.marshaller.MarshallerExclusions;
+import org.apache.ignite.marshaller.MarshallerUtils;
 import org.apache.ignite.marshaller.jdk.JdkMarshaller;
 import org.apache.ignite.mxbean.ClusterMetricsMXBean;
 import org.apache.ignite.mxbean.IgniteMXBean;
@@ -273,8 +270,6 @@ import static org.apache.ignite.internal.IgniteVersionUtils.VER;
 import static org.apache.ignite.internal.IgniteVersionUtils.VER_STR;
 import static org.apache.ignite.lifecycle.LifecycleEventType.AFTER_NODE_START;
 import static org.apache.ignite.lifecycle.LifecycleEventType.BEFORE_NODE_START;
-import static org.apache.ignite.marshaller.MarshallerUtils.CLS_NAMES_FILE;
-import static org.apache.ignite.marshaller.MarshallerUtils.JDK_CLS_NAMES_FILE;
@@ -888,7 +883,7 @@ public class IgniteKernal implements IgniteEx, IgniteMXBean, Externalizable {
                 schemaExecSvc,
                 customExecSvcs,
                 plugins,
-                classNameFilter()
+                MarshallerUtils.classNameFilter(this.getClass().getClassLoader())
             );
             cfg.getMarshaller().setContext(ctx.marshallerContext());
@@ -1748,105 +1743,6 @@ public class IgniteKernal implements IgniteEx, IgniteMXBean, Externalizable {
         }
     }
-    /**
-     * Returns class name filter for marshaller.
-     *
-     * @return Class name filter for marshaller.
-     */
-    private IgnitePredicate<String> classNameFilter() throws IgniteCheckedException {
-        ClassSet whiteList = classWhiteList();
-        ClassSet blackList = classBlackList();
-
-        return new IgnitePredicate<String>() {
-            @Override public boolean apply(String s) {
-                // Allows all primitive arrays and checks arrays' type.
-                if ((blackList != null || whiteList != null) && s.charAt(0) == '[') {
-                    if (s.charAt(1) == 'L' && s.length() > 2)
-                        s = s.substring(2, s.length() - 1);
-                    else
-                        return true;
-                }
-
-                return (blackList == null || !blackList.contains(s)) && (whiteList == null || whiteList.contains(s));
-            }
-        };
-    }
-
-    /**
-     * @return White list of classes.
-     */
-    private ClassSet classWhiteList() throws IgniteCheckedException {
-        ClassSet clsSet = null;
-
-        String fileName = IgniteSystemProperties.getString(IgniteSystemProperties.IGNITE_MARSHALLER_WHITELIST);
-
-        if (fileName != null) {
-            clsSet = new ClassSet();
-
-            addClassNames(JDK_CLS_NAMES_FILE, clsSet);
-            addClassNames(CLS_NAMES_FILE, clsSet);
-            addClassNames(fileName, clsSet);
-        }
-
-        return clsSet;
-    }
-
-    /**
-     * @return Black list of classes.
-     */
-    private ClassSet classBlackList() throws IgniteCheckedException {
-        ClassSet clsSet = null;
-
-        String blackListFileName = IgniteSystemProperties.getString(IgniteSystemProperties.IGNITE_MARSHALLER_BLACKLIST);
-
-        if (blackListFileName != null)
-            addClassNames(blackListFileName, clsSet = new ClassSet());
-
-        return clsSet;
-    }
-
-    /**
-     * Reads class names from resource referred by given system property name and returns set of classes.
-     *
-     * @param fileName File name containing list of classes.
-     * @param clsSet Class set for update.
-     * @return Set of classes.
-     */
-    private void addClassNames(String fileName, ClassSet clsSet) throws IgniteCheckedException {
-        InputStream is = this.getClass().getClassLoader().getResourceAsStream(fileName);
-
-        if (is == null) {
-            try {
-                is = new FileInputStream(new File(fileName));
-            }
-            catch (FileNotFoundException e) {
-                throw new IgniteCheckedException(""File "" + fileName + "" not found."");
-            }
-        }
-
-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
-            String line;
-
-            for (int i = 1; (line = reader.readLine()) != null; i++) {
-                String s = line.trim();
-
-                if (!s.isEmpty() && s.charAt(0) != '#' && s.charAt(0) != '[') {
-                    try {
-                        clsSet.add(s);
-                    }
-                    catch (IllegalArgumentException e) {
-                        throw new IgniteCheckedException(""Exception occurred while reading list of classes"" +
-                            ""[path="" + fileName + "", row="" + i + "", line="" + s + ']', e);
-                    }
-                }
-            }
-        }
-        catch (IOException e) {
-            throw new IgniteCheckedException(""Exception occurred while reading and creating list of classes "" +
-                ""[path="" + fileName + ']', e);
-        }
-    }
-",1,java,72.0,IgniteKernal.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -5,6 +5,7 @@
 import org.bouncycastle.crypto.DataLengthException;
 import org.bouncycastle.crypto.OutputLengthException;
 import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.util.Arrays;
 import org.bouncycastle.util.Pack;
@@ -415,6 +416,8 @@ private static int subWord(int x)
     private int         C0, C1, C2, C3;
     private boolean     forEncryption;
+    private byte[]      s;
+
     private static final int BLOCK_SIZE = 16;
@@ -440,6 +443,14 @@ public void init(
         {
             WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);
             this.forEncryption = forEncryption;
+            if (forEncryption)
+            {
+                s = Arrays.clone(S);
+            }
+            else
+            {
+                s = Arrays.clone(Si);
+            }
             return;
         }
@@ -578,10 +589,10 @@ private void encryptBlock(int[][] KW)
-        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0];
-        this.C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1];
-        this.C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];
-        this.C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];
+        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[r][0];
+        this.C1 = (s[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[r][1];
+        this.C2 = (s[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];
+        this.C3 = (s[r3&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];
     }
     private void decryptBlock(int[][] KW)
@@ -610,9 +621,9 @@ private void decryptBlock(int[][] KW)
-        this.C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
-        this.C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1];
-        this.C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2];
-        this.C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3];
+        this.C0 = (Si[r0&255]&255) ^ ((s[(r3>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
+        this.C1 = (s[r1&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (s[(r2>>24)&255]<<24) ^ KW[0][1];
+        this.C2 = (s[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[0][2];
+        this.C3 = (Si[r3&255]&255) ^ ((s[(r2>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[0][3];
     }
 }",1,java,26.0,AESEngine.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -37,15 +37,9 @@ import java.util.Map;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
 
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.ConstraintType;
@@ -76,6 +70,7 @@ import net.sf.mpxj.common.NumberHelper;
 import net.sf.mpxj.common.Pair;
 import net.sf.mpxj.common.ResourceFieldLists;
 import net.sf.mpxj.common.TaskFieldLists;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.ganttproject.schema.Allocation;
 import net.sf.mpxj.ganttproject.schema.Allocations;
 import net.sf.mpxj.ganttproject.schema.Calendars;
@@ -118,6 +113,11 @@ public final class GanttProjectReader extends AbstractProjectReader
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_resourcePropertyDefinitions = new HashMap<>();
@@ -137,19 +137,7 @@ public final class GanttProjectReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project ganttProject = (Project) unmarshaller.unmarshal(doc);
+         Project ganttProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, stream);
 
          readProjectProperties(ganttProject);
          readCalendars(ganttProject);
",1,java,22.0,GanttProjectReader.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -15,101 +15,43 @@
 package com.ning.http.util;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
+import com.ning.http.client.AsyncHttpClientConfig;
+
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
-import java.io.FileInputStream;
+
 import java.io.IOException;
-import java.io.InputStream;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
 import java.security.SecureRandom;
-import java.security.Security;
-/**
- * This class is a copy of http://github.com/sonatype/wagon-ning/raw/master/src/main/java/org/apache/maven/wagon/providers/http/SslUtils.java
- */
 public class SslUtils {
-    private static SSLContext context = null;
-
-    public static SSLEngine getSSLEngine()
-            throws GeneralSecurityException, IOException {
-        SSLEngine engine = null;
-
-        SSLContext context = getSSLContext();
-        if (context != null) {
-            engine = context.createSSLEngine();
-            engine.setUseClientMode(true);
-        }
-
-        return engine;
+    private static class SingletonHolder {
+        public static final SslUtils instance = new SslUtils();
     }
-    public static SSLContext getSSLContext()
-            throws GeneralSecurityException, IOException {
-        if (context == null) {
-            SSLConfig config = new SSLConfig();
-            if (config.keyStoreLocation == null
-                    || config.trustStoreLocation == null) {
-                context = getLooseSSLContext();
-            } else {
-                context = getStrictSSLContext(config);
-            }
-        }
-        return context;
+    public static SslUtils getInstance() {
+        return SingletonHolder.instance;
     }
-    static SSLContext getStrictSSLContext(SSLConfig config)
-            throws GeneralSecurityException, IOException {
-        KeyStore keyStore = KeyStore.getInstance(config.keyStoreType);
-        InputStream keystoreInputStream = new FileInputStream(config.keyStoreLocation);
-        try {
-            keyStore.load(keystoreInputStream, (config.keyStorePassword == null) ? null
-                    : config.keyStorePassword.toCharArray());
-        } finally {
-            keystoreInputStream.close();
+    public SSLEngine createClientSSLEngine(AsyncHttpClientConfig config) throws GeneralSecurityException, IOException {
+        SSLContext sslContext = config.getSSLContext();
+        if (sslContext == null) {
+            sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
         }
-
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(config.keyManagerAlgorithm);
-        keyManagerFactory.init(keyStore, (config.keyManagerPassword == null) ? null
-                : config.keyManagerPassword.toCharArray());
-        KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();
-
-        KeyStore trustStore = KeyStore.getInstance(config.trustStoreType);
-        InputStream truststoreInputStream = new FileInputStream(config.trustStoreLocation);
-        try {
-            trustStore.load(truststoreInputStream, (config.trustStorePassword == null) ? null
-                    : config.trustStorePassword.toCharArray());
-        } finally {
-            truststoreInputStream.close();
-        }
-
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(config.trustManagerAlgorithm);
-        trustManagerFactory.init(trustStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        SSLContext context = SSLContext.getInstance(""TLS"");
-        context.init(keyManagers, trustManagers, null);
-
-        return context;
+        SSLEngine sslEngine = sslContext.createSSLEngine();
+        sslEngine.setUseClientMode(true);
+        return sslEngine;
     }
-
-    static SSLContext getLooseSSLContext()
-            throws GeneralSecurityException {
-        SSLContext sslContext = SSLContext.getInstance(""TLS"");
-        sslContext.init(null, new TrustManager[]{LooseTrustManager.INSTANCE}, new SecureRandom());
-        return sslContext;
+    
+    public SSLContext getSSLContext(boolean acceptAnyCertificate) throws GeneralSecurityException, IOException {
+        // SSLContext.getDefault() doesn't exist in JDK5
+        return acceptAnyCertificate ? looseTrustManagerSSLContext : SSLContext.getInstance(""Default"");
     }
-    static class LooseTrustManager
-            implements X509TrustManager {
-
-        public static final LooseTrustManager INSTANCE = new LooseTrustManager();
+    static class LooseTrustManager implements X509TrustManager {
         public java.security.cert.X509Certificate[] getAcceptedIssuers() {
             return new java.security.cert.X509Certificate[0];
@@ -122,53 +64,15 @@ public void checkServerTrusted(java.security.cert.X509Certificate[] certs, Strin
         }
     }
-    private final static class SSLConfig {
-
-        public String keyStoreLocation;
-
-        public String keyStoreType = ""JKS"";
-
-        public String keyStorePassword = ""changeit"";
-
-        public String keyManagerAlgorithm = ""SunX509"";
-
-        public String keyManagerPassword = ""changeit"";
-
-        public String trustStoreLocation;
-
-        public String trustStoreType = ""JKS"";
+    private SSLContext looseTrustManagerSSLContext = looseTrustManagerSSLContext();
-        public String trustStorePassword = ""changeit"";
-
-        public String trustManagerAlgorithm = ""SunX509"";
-
-        public SSLConfig() {
-            keyStoreLocation = System.getProperty(""javax.net.ssl.keyStore"");
-            keyStorePassword = System.getProperty(""javax.net.ssl.keyStorePassword"", ""changeit"");
-            keyStoreType = System.getProperty(""javax.net.ssl.keyStoreType"", KeyStore.getDefaultType());
-            keyManagerAlgorithm = Security.getProperty(""ssl.KeyManagerFactory.algorithm"");
-
-            if (keyManagerAlgorithm == null) {
-                keyManagerAlgorithm = ""SunX509"";
-            }
-
-            keyManagerPassword = System.getProperty(""javax.net.ssl.keyStorePassword"", ""changeit"");
-
-            trustStoreLocation = System.getProperty(""javax.net.ssl.trustStore"");
-            if (trustStoreLocation == null) {
-                trustStoreLocation = keyStoreLocation;
-                trustStorePassword = keyStorePassword;
-                trustStoreType = keyStoreType;
-            } else {
-                trustStorePassword = System.getProperty(""javax.net.ssl.trustStorePassword"", ""changeit"");
-                trustStoreType = System.getProperty(""javax.net.ssl.trustStoreType"", KeyStore.getDefaultType());
-            }
-            trustManagerAlgorithm = Security.getProperty(""ssl.TrustManagerFactory.algorithm"");
-
-            if (trustManagerAlgorithm == null) {
-                trustManagerAlgorithm = ""SunX509"";
-            }
+    private SSLContext looseTrustManagerSSLContext() {
+        try {
+            SSLContext sslContext = SSLContext.getInstance(""TLS"");
+            sslContext.init(null, new TrustManager[] { new LooseTrustManager() }, new SecureRandom());
+            return sslContext;
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
         }
     }
-
 }",1,java,119.0,src/main/java/com/ning/http/util/SslUtils.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -10,6 +10,7 @@
 import org.postgresql.jdbc.FieldMetadata;
 import org.postgresql.jdbc.TimestampUtils;
 import org.postgresql.util.LruCache;
+import org.postgresql.xml.PGXmlFactoryFactory;
 import java.sql.Connection;
 import java.sql.ResultSet;
@@ -212,4 +213,12 @@ CachedQuery createQuery(String sql, boolean escapeProcessing, boolean isParamete
   boolean hintReadOnly();
+
+  /**
+   * Retrieve the factory to instantiate XML processing factories.
+   *
+   * @return The factory to use to instantiate XML processing factories
+   * @throws SQLException if the class cannot be found or instantiated.
+   */
+  PGXmlFactoryFactory getXmlFactoryFactory() throws SQLException;
 }",1,java,3.0,pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -540,11 +540,6 @@ public Builder setExecutorService(ExecutorService applicationThreadPool) {
             return this;
         }
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            configBuilder.setSSLEngineFactory(sslEngineFactory);
-            return this;
-        }
-
         public Builder setSSLContext(final SSLContext sslContext) {
             configBuilder.setSSLContext(sslContext);
             return this;
@@ -670,6 +665,11 @@ public Builder setProviderClass(String providerClass) {
             return this;
         }
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            configBuilder.setAcceptAnyCertificates(acceptAnyCertificate);
+            return this;
+        }
+
         public SimpleAsyncHttpClient build() {
             if (realmBuilder != null) {",1,java,8.0,src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -16,10 +16,12 @@
 import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
 import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
 import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
-import org.bouncycastle.asn1.x9.DHDomainParameters;
 import org.bouncycastle.asn1.x9.DomainParameters;
+import org.bouncycastle.asn1.x9.ValidationParams;
 import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+import org.bouncycastle.crypto.params.DHParameters;
 import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHValidationParameters;
 import org.bouncycastle.jcajce.provider.asymmetric.util.KeyUtil;
 public class BCDHPublicKey
@@ -29,6 +31,7 @@
     private BigInteger              y;
+    private transient DHPublicKeyParameters   dhPublicKey;
     private transient DHParameterSpec         dhSpec;
     private transient SubjectPublicKeyInfo    info;
@@ -37,6 +40,7 @@
     {
         this.y = spec.getY();
         this.dhSpec = new DHParameterSpec(spec.getP(), spec.getG());
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(spec.getP(), spec.getG()));
     }
     BCDHPublicKey(
@@ -44,6 +48,7 @@
     {
         this.y = key.getY();
         this.dhSpec = key.getParams();
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
     }
     BCDHPublicKey(
@@ -51,6 +56,7 @@
     {
         this.y = params.getY();
         this.dhSpec = new DHParameterSpec(params.getParameters().getP(), params.getParameters().getG(), params.getParameters().getL());
+        this.dhPublicKey = params;
     }
     BCDHPublicKey(
@@ -59,6 +65,7 @@
     {
         this.y = y;
         this.dhSpec = dhSpec;
+        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
     }
     public BCDHPublicKey(
@@ -94,12 +101,23 @@ public BCDHPublicKey(
             {
                 this.dhSpec = new DHParameterSpec(params.getP(), params.getG());
             }
+            this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));
         }
         else if (id.equals(X9ObjectIdentifiers.dhpublicnumber))
         {
             DomainParameters params = DomainParameters.getInstance(seq);
             this.dhSpec = new DHParameterSpec(params.getP(), params.getG());
+            ValidationParams validationParams = params.getValidationParams();
+            if (validationParams != null)
+            {
+                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(),
+                                            new DHValidationParameters(validationParams.getSeed(), validationParams.getPgenCounter().intValue())));
+            }
+            else
+            {
+                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(), null));
+            }
         }
         else
         {
@@ -137,6 +155,11 @@ public BigInteger getY()
         return y;
     }
+    public DHPublicKeyParameters engineGetKeyParameters()
+    {
+        return dhPublicKey;
+    }
+
     private boolean isPKCSParam(ASN1Sequence seq)
     {
         if (seq.size() == 2)",1,java,24.0,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/BCDHPublicKey.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -350,7 +350,7 @@ public void onTimeout(Connection connection) {
         boolean defaultSecState = (context != null);
         if (context == null) {
             try {
-                context = SslUtils.getSSLContext();
+                context = SslUtils.getInstance().getSSLContext(clientConfig.isAcceptAnyCertificate());
             } catch (Exception e) {
                 throw new IllegalStateException(e);
             }",1,java,2.0,src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -32,6 +32,8 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import javax.persistence.Entity;
@@ -73,6 +75,9 @@ public class Book {
     private Set<PublicationFormat> publicationFormats = new HashSet<>();
     private Set<Preview> previews = new HashSet<>();
     private BigDecimal weightLbs;
+    private Price price;
+    private List<Price> priceHistory;
+    private Map<Date, Price> priceRevisions;
 
     @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
     public long getId() {
@@ -99,6 +104,31 @@ public class Book {
         this.genre = genre;
     }
 
+    public Price getPrice() {
+        return price;
+    }
+
+    public void setPriceHistory(List<Price> priceHistory) {
+        this.priceHistory = priceHistory;
+    }
+
+    public List<Price> getPriceHistory() {
+        return priceHistory;
+    }
+
+    public void setPriceRevisions(Map<Date, Price> priceRevisions) {
+        this.priceRevisions = priceRevisions;
+    }
+
+    public Map<Date, Price> getPriceRevisions() {
+        return priceRevisions;
+    }
+
+    public void setPrice(Price price) {
+        this.price = price;
+    }
+
+
     public String getLanguage() {
         return language;
     }
",1,java,24.0,Book.java
0a78612f981c541ad2d997e6a365f2a0b3e799d9,cloudfoundry/uaa,train,"@@ -0,0 +1,72 @@
+package org.cloudfoundry.identity.uaa.security;
+
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.SecureRandom;
+
+public class LdapSocketFactory  extends SSLSocketFactory {
+
+  private static SocketFactory instance;
+  private SSLSocketFactory delegate;
+
+  public static SocketFactory getDefault() {
+    if(instance == null) {
+      instance = new LdapSocketFactory();
+    }
+
+    return instance;
+  }
+
+  public LdapSocketFactory() {
+    try {
+      X509TrustManager trustManager = new X509ExpiryCheckingTrustManager();
+      TrustManager[] tma = new TrustManager[]{trustManager};
+      SSLContext sc = SSLContext.getInstance(""TLS"");
+      sc.init(null, tma, new SecureRandom());
+      this.delegate = sc.getSocketFactory();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  @Override
+  public String[] getDefaultCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  @Override
+  public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override
+  public Socket createSocket(Socket socket, String s, int i, boolean b) throws IOException {
+    return delegate.createSocket(socket, s, i, b);
+  }
+
+  @Override
+  public Socket createSocket(String s, int i) throws IOException{
+    return delegate.createSocket(s, i);
+  }
+
+  @Override
+  public Socket createSocket(String s, int i, InetAddress inetAddress, int i1) throws IOException {
+    return delegate.createSocket(s, i, inetAddress, i1);
+  }
+
+  @Override
+  public Socket createSocket(InetAddress inetAddress, int i) throws IOException {
+    return delegate.createSocket(inetAddress, i);
+  }
+
+  @Override
+  public Socket createSocket(InetAddress inetAddress, int i, InetAddress inetAddress1, int i1) throws IOException {
+    return delegate.createSocket(inetAddress, i, inetAddress1, i1);
+  }
+}",1,java,60.0,LdapSocketFactory.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -572,6 +572,11 @@ public class AuthenticationManager {
         return uri.getRawPath();
     }
+    public static String getAccountCookiePath(RealmModel realm, UriInfo uriInfo) {
+        URI uri = RealmsResource.accountUrl(uriInfo.getBaseUriBuilder()).build(realm.getName());
+        return uri.getRawPath();
+    }
+
     public static void expireCookie(RealmModel realm, String cookieName, String path, boolean httpOnly, ClientConnection connection) {
         logger.debugv(""Expiring cookie: {0} path: {1}"", cookieName, path);
         boolean secureOnly = realm.getSslRequired().isRequired(connection);;",1,java,5.0,AuthenticationManager.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -37,15 +37,9 @@ import java.util.UUID;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
 
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.Day;
@@ -68,6 +62,7 @@ import net.sf.mpxj.common.AlphanumComparator;
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.DebugLogPrintWriter;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.phoenix.schema.Project;
 import net.sf.mpxj.phoenix.schema.Project.Layouts.Layout;
@@ -112,6 +107,11 @@ public final class PhoenixReader extends AbstractProjectReader
 
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_activityMap = new HashMap<>();
          m_activityCodeValues = new HashMap<>();
@@ -134,19 +134,7 @@ public final class PhoenixReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(new SkipNulInputStream(stream)));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project phoenixProject = (Project) unmarshaller.unmarshal(doc);
+         Project phoenixProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, new SkipNulInputStream(stream));
          Storepoint storepoint = getCurrentStorepoint(phoenixProject);
          readProjectProperties(phoenixProject.getSettings(), storepoint);
          readCalendars(storepoint);
",1,java,22.0,PhoenixReader.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -12,11 +12,13 @@ import com.yahoo.elide.core.PersistentResource;
 import com.yahoo.elide.core.exceptions.BadRequestException;
 import com.yahoo.elide.graphql.DeferredId;
 import com.yahoo.elide.graphql.Environment;
+import com.yahoo.elide.graphql.NonEntityDictionary;
 import com.yahoo.elide.graphql.PersistentResourceFetcher;
 
 import lombok.AllArgsConstructor;
 import lombok.Getter;
 
+import java.util.Collection;
 import java.util.Map;
 import java.util.Objects;
 import java.util.stream.Collectors;
@@ -30,21 +32,39 @@ public class NodeContainer implements PersistentResourceContainer, GraphQLContai
 
     @Override
     public Object processFetch(Environment context, PersistentResourceFetcher fetcher) {
-        EntityDictionary dictionary = context.requestScope.getDictionary();
+        EntityDictionary entityDictionary = context.requestScope.getDictionary();
+        NonEntityDictionary nonEntityDictionary = fetcher.getNonEntityDictionary();
+
         Class parentClass = context.parentResource.getResourceClass();
         String fieldName = context.field.getName();
-        String idFieldName = dictionary.getIdFieldName(parentClass);
+        String idFieldName = entityDictionary.getIdFieldName(parentClass);
 
-        if (dictionary.isAttribute(parentClass, fieldName)) { /* fetch attribute properties */
+        if (entityDictionary.isAttribute(parentClass, fieldName)) { /* fetch attribute properties */
             Object attribute = context.parentResource.getAttribute(fieldName);
+
+            if (attribute != null && nonEntityDictionary.hasBinding(attribute.getClass())) {
+                return new NonEntityContainer(attribute);
+            }
+
             if (attribute instanceof Map) {
                 return ((Map<Object, Object>) attribute).entrySet().stream()
                         .map(MapEntryContainer::new)
                         .collect(Collectors.toList());
             }
+
+            if (attribute instanceof Collection) {
+                Class<?> innerType = entityDictionary.getParameterizedType(parentClass, fieldName);
+
+                if (nonEntityDictionary.hasBinding(innerType)) {
+                    return ((Collection) attribute).stream()
+                            .map(NonEntityContainer::new)
+                            .collect(Collectors.toList());
+                }
+            }
+
             return attribute;
         }
-        if (dictionary.isRelation(parentClass, fieldName)) { /* fetch relationship properties */
+        if (entityDictionary.isRelation(parentClass, fieldName)) { /* fetch relationship properties */
             boolean generateTotals = requestContainsPageInfo(context.field);
             return fetcher.fetchRelationship(context, context.parentResource,
                     fieldName, context.ids, context.offset, context.first, context.sort, context.filters,
",1,java,22.0,NodeContainer.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,kiegroup/jbpm-designer,train,"@@ -1,23 +1,27 @@
 package org.jbpm.designer.filter;
 
-import org.apache.commons.httpclient.HttpClient;
-
-import javax.servlet.*;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.Iterator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 public class DesignerInjectionFilter implements Filter {
+
     private FilterConfig fc = null;
     private ServletContext sc = null;
     private InjectionConfig cf;
     private InjectionRules rules;
-    public static HttpClient client;
 
     public void init(FilterConfig filterConfig) throws ServletException {
         fc = filterConfig;
",1,java,15.0,DesignerInjectionFilter.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -20,7 +20,7 @@
 import org.bouncycastle.crypto.DataLengthException;
 import org.bouncycastle.crypto.InvalidCipherTextException;
 import org.bouncycastle.crypto.Mac;
-import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.AESEngine;
 import org.bouncycastle.crypto.engines.AESWrapEngine;
 import org.bouncycastle.crypto.engines.RFC3211WrapEngine;
 import org.bouncycastle.crypto.engines.RFC5649WrapEngine;
@@ -61,7 +61,7 @@ public ECB()
             {
                 public BlockCipher get()
                 {
-                    return new AESFastEngine();
+                    return new AESEngine();
                 }
             });
         }
@@ -72,7 +72,7 @@ public BlockCipher get()
     {
         public CBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), 128);
+            super(new CBCBlockCipher(new AESEngine()), 128);
         }
     }
@@ -81,7 +81,7 @@ public CBC()
     {
         public CFB()
         {
-            super(new BufferedBlockCipher(new CFBBlockCipher(new AESFastEngine(), 128)), 128);
+            super(new BufferedBlockCipher(new CFBBlockCipher(new AESEngine(), 128)), 128);
         }
     }
@@ -90,7 +90,7 @@ public CFB()
     {
         public OFB()
         {
-            super(new BufferedBlockCipher(new OFBBlockCipher(new AESFastEngine(), 128)), 128);
+            super(new BufferedBlockCipher(new OFBBlockCipher(new AESEngine(), 128)), 128);
         }
     }
@@ -99,7 +99,7 @@ public OFB()
     {
         public GCM()
         {
-            super(new GCMBlockCipher(new AESFastEngine()));
+            super(new GCMBlockCipher(new AESEngine()));
         }
     }
@@ -108,7 +108,7 @@ public GCM()
     {
         public CCM()
         {
-            super(new CCMBlockCipher(new AESFastEngine()), false, 16);
+            super(new CCMBlockCipher(new AESEngine()), false, 16);
         }
     }
@@ -117,7 +117,7 @@ public CCM()
     {
         public AESCMAC()
         {
-            super(new CMac(new AESFastEngine()));
+            super(new CMac(new AESEngine()));
         }
     }
@@ -126,7 +126,7 @@ public AESCMAC()
     {
         public AESGMAC()
         {
-            super(new GMac(new GCMBlockCipher(new AESFastEngine())));
+            super(new GMac(new GCMBlockCipher(new AESEngine())));
         }
     }
@@ -141,7 +141,7 @@ public AESCCMMAC()
         private static class CCMMac
             implements Mac
         {
-            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESFastEngine());
+            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESEngine());
             private int macLength = 8;
@@ -200,7 +200,7 @@ public void reset()
     {
         public Poly1305()
         {
-            super(new org.bouncycastle.crypto.macs.Poly1305(new AESFastEngine()));
+            super(new org.bouncycastle.crypto.macs.Poly1305(new AESEngine()));
         }
     }
@@ -227,7 +227,7 @@ public Wrap()
     {
         public RFC3211Wrap()
         {
-            super(new RFC3211WrapEngine(new AESFastEngine()), 16);
+            super(new RFC3211WrapEngine(new AESEngine()), 16);
         }
     }
@@ -236,7 +236,7 @@ public RFC3211Wrap()
     {
         public RFC5649Wrap()
         {
-            super(new RFC5649WrapEngine(new AESFastEngine()));
+            super(new RFC5649WrapEngine(new AESEngine()));
         }
     }
@@ -248,7 +248,7 @@ public RFC5649Wrap()
     {
         public PBEWithAESCBC()
         {
-            super(new CBCBlockCipher(new AESFastEngine()));
+            super(new CBCBlockCipher(new AESEngine()));
         }
     }
@@ -260,7 +260,7 @@ public PBEWithAESCBC()
     {
         public PBEWithSHA1AESCBC128()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 128, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 128, 16);
         }
     }
@@ -269,7 +269,7 @@ public PBEWithSHA1AESCBC128()
     {
         public PBEWithSHA1AESCBC192()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 192, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 192, 16);
         }
     }
@@ -278,7 +278,7 @@ public PBEWithSHA1AESCBC192()
     {
         public PBEWithSHA1AESCBC256()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 256, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 256, 16);
         }
     }
@@ -290,7 +290,7 @@ public PBEWithSHA1AESCBC256()
     {
         public PBEWithSHA256AESCBC128()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 128, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 128, 16);
         }
     }
@@ -299,7 +299,7 @@ public PBEWithSHA256AESCBC128()
     {
         public PBEWithSHA256AESCBC192()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 192, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 192, 16);
         }
     }
@@ -308,7 +308,7 @@ public PBEWithSHA256AESCBC192()
     {
         public PBEWithSHA256AESCBC256()
         {
-            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 256, 16);
+            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 256, 16);
         }
     }",1,java,40.0,prov/src/main/java/org/bouncycastle/jcajce/provider/symmetric/AES.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,kiegroup/jbpm-designer,train,"@@ -34,12 +34,11 @@ package org.jbpm.designer.server;
  **/
 
 import java.io.ByteArrayInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.URL;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.ListIterator;
 
@@ -47,7 +46,6 @@ import javax.servlet.ServletContext;
 import javax.servlet.http.HttpServletRequest;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.Source;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerException;
@@ -55,16 +53,25 @@ import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpException;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
 
 public class Repository {
 
+    private static final Logger logger = LoggerFactory.getLogger(Repository.class);
+    
 	public static final String NEW_MODEL_SVG_STRING = ""<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:oryx=\""http://oryx-editor.org\"" id=\""oryx_98F1C176-75F8-4C0A-899E-0F5E352A5F58\"" width=\""10\"" height=\""10\"" xlink=\""http://www.w3.org/1999/xlink\"" svg=\""http://www.w3.org/2000/svg\""><defs/><g stroke=\""none\"" font-family=\""Verdana\"" font-size=\""12\""><g class=\""stencils\"" transform=\""translate(0)\""><g class=\""me\""/><g class=\""children\""/><g class=\""edge\""/></g></g></svg>"";
 	public static final String DEFAULT_STENCILSET = ""/stencilsets/bpmn1.1/bpmn1.1.json"";
 	public static final String DEFAULT_TYPE = ""http://b3mn.org/stencilset/bpmn1.1#"";
@@ -127,17 +134,21 @@ public class Repository {
 
 	public String getModel(String path, String representationType) {
 		String result = """";
+		
+		String urlString = baseUrl + path + ""/"" + representationType;
 		try {
-		    HttpClient client = new HttpClient();
-		    GetMethod method = new GetMethod( baseUrl + path + ""/"" + representationType);
-		    int statusCode = client.executeMethod( method );
-			if( statusCode != -1 ) {
-				result = method.getResponseBodyAsString();
+		    HttpClient client = HttpClientBuilder.create().build();
+		    HttpGet get = new HttpGet( urlString);
+		    HttpResponse response = client.execute( get );
+		    int statusCode = response.getStatusLine().getStatusCode();
+			if( statusCode != -1 ) { 
+			    HttpEntity entity = response.getEntity();
+				result = EntityUtils.toString(entity);
 			} else {
-				 // TODO handle error
+				 logger.error(""GET to '{}' failed with status {}"", urlString, statusCode );
 			}
 		} catch( Exception e ) {
-			// TODO handle exception
+		    logger.error(""GET to '{}' failed:"" + e.getMessage(), e );
 		}
 		return result;
 	}
@@ -332,34 +343,56 @@ public class Repository {
 	}
 
 	public String saveNewModel(String newModel, String name, String summary, String type, String stencilset, String svg){
-		String result = """";
-		String url = baseUrl + ""backend/poem/repository/new?stencilset="" + stencilset;
-		try {
-		    HttpClient client = new HttpClient();
-		    PostMethod method = new PostMethod(url);
-			// configure the form parameters
-			method.addParameter(""data"", newModel);
-			method.addParameter(""title"", name);
-			method.addParameter(""summary"", summary);
-			method.addParameter(""type"", type);
-			method.addParameter(""svg"", svg);
-			// execute the POST method
-			int statusCode = client.executeMethod(method);
-			if(statusCode != -1) {
-				Header header = method.getResponseHeader(""location"");
-				result = header.getValue();
-				// hack for reverse proxies:
-				result = result.substring(result.lastIndexOf(""http://""));
+	    String result = """";
+
+	    // setup 
+	    String url = baseUrl + ""backend/poem/repository/new?stencilset="" + stencilset;
+	    HttpClient client = HttpClientBuilder.create().build();
 
-				if (result.startsWith(baseUrl)){
-					result = result.substring(baseUrl.length());
+	    // configure the form parameters
+	    List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+	    formParams.add(new BasicNameValuePair(""data"", newModel));
+	    formParams.add(new BasicNameValuePair(""title"", name));
+	    formParams.add(new BasicNameValuePair(""summary"", summary));
+	    formParams.add(new BasicNameValuePair(""type"", type));
+	    formParams.add(new BasicNameValuePair(""svg"", svg));
+	    UrlEncodedFormEntity formEntity;
+
+	    try {
+	        formEntity = new UrlEncodedFormEntity(formParams);
+	    } catch( UnsupportedEncodingException uee ) {
+	        logger.error(""Could not encode authentication parameters into request body"", uee);
+	        return result;
+	    }
+
+	    // create POST method and add form 
+	    HttpPost post = new HttpPost( url);
+	    post.setEntity(formEntity);
+	    
+	    try {
+	        // execute the POST method
+	        HttpResponse response = client.execute( post );
+            int statusCode = response.getStatusLine().getStatusCode();
+            if( statusCode != -1 ) { 
+                Header [] headers = response.getHeaders(""location"");
+				if( headers.length > 0 ) { 
+				    result = headers[0].getValue();
+				    // hack for reverse proxies:
+				    result = result.substring(result.lastIndexOf(""http://""));
+				    if (result.startsWith(baseUrl)){
+				        result = result.substring(baseUrl.length());
+				    }
+				} else {
+				    logger.error(""GET to '{}' failed with status {}"", url, statusCode );
 				}
-			} else {
-				// TODO handle error
-			}
-		} catch( Exception e ) {
-			e.printStackTrace();
-		}
+            } 
+            else { 
+               logger.error( ""POST to [{}] resulted in status code {} "", url, statusCode);
+            }
+		} catch( Exception e ) { 
+		    logger.error(""POST to ["" + url + ""] failed: "" + e.getMessage(), e );
+		} 
+			
 		return result;
 	}
 	
@@ -390,27 +423,33 @@ public class Repository {
 		}
 		String modelTagsUrl = modelUrl + ""/tags"";
 
-		HttpClient client = new HttpClient();
-	    PostMethod method = new PostMethod(modelTagsUrl);
+		HttpClient client = HttpClientBuilder.create().build();
+		HttpPost post = new HttpPost(modelTagsUrl);
 	    
 		// configure the form parameters
-		method.addParameter(""tag_name"", tagName);
+        List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+        formParams.add(new BasicNameValuePair(""tag_name"", tagName));
+        UrlEncodedFormEntity formEntity;
+
+        try {
+            formEntity = new UrlEncodedFormEntity(formParams);
+        } catch( UnsupportedEncodingException uee ) {
+            logger.error(""Could not encode authentication parameters into request body"", uee);
+            return;
+        }
 
 		// execute the POST method
 		int statusCode;
 		try {
-			statusCode = client.executeMethod(method);
+			HttpResponse response = client.execute(post);
+			statusCode = response.getStatusLine().getStatusCode();
 			if (statusCode != -1) {
-				// TODO return result
+				// TODO return result 
 			} else {
-				// TODO handle error
+			    logger.error( ""POST to ["" + modelTagsUrl + ""] failed with status code "" + statusCode );
 			}
-		} catch (HttpException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+		} catch (Exception e) {
+			logger.error( ""POST to ["" + modelTagsUrl + ""] failed: "" + e.getMessage(), e );
 		}
 	}
 	
",1,java,123.0,Repository.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -132,6 +132,9 @@ import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.escape.Escaper;
+import com.google.common.html.HtmlEscapers;
+import com.google.common.net.UrlEscapers;
 import com.google.inject.Binder;
 import com.google.inject.Guice;
 import com.google.inject.Injector;
@@ -4060,6 +4063,9 @@ public class Jooby implements Routes, LifeCycle, Registry {
       throw new IllegalStateException(""Required property 'application.secret' is missing"");
     }
 
+    /** Some basic xss functions. */
+    xss(finalEnv);
+
     /** dependency injection */
     @SuppressWarnings(""unchecked"")
     Injector injector = Guice.createInjector(stage, binder -> {
@@ -4223,6 +4229,18 @@ public class Jooby implements Routes, LifeCycle, Registry {
     return injector;
   }
 
+  private void xss(final Env env) {
+    Escaper ufe = UrlEscapers.urlFragmentEscaper();
+    Escaper fpe = UrlEscapers.urlFormParameterEscaper();
+    Escaper pse = UrlEscapers.urlPathSegmentEscaper();
+    Escaper html = HtmlEscapers.htmlEscaper();
+
+    env.xss(""urlFragment"", ufe::escape)
+        .xss(""formParam"", fpe::escape)
+        .xss(""pathSegment"", pse::escape)
+        .xss(""html"", html::escape);
+  }
+
   private static Provider<Session.Definition> session(final Config $session,
       final Session.Definition session) {
     return () -> {
",1,java,15.0,Jooby.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -6,9 +6,13 @@
 package com.yahoo.elide.graphql.containers;
 
 import com.yahoo.elide.core.exceptions.BadRequestException;
+import com.yahoo.elide.graphql.Entity;
 import com.yahoo.elide.graphql.Environment;
+import com.yahoo.elide.graphql.NonEntityDictionary;
 import com.yahoo.elide.graphql.PersistentResourceFetcher;
 
+import java.util.Collection;
+import java.util.HashMap;
 import java.util.Map;
 
 /**
@@ -31,14 +35,56 @@ public class MapEntryContainer implements GraphQLContainer {
 
     @Override
     public Object processFetch(Environment context, PersistentResourceFetcher fetcher) {
+        NonEntityDictionary nonEntityDictionary = fetcher.getNonEntityDictionary();
         String fieldName = context.field.getName();
 
+        Object returnObject;
         if (KEY.equalsIgnoreCase(fieldName)) {
-            return entry.getKey();
+            returnObject = entry.getKey();
+
         } else if (VALUE.equalsIgnoreCase(fieldName)) {
-            return entry.getValue();
+            returnObject = entry.getValue();
+        } else {
+            throw new BadRequestException(""Invalid field: '"" + fieldName
+                    + ""'. Maps only contain fields 'key' and 'value'"");
+        }
+
+        if (nonEntityDictionary.hasBinding(returnObject.getClass())) {
+            return new NonEntityContainer(returnObject);
+        }
+        return returnObject;
+    }
+
+    /**
+     * Converts an attribute which is a list of maps - each containing a KEY and a VALUE
+     * into a HashMap with the value of KEY as key and the value of VALUE as the value.
+     * @param attribute The attribute to convert.
+     * @return The converted map.
+     */
+    public static Map translateFromGraphQLMap(Entity.Attribute attribute) {
+        Map returnMap = new HashMap();
+        Object collection = attribute.getValue();
+
+        if (collection == null) {
+            return null;
+        }
+
+        if (! (collection instanceof Collection)) {
+            throw new BadRequestException(""Invalid map format for GraphQL request"");
         }
 
-        throw new BadRequestException(""Invalid field: '"" + fieldName + ""'. Maps only contain fields 'key' and 'value'"");
+        ((Collection) collection).stream().forEach((entry -> {
+            if (! (entry instanceof Map)) {
+                throw new BadRequestException(""Invalid map format for GraphQL request"");
+            }
+
+            if (! ((Map) entry).containsKey(KEY) && ((Map) entry).containsKey(VALUE)) {
+                throw new BadRequestException(""Invalid map format for GraphQL request"");
+            }
+
+            returnMap.put(((Map) entry).get(KEY), ((Map) entry).get(VALUE));
+        }));
+
+        return returnMap;
     }
 }
",1,java,38.0,MapEntryContainer.java
fdd7459bc5470e90024dbe762249166481cce769,apache/commons-compress,train,"@@ -18,6 +18,8 @@
 package org.apache.commons.compress.compressors.bzip2;
+import java.util.BitSet;
+
@@ -92,12 +94,14 @@
-     * The class seems to mix several revisions of libbzip2's code.
+     * This class seems to mix several revisions of libbzip2's code.
+     *
+     * I've added the fallbackSort function of 1.0.6.
@@ -108,6 +112,12 @@
     private static final int QSORT_STACK_SIZE = 1000;
+    private static final int FALLBACK_QSORT_STACK_SIZE = 100;
+
+    private static final int STACK_SIZE =
+        QSORT_STACK_SIZE < FALLBACK_QSORT_STACK_SIZE
+        ? FALLBACK_QSORT_STACK_SIZE : QSORT_STACK_SIZE;
+
     private boolean blockRandomised;
@@ -118,8 +128,8 @@
     private int workLimit;
     private boolean firstAttempt;
-    private final int[] stack_ll = new int[QSORT_STACK_SIZE]; // 4000 byte
-    private final int[] stack_hh = new int[QSORT_STACK_SIZE]; // 4000 byte
+    private final int[] stack_ll = new int[STACK_SIZE]; // 4000 byte
+    private final int[] stack_hh = new int[STACK_SIZE]; // 4000 byte
     private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte
     private final int[] mainSort_runningOrder = new int[256]; // 1024 byte
@@ -166,6 +176,350 @@ boolean blockSort(final BZip2CompressorOutputStream.Data data, final int last) {
         return blockRandomised;
     }
+/*---------------------------------------------*/
+
+/*---------------------------------------------*/
+/*--- LBZ2: Fallback O(N log(N)^2) sorting        ---*/
+/*--- algorithm, for repetitive blocks      ---*/
+/*---------------------------------------------*/
+
+    /*
+     * This is the fallback sorting algorithm libbzip2 1.0.6 uses for
+     * repetitive or very short inputs.
+     *
+     * The idea is inspired by Manber-Myers string suffix sorting
+     * algorithm.  First a bucket sort places each permutation of the
+     * block into a bucket based on its first byte.  Permutations are
+     * represented by pointers to their first character kept in
+     * (partially) sorted order inside the array ftab.
+     *
+     * The next step visits all buckets in order and performs a
+     * quicksort on all permutations of the bucket based on the index
+     * of the bucket the second byte of the permutation belongs to,
+     * thereby forming new buckets.  When arrived here the
+     * permutations are sorted up to the second character and we have
+     * buckets of permutations that are identical up to two
+     * characters.
+     *
+     * Repeat the step of quicksorting each bucket, now based on the
+     * bucket holding the sequence of the third and forth character
+     * leading to four byte buckets.  Repeat this doubling of bucket
+     * sizes until all buckets only contain single permutations or the
+     * bucket size exceeds the block size.
+     *
+     * I.e.
+     *
+     * ""abraba"" form three buckets for the chars ""a"", ""b"", and ""r"" in
+     * the first step with
+     *
+     * fmap = { 'a:' 5, 3, 0, 'b:' 4, 1, 'r', 2 }
+     *
+     * when looking at the bucket of ""a""s the second characters are in
+     * the buckets that start with fmap-index 0 (rolled over), 3 and 3
+     * respectively, forming two new buckets ""aa"" and ""ab"", so we get
+     *
+     * fmap = { 'aa:' 5, 'ab:' 3, 0, 'ba:' 4, 'br': 1, 'ra:' 2 }
+     *
+     * since the last bucket only contained a single item it didn't
+     * have to be sorted at all.
+     *
+     * There now is just one bucket with more than one permutation
+     * that remains to be sorted.  For the permutation that starts
+     * with index 3 the third and forth char are in bucket 'aa' at
+     * index 0 and for the one starting at block index 0 they are in
+     * bucket 'ra' with sort index 5.  The fully sorted order then becomes.
+     *
+     * fmap = { 5, 3, 0, 4, 1, 2 }
+     * 
+     */
+
+    /**
+     * @param fmap points to the index of the starting point of a
+     *        permutation inside the block of data in the current
+     *        partially sorted order
+     * @param eclass points from the index of a character inside the
+     *        block to the first index in fmap that contains the
+     *        bucket of its suffix that is sorted in this step.
+     * @param lo lower boundary of the fmap-interval to be sorted 
+     * @param hi upper boundary of the fmap-interval to be sorted 
+     */
+    private void fallbackSimpleSort(int[] fmap, 
+                                    int[] eclass, 
+                                    int lo, 
+                                    int hi) {
+        if (lo == hi) return;
+
+        int j;
+        if (hi - lo > 3) {
+            for (int i = hi - 4; i >= lo; i--) {
+                int tmp = fmap[i];
+                int ec_tmp = eclass[tmp];
+                for (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];
+                     j += 4) {
+                    fmap[j - 4] = fmap[j];
+                }
+                fmap[j - 4] = tmp;
+            }
+        }
+
+        for (int i = hi - 1; i >= lo; i--) {
+            int tmp = fmap[i];
+            int ec_tmp = eclass[tmp];
+            for (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {
+                fmap[j - 1] = fmap[j];
+            }
+            fmap[j-1] = tmp;
+        }
+    }
+
+    private static final int FALLBACK_QSORT_SMALL_THRESH = 10;
+
+    /**
+     * swaps two values in fmap
+     */
+    private void fswap(int[] fmap, int zz1, int zz2) {
+        int zztmp = fmap[zz1];
+        fmap[zz1] = fmap[zz2];
+        fmap[zz2] = zztmp;
+    }
+
+    /**
+     * swaps two intervals starting at yyp1 and yyp2 of length yyn inside fmap.
+     */
+    private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {
+        while (yyn > 0) {
+            fswap(fmap, yyp1, yyp2);
+            yyp1++; yyp2++; yyn--;
+        }
+    }
+
+    private int fmin(int a, int b) {
+        return a < b ? a : b;
+    }
+
+    private void fpush(int sp, int lz, int hz) {
+        stack_ll[sp] = lz;
+        stack_hh[sp] = hz;
+    }
+
+    private int[] fpop(int sp) {
+        return new int[] { stack_ll[sp], stack_hh[sp] };
+    }
+
+    /**
+     * @param fmap points to the index of the starting point of a
+     *        permutation inside the block of data in the current
+     *        partially sorted order
+     * @param eclass points from the index of a character inside the
+     *        block to the first index in fmap that contains the
+     *        bucket of its suffix that is sorted in this step.
+     * @param loSt lower boundary of the fmap-interval to be sorted 
+     * @param hiSt upper boundary of the fmap-interval to be sorted 
+     */
+    private void fallbackQSort3(int[] fmap, 
+                                int[] eclass, 
+                                int loSt, 
+                                int hiSt) {
+        int lo, unLo, ltLo, hi, unHi, gtHi, n;
+
+        long r = 0;
+        int sp = 0;
+        fpush(sp++, loSt, hiSt);
+
+        while (sp > 0) {
+            int[] s = fpop(--sp);
+            lo = s[0]; hi = s[1];
+
+            if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {
+                fallbackSimpleSort(fmap, eclass, lo, hi);
+                continue;
+            }
+
+            /* LBZ2: Random partitioning.  Median of 3 sometimes fails to
+               avoid bad cases.  Median of 9 seems to help but 
+               looks rather expensive.  This too seems to work but
+               is cheaper.  Guidance for the magic constants 
+               7621 and 32768 is taken from Sedgewick's algorithms
+               book, chapter 35.
+            */
+            r = ((r * 7621) + 1) % 32768;
+            long r3 = r % 3, med;
+            if (r3 == 0) {
+                med = eclass[fmap[lo]]; 
+            } else if (r3 == 1) {
+                med = eclass[fmap[(lo+hi)>>1]];
+            } else {
+                med = eclass[fmap[hi]];
+            }
+
+            unLo = ltLo = lo;
+            unHi = gtHi = hi;
+
+            // looks like the ternary partition attributed to Wegner
+            // in the cited Sedgewick paper
+            while (true) {
+                while (true) {
+                    if (unLo > unHi) break;
+                    n = eclass[fmap[unLo]] - (int) med;
+                    if (n == 0) { 
+                        fswap(fmap, unLo, ltLo); 
+                        ltLo++; unLo++; 
+                        continue; 
+                    };
+                    if (n > 0) break;
+                    unLo++;
+                }
+                while (true) {
+                    if (unLo > unHi) break;
+                    n = eclass[fmap[unHi]] - (int) med;
+                    if (n == 0) {
+                        fswap(fmap, unHi, gtHi); 
+                        gtHi--; unHi--; 
+                        continue; 
+                    };
+                    if (n < 0) break;
+                    unHi--;
+                }
+                if (unLo > unHi) break;
+                fswap(fmap, unLo, unHi); unLo++; unHi--;
+            }
+
+            if (gtHi < ltLo) continue;
+
+            n = fmin(ltLo - lo, unLo - ltLo);
+            fvswap(fmap, lo, unLo - n, n);
+            int m = fmin(hi - gtHi, gtHi - unHi);
+            fvswap(fmap, unHi + 1, hi - m + 1, m);
+
+            n = lo + unLo - ltLo - 1;
+            m = hi - (gtHi - unHi) + 1;
+
+            if (n - lo > hi - m) {
+                fpush(sp++, lo, n);
+                fpush(sp++, m, hi);
+            } else {
+                fpush(sp++, m, hi);
+                fpush(sp++, lo, n);
+            }
+        }
+    }
+
+
+/*---------------------------------------------*/
+
+    private int[] eclass;
+
+    private int[] getEclass() {
+        return eclass == null
+            ? (eclass = new int[quadrant.length / 2]) : eclass;
+    }
+
+    /*
+     * The C code uses an array of ints to represents the bucket-start
+     * flags (bhtab).  It also contains optimizations to skip over 32
+     * consecutively set or consecutively unset bits on word
+     * boundaries at once.  For now I've chosen to use the simpler but
+     * potentially slower code using BitSet - also in the hope that
+     * using the BitSet#nextXXX methods may be fast enough.
+     */
+
+    /**
+     * @param fmap points to the index of the starting point of a
+     *        permutation inside the block of data in the current
+     *        partially sorted order
+     * @param block the original data
+     * @param nblock size of the block
+     * @param off offset of first byte to sort in block
+     */
+    final void fallbackSort(int[] fmap, byte[] block, int nblock) {
+        int[] ftab = new int[257];
+        int H, i, j, k, l, r, cc, cc1;
+        int nNotDone;
+        int nBhtab;
+
+        /*--
+          LBZ2: Initial 1-char radix sort to generate
+          initial fmap and initial BH bits.
+          --*/
+        for (i = 0; i < nblock; i++) ftab[block[i] & 0xff]++;
+        for (i = 1; i < 257;    i++) ftab[i] += ftab[i - 1];
+
+        for (i = 0; i < nblock; i++) {
+            j = block[i] & 0xff;
+            k = ftab[j] - 1;
+            ftab[j] = k;
+            fmap[k] = i;
+        }
+
+        nBhtab = 64 + nblock;
+        BitSet bhtab = new BitSet(nBhtab);
+        for (i = 0; i < 256; i++) bhtab.set(ftab[i]);
+
+        /*--
+          LBZ2: Inductively refine the buckets.  Kind-of an
+          ""exponential radix sort"" (!), inspired by the
+          Manber-Myers suffix array construction algorithm.
+          --*/
+
+        /*-- LBZ2: set sentinel bits for block-end detection --*/
+        for (i = 0; i < 32; i++) { 
+            bhtab.set(nblock + 2 * i);
+            bhtab.clear(nblock + 2 * i + 1);
+        }
+
+        eclass = getEclass();
+
+        /*-- LBZ2: the log(N) loop --*/
+        H = 1;
+        while (true) {
+
+            j = 0;
+            for (i = 0; i < nblock; i++) {
+                if (bhtab.get(i)) {
+                    j = i;
+                }
+                k = fmap[i] - H;
+                if (k < 0) {
+                    k += nblock;
+                }
+                eclass[k] = j;
+            }
+
+            nNotDone = 0;
+            r = -1;
+            while (true) {
+
+                /*-- LBZ2: find the next non-singleton bucket --*/
+                k = r + 1;
+                k = bhtab.nextSetBit(k);
+                l = k - 1;
+                if (l >= nblock) break;
+                k = bhtab.nextClearBit(k);
+                r = k - 1;
+                if (r >= nblock) break;
+
+                /*-- LBZ2: now [l, r] bracket current bucket --*/
+                if (r > l) {
+                    nNotDone += (r - l + 1);
+                    fallbackQSort3(fmap, eclass, l, r);
+
+                    /*-- LBZ2: scan bucket and generate header bits-- */
+                    cc = -1;
+                    for (i = l; i <= r; i++) {
+                        cc1 = eclass[fmap[i]];
+                        if (cc != cc1) {
+                            bhtab.set(i);
+                            cc = cc1;
+                        };
+                    }
+                }
+            }
+
+            H *= 2;
+            if (H > nblock || nNotDone == 0) break;
+        }
+    }
+",1,java,203.0,BlockSort.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -86,26 +86,25 @@ private XMSSPrivateKeyParameters(Builder builder)
             position += rootSize;
             byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);
-            BDS bdsImport = null;
             try
             {
-                bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary);
+                BDS bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary, BDS.class);
+                bdsImport.setXMSS(builder.xmss);
+                bdsImport.validate();
+                if (bdsImport.getIndex() != index)
+                {
+                    throw new IllegalStateException(""serialized BDS has wrong index"");
+                }
+                bdsState = bdsImport;
             }
             catch (IOException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
             catch (ClassNotFoundException e)
             {
-                e.printStackTrace();
-            }
-            bdsImport.setXMSS(builder.xmss);
-            bdsImport.validate();
-            if (bdsImport.getIndex() != index)
-            {
-                throw new IllegalStateException(""serialized BDS has wrong index"");
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
-            bdsState = bdsImport;
         }
         else
         {",1,java,21.0,core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSPrivateKeyParameters.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -31,7 +31,7 @@ private ByteUtil() {}
-   * @return  Long integer value.
+   * @return  Integer value.
   public static int toInt(final byte[] data)
   {
@@ -39,6 +39,19 @@ public static int toInt(final byte[] data)
   }
+  /**
+   * Converts an unsigned byte into an integer.
+   *
+   * @param  unsigned  Unsigned byte.
+   *
+   * @return  Integer value.
+   */
+  public static int toInt(final byte unsigned)
+  {
+    return 0x000000FF & unsigned;
+  }
+
+
@@ -175,6 +188,21 @@ public static String toString(final byte[] bytes)
   }
+  /**
+   * Converts a portion of a byte array into a string in the UTF-8 character set.
+   *
+   * @param  bytes  Byte array to convert.
+   * @param  offset  Offset into byte array where string content begins.
+   * @param  length  Total number of bytes to convert.
+   *
+   * @return  UTF-8 string representation of bytes.
+   */
+  public static String toString(final byte[] bytes, final int offset, final int length)
+  {
+    return new String(bytes, offset, length, DEFAULT_CHARSET);
+  }
+
+
@@ -226,6 +254,19 @@ public static ByteBuffer toByteBuffer(final String s)
   }
+  /**
+   * Converts an integer into an unsigned byte. All bits above 1 byte are truncated.
+   *
+   * @param  b  Integer value.
+   *
+   * @return  Unsigned byte as a byte.
+   */
+  public static byte toUnsignedByte(final int b)
+  {
+    return (byte) (0x000000FF & b);
+  }
+
+
@@ -244,4 +285,6 @@ public static ByteBuffer toByteBuffer(final String s)
     buffer.get(array);
     return array;
   }
+
+
 }",1,java,13.0,src/main/java/org/cryptacular/util/ByteUtil.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -68,21 +68,21 @@ private XMSSMTPrivateKeyParameters(Builder builder)
             byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);
-            BDSStateMap bdsImport = null;
             try
             {
-                bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary);
+                BDSStateMap bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary, BDSStateMap.class);
+
+                bdsImport.setXMSS(builder.xmss);
+                bdsState = bdsImport;
             }
             catch (IOException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
             catch (ClassNotFoundException e)
             {
-                e.printStackTrace();
+                throw new IllegalArgumentException(e.getMessage(), e);
             }
-            bdsImport.setXMSS(builder.xmss);
-            bdsState = bdsImport;
         }
         else
         {
@@ -260,17 +260,14 @@ public XMSSMTPrivateKeyParameters build()
         XMSSUtil.copyBytesAtOffset(out, root, position);
-        byte[] bdsStateOut = null;
         try
         {
-            bdsStateOut = XMSSUtil.serialize(bdsState);
+            return Arrays.concatenate(out, XMSSUtil.serialize(bdsState));
         }
         catch (IOException e)
         {
-            e.printStackTrace();
-            throw new RuntimeException(""error serializing bds state"");
+            throw new IllegalStateException(""error serializing bds state: "" + e.getMessage(), e);
         }
-        return Arrays.concatenate(out, bdsStateOut);
     }
     public long getIndex()",1,java,18.0,core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSMTPrivateKeyParameters.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,train,"@@ -183,7 +183,7 @@ private HttpURLConnection createUrlConnection(Request request) throws IOExceptio
             SSLContext sslContext = config.getSSLContext();
             if (sslContext == null) {
                 try {
-                    sslContext = SslUtils.getSSLContext();
+                    sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
                 } catch (NoSuchAlgorithmException e) {
                     throw new IOException(e.getMessage());
                 } catch (GeneralSecurityException e) {",1,java,2.0,src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -22,6 +22,9 @@ import org.openqa.selenium.By;
 import org.openqa.selenium.WebElement;
 import org.openqa.selenium.support.FindBy;
+import java.util.LinkedList;
+import java.util.List;
+
@@ -50,26 +53,72 @@ public class AccountFederatedIdentityPage extends AbstractAccountPage {
     public boolean isCurrent() {
         return driver.getTitle().contains(""Account Management"") && driver.getPageSource().contains(""Federated Identities"");
     }
-    
-    public WebElement findAddProviderButton(String alias) {
-        return driver.findElement(By.id(""add-"" + alias));
+
+    public List<FederatedIdentity> getIdentities() {
+        List<FederatedIdentity> identities = new LinkedList<>();
+        WebElement identitiesElement = driver.findElement(By.id(""federated-identities""));
+        for (WebElement i : identitiesElement.findElements(By.className(""row""))) {
+
+            String providerId = i.findElement(By.tagName(""label"")).getText();
+            String subject = i.findElement(By.tagName(""input"")).getAttribute(""value"");
+            WebElement button = i.findElement(By.tagName(""button""));
+
+            identities.add(new FederatedIdentity(providerId, subject, button));
+        }
+        return identities;
     }
-    
-    public WebElement findRemoveProviderButton(String alias) {
-        return driver.findElement(By.id(""remove-"" + alias));
+
+    public WebElement findAddProvider(String providerId) {
+        return driver.findElement(By.id(""add-link-"" + providerId));
     }
-    public void clickAddProvider(String alias) {
-        WebElement addButton = findAddProviderButton(alias);
-        addButton.click();
+    public void clickAddProvider(String providerId) {
+        findAddProvider(providerId).click();
     }
-    public void clickRemoveProvider(String alias) {
-        WebElement addButton = findRemoveProviderButton(alias);
-        addButton.click();
+    public void clickRemoveProvider(String providerId) {
+        driver.findElement(By.id(""remove-link-"" + providerId)).click();
     }
     public String getError() {
         return errorMessage.getText();
     }
+
+    public static class FederatedIdentity {
+
+        private String providerId;
+        private String subject;
+        private WebElement action;
+
+        public FederatedIdentity(String providerId, String subject, WebElement action) {
+            this.providerId = providerId;
+            this.subject = subject;
+            this.action = action;
+        }
+
+        public String getProvider() {
+            return providerId;
+        }
+
+        public void setProviderId(String providerId) {
+            this.providerId = providerId;
+        }
+
+        public String getSubject() {
+            return subject;
+        }
+
+        public void setSubject(String subject) {
+            this.subject = subject;
+        }
+
+        public WebElement getAction() {
+            return action;
+        }
+
+        public void setAction(WebElement action) {
+            this.action = action;
+        }
+    }
+
 }",1,java,56.0,AccountFederatedIdentityPage.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -126,9 +126,8 @@ public class Urls {
         return accountBase(baseUri).path(AccountFormService.class, ""totpPage"").build(realmName);
     }
-    public static URI accountTotpRemove(URI baseUri, String realmName, String stateChecker) {
+    public static URI accountTotpRemove(URI baseUri, String realmName) {
         return accountBase(baseUri).path(AccountFormService.class, ""processTotpRemove"")
-                .queryParam(""stateChecker"", stateChecker)
                 .build(realmName);
     }
@@ -140,9 +139,8 @@ public class Urls {
         return accountBase(baseUri).path(AccountFormService.class, ""sessionsPage"").build(realmName);
     }
-    public static URI accountSessionsLogoutPage(URI baseUri, String realmName, String stateChecker) {
+    public static URI accountSessionsLogoutPage(URI baseUri, String realmName) {
         return accountBase(baseUri).path(AccountFormService.class, ""processSessionsLogout"")
-                .queryParam(""stateChecker"", stateChecker)
                 .build(realmName);
     }",1,java,6.0,Urls.java
e6aa166246d1734f4798a9e31f78842f4c85c28b,jenkinsci/jenkins,train,"@@ -0,0 +1,84 @@
+/*
+ * The MIT License
+ *
+ * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi
+ * Copyright (c) 2016, CloudBees Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the ""Software""), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package hudson.util;
+
+import com.trilead.ssh2.crypto.Base64;
+import hudson.Util;
+import jenkins.model.Jenkins;
+import jenkins.security.CryptoConfidentialKey;
+import org.kohsuke.accmod.Restricted;
+import org.kohsuke.accmod.restrictions.NoExternalUse;
+
+import javax.crypto.Cipher;
+import javax.crypto.SecretKey;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+/**
+ * Historical algorithms for decrypting {@link Secret}s.
+ */
+@Restricted(NoExternalUse.class)
+public class HistoricalSecrets {
+
+    /*package*/ static Secret decrypt(String data, CryptoConfidentialKey key) throws IOException, GeneralSecurityException {
+        byte[] in = Base64.decode(data.toCharArray());
+        Secret s = tryDecrypt(key.decrypt(), in);
+        if (s!=null)    return s;
+
+        // try our historical key for backward compatibility
+        Cipher cipher = Secret.getCipher(""AES"");
+        cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());
+        return tryDecrypt(cipher, in);
+    }
+
+    /*package*/ static Secret tryDecrypt(Cipher cipher, byte[] in) {
+        try {
+            String plainText = new String(cipher.doFinal(in), UTF_8);
+            if(plainText.endsWith(MAGIC))
+                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));
+            return null;
+        } catch (GeneralSecurityException e) {
+            return null; // if the key doesn't match with the bytes, it can result in BadPaddingException
+        }
+    }
+
+    /**
+     * Turns {@link Jenkins#getSecretKey()} into an AES key.
+     *
+     * @deprecated
+     * This is no longer the key we use to encrypt new information, but we still need this
+     * to be able to decrypt what's already persisted.
+     */
+    @Deprecated
+    /*package*/ static SecretKey getLegacyKey() throws GeneralSecurityException {
+        String secret = Secret.SECRET;
+        if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();
+        return Util.toAes128Key(secret);
+    }
+
+    private static final String MAGIC = ""::::MAGIC::::"";
+}",1,java,38.0,core/src/main/java/hudson/util/HistoricalSecrets.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -49,7 +49,7 @@ public class ModelBuilder {
     public static final String ARGUMENT_AFTER = ""after"";
     public static final String ARGUMENT_OPERATION = ""op"";
 
-    private EntityDictionary dictionary;
+    private EntityDictionary entityDictionary;
     private DataFetcher dataFetcher;
     private GraphQLArgument relationshipOpArg;
     private GraphQLArgument idArgument;
@@ -69,12 +69,15 @@ public class ModelBuilder {
 
     /**
      * Class constructor, constructs the custom arguments to handle mutations
-     * @param dictionary elide entity dictionary
+     * @param entityDictionary elide entity dictionary
+     * @param nonEntityDictionary elide non-entity dictionary
      * @param dataFetcher graphQL data fetcher
      */
-    public ModelBuilder(EntityDictionary dictionary, DataFetcher dataFetcher) {
-        this.generator = new GraphQLConversionUtils(dictionary);
-        this.dictionary = dictionary;
+    public ModelBuilder(EntityDictionary entityDictionary,
+                        NonEntityDictionary nonEntityDictionary,
+                        DataFetcher dataFetcher) {
+        this.generator = new GraphQLConversionUtils(entityDictionary, nonEntityDictionary);
+        this.entityDictionary = entityDictionary;
         this.dataFetcher = dataFetcher;
 
         relationshipOpArg = newArgument()
@@ -143,24 +146,24 @@ public class ModelBuilder {
      * @return The built schema.
      */
     public GraphQLSchema build() {
-        Set<Class<?>> allClasses = dictionary.getBindings();
+        Set<Class<?>> allClasses = entityDictionary.getBindings();
 
         if (allClasses.isEmpty()) {
             throw new IllegalArgumentException(""None of the provided classes are exported by Elide"");
         }
 
-        Set<Class<?>> rootClasses =  allClasses.stream().filter(dictionary::isRoot).collect(Collectors.toSet());
+        Set<Class<?>> rootClasses =  allClasses.stream().filter(entityDictionary::isRoot).collect(Collectors.toSet());
 
         /*
          * Walk the object graph (avoiding cycles) and construct the GraphQL input object types.
          */
-        dictionary.walkEntityGraph(rootClasses, this::buildInputObjectStub);
+        entityDictionary.walkEntityGraph(rootClasses, this::buildInputObjectStub);
         resolveInputObjectRelationships();
 
         /* Construct root object */
         GraphQLObjectType.Builder root = newObject().name(""_root"");
         for (Class<?> clazz : rootClasses) {
-            String entityName = dictionary.getJsonAliasFor(clazz);
+            String entityName = entityDictionary.getJsonAliasFor(clazz);
             root.field(newFieldDefinition()
                     .name(entityName)
                     .dataFetcher(dataFetcher)
@@ -180,7 +183,7 @@ public class ModelBuilder {
         /*
          * Walk the object graph (avoiding cycles) and construct the GraphQL output object types.
          */
-        dictionary.walkEntityGraph(rootClasses, this::buildConnectionObject);
+        entityDictionary.walkEntityGraph(rootClasses, this::buildConnectionObject);
 
         /* Construct the schema */
         GraphQLSchema schema = GraphQLSchema.newSchema()
@@ -205,7 +208,7 @@ public class ModelBuilder {
             return connectionObjectRegistry.get(entityClass);
         }
 
-        String entityName = dictionary.getJsonAliasFor(entityClass);
+        String entityName = entityDictionary.getJsonAliasFor(entityClass);
 
         GraphQLObjectType connectionObject = newObject()
                 .name(entityName)
@@ -236,12 +239,12 @@ public class ModelBuilder {
 
         log.debug(""Building query object for {}"", entityClass.getName());
 
-        String entityName = dictionary.getJsonAliasFor(entityClass);
+        String entityName = entityDictionary.getJsonAliasFor(entityClass);
 
         GraphQLObjectType.Builder builder = newObject()
                 .name(""_node__"" + entityName);
 
-        String id = dictionary.getIdFieldName(entityClass);
+        String id = entityDictionary.getIdFieldName(entityClass);
 
         /* our id types are DeferredId objects (not Scalars.GraphQLID) */
         builder.field(newFieldDefinition()
@@ -249,8 +252,8 @@ public class ModelBuilder {
                 .dataFetcher(dataFetcher)
                 .type(GraphQLScalars.GRAPHQL_DEFERRED_ID));
 
-        for (String attribute : dictionary.getAttributes(entityClass)) {
-            Class<?> attributeClass = dictionary.getType(entityClass, attribute);
+        for (String attribute : entityDictionary.getAttributes(entityClass)) {
+            Class<?> attributeClass = entityDictionary.getType(entityClass, attribute);
             if (excludedEntities.contains(attributeClass)) {
                 continue;
             }
@@ -274,14 +277,14 @@ public class ModelBuilder {
             );
         }
 
-        for (String relationship : dictionary.getElideBoundRelationships(entityClass)) {
-            Class<?> relationshipClass = dictionary.getParameterizedType(entityClass, relationship);
+        for (String relationship : entityDictionary.getElideBoundRelationships(entityClass)) {
+            Class<?> relationshipClass = entityDictionary.getParameterizedType(entityClass, relationship);
             if (excludedEntities.contains(relationshipClass)) {
                 continue;
             }
 
-            String relationshipEntityName = dictionary.getJsonAliasFor(relationshipClass);
-            RelationshipType type = dictionary.getRelationshipType(entityClass, relationship);
+            String relationshipEntityName = entityDictionary.getJsonAliasFor(relationshipClass);
+            RelationshipType type = entityDictionary.getRelationshipType(entityClass, relationship);
 
             if (type.isToOne()) {
                 builder.field(newFieldDefinition()
@@ -351,18 +354,18 @@ public class ModelBuilder {
     private GraphQLInputType buildInputObjectStub(Class<?> clazz) {
         log.debug(""Building input object for {}"", clazz.getName());
 
-        String entityName = dictionary.getJsonAliasFor(clazz);
+        String entityName = entityDictionary.getJsonAliasFor(clazz);
 
         MutableGraphQLInputObjectType.Builder builder = MutableGraphQLInputObjectType.newMutableInputObject();
         builder.name(entityName + ARGUMENT_INPUT);
 
-        String id = dictionary.getIdFieldName(clazz);
+        String id = entityDictionary.getIdFieldName(clazz);
         builder.field(newInputObjectField()
                 .name(id)
                 .type(Scalars.GraphQLID));
 
-        for (String attribute : dictionary.getAttributes(clazz)) {
-            Class<?> attributeClass = dictionary.getType(clazz, attribute);
+        for (String attribute : entityDictionary.getAttributes(clazz)) {
+            Class<?> attributeClass = entityDictionary.getType(clazz, attribute);
 
             if (excludedEntities.contains(attributeClass)) {
                 continue;
@@ -390,10 +393,6 @@ public class ModelBuilder {
                 } else {
                     attributeType = convertedInputs.get(objectName);
                 }
-            } else {
-                String attributeTypeName = attributeType.getName();
-                convertedInputs.putIfAbsent(attributeTypeName, attributeType);
-                attributeType = convertedInputs.get(attributeTypeName);
             }
 
             builder.field(newInputObjectField()
@@ -412,14 +411,14 @@ public class ModelBuilder {
      */
     private void resolveInputObjectRelationships() {
         inputObjectRegistry.forEach((clazz, inputObj) -> {
-            for (String relationship : dictionary.getElideBoundRelationships(clazz)) {
+            for (String relationship : entityDictionary.getElideBoundRelationships(clazz)) {
                 log.debug(""Resolving relationship {} for {}"", relationship, clazz.getName());
-                Class<?> relationshipClass = dictionary.getParameterizedType(clazz, relationship);
+                Class<?> relationshipClass = entityDictionary.getParameterizedType(clazz, relationship);
                 if (excludedEntities.contains(relationshipClass)) {
                     continue;
                 }
 
-                RelationshipType type = dictionary.getRelationshipType(clazz, relationship);
+                RelationshipType type = entityDictionary.getRelationshipType(clazz, relationship);
 
                 if (type.isToOne()) {
                     inputObj.setField(relationship, newInputObjectField()
",1,java,56.0,ModelBuilder.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,kiegroup/jbpm-designer,train,"@@ -1,6 +1,6 @@
 package org.jbpm.designer.repository;
 
-import org.apache.commons.httpclient.URIException;
+import org.uberfire.java.nio.EncodingUtil;
 
 public class UriUtils {
 
@@ -13,22 +13,14 @@ public class UriUtils {
         if (value.matches(URL_ENCODED_REGEX)) {
             return value;
         }
-        try {
-            return org.apache.commons.httpclient.util.URIUtil.encodePath(value);
-        } catch (URIException e) {
-            throw new IllegalArgumentException(""Invalid value "" + value + "" given, error: "" + e.getMessage(), e);
-        }
+        return EncodingUtil.encodePath(value);
     }
 
     public static String decode(String value) {
         if(value == null) {
             return value;
         }
-        try {
-            return org.apache.commons.httpclient.util.URIUtil.decode(value);
-        } catch (URIException e) {
-            throw new IllegalArgumentException(""Invalid value "" + value + "" given, error: "" + e.getMessage(), e);
-        }
+        return EncodingUtil.decode(value);
 
     }
 }
",1,java,14.0,UriUtils.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,train,"@@ -0,0 +1,118 @@
+/*
+ * file:       UnmarshalHelper.java
+ * author:     Jon Iles
+ * copyright:  (c) Packwood Software 2020
+ * date:       29/08/2020
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package net.sf.mpxj.common;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.UnmarshallerHandler;
+import javax.xml.bind.ValidationEvent;
+import javax.xml.bind.ValidationEventHandler;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParserFactory;
+import javax.xml.transform.sax.SAXSource;
+
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLFilter;
+import org.xml.sax.XMLReader;
+
+/**
+ * Utility methods wrapping JAXB unmarshal.
+ */
+public final class UnmarshalHelper
+{
+   /**
+    * Unmarshal from an input stream.
+    *
+    * @param context JAXB context
+    * @param stream input stream
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputStream stream) throws JAXBException, SAXException, ParserConfigurationException
+   {
+      return context.createUnmarshaller().unmarshal(new SAXSource(createXmlReader(), new InputSource(stream)));
+   }
+
+   /**
+    * Unmarshall from an input stream and apply a filter.
+    *
+    * @param context JAXB context
+    * @param stream input stream
+    * @param filter XMLFilter instance
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputStream stream, XMLFilter filter) throws JAXBException, SAXException, ParserConfigurationException, IOException
+   {
+      return unmarshal(context, new InputSource(stream), filter, false);
+   }
+
+   /**
+    * Unmarshall from an input source and apply a filter, optionally ignore validation errors.
+    *
+    * @param context JAXB context
+    * @param source input source
+    * @param filter XMLFilter instance
+    * @param ignoreValidationErrors true if validation errors are ignored
+    * @return Unmarshalled root node
+    */
+   public static final Object unmarshal(JAXBContext context, InputSource source, XMLFilter filter, boolean ignoreValidationErrors) throws JAXBException, SAXException, ParserConfigurationException, IOException
+   {
+      Unmarshaller unmarshaller = context.createUnmarshaller();
+
+      if (ignoreValidationErrors)
+      {
+         unmarshaller.setEventHandler(new ValidationEventHandler()
+         {
+            @Override public boolean handleEvent(ValidationEvent event)
+            {
+               return true;
+            }
+         });
+      }
+
+      UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
+      filter.setParent(createXmlReader());
+      filter.setContentHandler(unmarshallerHandler);
+      filter.parse(source);
+
+      return unmarshallerHandler.getResult();
+   }
+   
+   /**
+    * Create a new XmlReader instance.
+    *
+    * @return XmlReader instance
+    */
+   public static final XMLReader createXmlReader() throws SAXException, ParserConfigurationException
+   {
+      SAXParserFactory factory = SAXParserFactory.newInstance();
+      factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
+      factory.setNamespaceAware(true);
+      return factory.newSAXParser().getXMLReader();
+   }
+}
",1,java,54.0,UnmarshalHelper.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -24,14 +24,12 @@ import org.keycloak.OAuth2Constants;
 import org.keycloak.common.ClientConnection;
 import org.keycloak.common.util.Base64Url;
 import org.keycloak.common.util.KeycloakUriBuilder;
-import org.keycloak.common.util.UriUtils;
 import org.keycloak.models.ClientModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.utils.KeycloakModelUtils;
 import org.keycloak.protocol.oidc.OIDCLoginProtocolService;
 import org.keycloak.services.ForbiddenException;
-import org.keycloak.services.managers.AppAuthManager;
 import org.keycloak.services.managers.Auth;
 import org.keycloak.services.managers.AuthenticationManager;
 import org.keycloak.services.util.CookieHelper;
@@ -130,14 +128,20 @@ public abstract class AbstractSecuredLocalService {
     }
     protected void updateCsrfChecks() {
-        Cookie cookie = headers.getCookies().get(KEYCLOAK_STATE_CHECKER);
-        if (cookie != null) {
-            stateChecker = cookie.getValue();
-        } else {
+        stateChecker = getStateChecker();
+        if (stateChecker == null) {
             stateChecker = Base64Url.encode(KeycloakModelUtils.generateSecret());
-            String cookiePath = AuthenticationManager.getRealmCookiePath(realm, uriInfo);
+
+            StringBuilder sb = new StringBuilder();
+            sb.append(auth.getSession().getId());
+            sb.append(""/"");
+            sb.append(stateChecker);
+
+            String sessionCookieValue = sb.toString();
+
+            String cookiePath = AuthenticationManager.getAccountCookiePath(realm, uriInfo);
             boolean secureOnly = realm.getSslRequired().isRequired(clientConnection);
-            CookieHelper.addCookie(KEYCLOAK_STATE_CHECKER, stateChecker, cookiePath, null, null, -1, secureOnly, true);
+            CookieHelper.addCookie(KEYCLOAK_STATE_CHECKER, sessionCookieValue, cookiePath, null, null, -1, secureOnly, true);
         }
     }
@@ -149,25 +153,27 @@ public abstract class AbstractSecuredLocalService {
     protected void csrfCheck(final MultivaluedMap<String, String> formData) {
-        if (!auth.isCookieAuthenticated()) return;
         String stateChecker = formData.getFirst(""stateChecker"");
-        if (!this.stateChecker.equals(stateChecker)) {
+        if (stateChecker == null || !stateChecker.equals(getStateChecker())) {
             throw new ForbiddenException();
         }
-
     }
-    /**
-     * Check to see if form post has sessionId hidden field and match it against the session id.
-     *
-     */
-    protected void csrfCheck(String stateChecker) {
-        if (!auth.isCookieAuthenticated()) return;
-        if (auth.getSession() == null) return;
-        if (!this.stateChecker.equals(stateChecker)) {
-            throw new ForbiddenException();
+    protected String getStateChecker() {
+        Cookie cookie = headers.getCookies().get(KEYCLOAK_STATE_CHECKER);
+        if (cookie != null) {
+            stateChecker = cookie.getValue();
+            String[] s = stateChecker.split(""/"");
+            if (s.length == 2) {
+                String sessionId = s[0];
+                String stateChecker = s[1];
+
+                if (auth.getSession().getId().equals(sessionId)) {
+                    return stateChecker;
+                }
+            }
         }
-
+        return null;
     }
     protected abstract URI getBaseRedirectUri();",1,java,38.0,AbstractSecuredLocalService.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -383,7 +383,7 @@ public void onTimeout(Connection connection) {
         boolean defaultSecState = (context != null);
         if (context == null) {
             try {
-                context = SslUtils.getSSLContext();
+                context = SslUtils.getInstance().getSSLContext(clientConfig.isAcceptAnyCertificate());
             } catch (Exception e) {
                 throw new IllegalStateException(e);
             }",1,java,2.0,src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2020, PostgreSQL Global Development Group
+ * See the LICENSE file in the project root for more information.
+ */
+
+package org.postgresql.xml;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.sax.SAXTransformerFactory;
+
+public class LegacyInsecurePGXmlFactoryFactory implements PGXmlFactoryFactory {
+  public static final LegacyInsecurePGXmlFactoryFactory INSTANCE = new LegacyInsecurePGXmlFactoryFactory();
+
+  private LegacyInsecurePGXmlFactoryFactory() {
+  }
+
+  @Override
+  public DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
+    DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+    builder.setErrorHandler(NullErrorHandler.INSTANCE);
+    return builder;
+  }
+
+  @Override
+  public TransformerFactory newTransformerFactory() {
+    return TransformerFactory.newInstance();
+  }
+
+  @Override
+  public SAXTransformerFactory newSAXTransformerFactory() {
+    return (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+  }
+
+  @Override
+  public XMLInputFactory newXMLInputFactory() {
+    return XMLInputFactory.newInstance();
+  }
+
+  @Override
+  public XMLOutputFactory newXMLOutputFactory() {
+    return XMLOutputFactory.newInstance();
+  }
+
+  @Override
+  public XMLReader createXMLReader() throws SAXException {
+    return XMLReaderFactory.createXMLReader();
+  }
+}",1,java,43.0,pgjdbc/src/main/java/org/postgresql/xml/LegacyInsecurePGXmlFactoryFactory.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -164,9 +164,9 @@ public KeyValue get(final String key, final long languageId, final ContentType c
             if (UtilMethods.isSet(contentType) && UtilMethods.isSet(contentType.variable())) {
-                query.append("" +"").append(contentType.variable()).append("".key:"").append(key);
+                query.append("" +"").append(contentType.variable()).append("".key_dotraw:"").append(key);
             } else {
-                query.append("" +key:"").append(key);
+                query.append("" +key_dotraw:"").append(key);
             }
             query.append((languageId >= 0) ? "" +languageId:"" + languageId : StringPool.BLANK);",1,java,4.0,dotCMS/src/main/java/com/dotcms/keyvalue/business/KeyValueAPIImpl.java
96d8f4c1ad42728e75b7b841c7dad6f58d006f8f,yahoo/elide,train,"@@ -16,6 +16,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 
 /**
  * Basically the same class as GraphQLInputObjectType except fields can be added after the
@@ -46,7 +47,7 @@ import java.util.Map;
 public class MutableGraphQLInputObjectType extends GraphQLInputObjectType {
 
     private final Map<String, GraphQLInputObjectField> fieldMap = new LinkedHashMap<String, GraphQLInputObjectField>();
-    private String name;
+    private final String name;
 
     public MutableGraphQLInputObjectType(String name, String description, List<GraphQLInputObjectField> fields) {
         super(name, description, fields);
@@ -59,10 +60,6 @@ public class MutableGraphQLInputObjectType extends GraphQLInputObjectType {
         return name;
     }
 
-    public void setName(String name) {
-        this.name = name;
-    }
-
     private void buildMap(List<GraphQLInputObjectField> fields) {
         for (GraphQLInputObjectField field : fields) {
             String name = field.getName();
@@ -137,4 +134,21 @@ public class MutableGraphQLInputObjectType extends GraphQLInputObjectType {
             return new MutableGraphQLInputObjectType(name, description, fields);
         }
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        MutableGraphQLInputObjectType that = (MutableGraphQLInputObjectType) o;
+        return Objects.equals(name, that.name);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name);
+    }
 }
",1,java,21.0,MutableGraphQLInputObjectType.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -52,7 +52,7 @@ public BCXMSSMTPrivateKey(PrivateKeyInfo keyInfo)
             if (xmssMtPrivateKey.getBdsState() != null)
             {
-                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState()));
+                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState(), BDSStateMap.class));
             }
             this.keyParams = keyBuilder.build();",1,java,2.0,prov/src/main/java/org/bouncycastle/pqc/jcajce/provider/xmss/BCXMSSMTPrivateKey.java
ce5c3e8079d64929abb76ec3ec7ac7c71a4a26b6,dotCMS/core,train,"@@ -14,6 +14,8 @@
 import com.dotcms.filters.interceptor.AbstractWebInterceptorSupportFilter;
 import com.dotcms.filters.interceptor.WebInterceptorDelegate;
 import com.dotcms.filters.interceptor.dotcms.DefaultBackEndLoginRequiredWebInterceptor;
+import com.dotcms.filters.interceptor.dotcms.XSSPreventionWebInterceptor;
+import com.dotmarketing.util.Config;
@@ -39,6 +41,9 @@ private void addDefaultInterceptors(final FilterConfig config) {
         delegate.add(new DefaultBackEndLoginRequiredWebInterceptor());
+        if(Config.getBooleanProperty(""XSS_PROTECTION_ENABLED"", false));{
+          delegate.add(new XSSPreventionWebInterceptor());
+        }
     } // addDefaultInterceptors.",1,java,6.0,dotCMS/src/main/java/com/dotmarketing/filters/LoginRequiredFilter.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,train,"@@ -0,0 +1,96 @@
+/*
+ * To the extent possible under law, Kevin Locke has waived all copyright and
+ * related or neighboring rights to this work.
+ * <p/>
+ * A legal description of this waiver is available in <a href=""https://gist.github.com/kevinoid/3829665"">LICENSE.txt</a>
+ */
+package org.asynchttpclient.util;
+
+import sun.security.util.HostnameChecker;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.kerberos.KerberosPrincipal;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * Uses the internal HostnameChecker to verify the server's hostname matches with the
+ * certificate.  This is a requirement for HTTPS, but the raw SSLEngine does not have
+ * this functionality.  As such, it has to be added in manually.  For a more complete
+ * description of hostname verification and why it's important,
+ * please read
+ * <a href=""http://tersesystems.com/2014/03/23/fixing-hostname-verification/"">Fixing
+ * Hostname Verification</a>.
+ * <p/>
+ * This code is based on Kevin Locke's <a href=""http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/"">guide</a> .
+ * <p/>
+
+ */
+public class DefaultHostnameVerifier implements HostnameVerifier {
+
+    private HostnameVerifier extraHostnameVerifier;
+
+    public DefaultHostnameVerifier() {
+    }
+
+    public DefaultHostnameVerifier(HostnameVerifier extraHostnameVerifier) {
+        this.extraHostnameVerifier = extraHostnameVerifier;
+    }
+
+    private boolean hostnameMatches(String hostname, SSLSession session) {
+        HostnameChecker checker =
+                HostnameChecker.getInstance(HostnameChecker.TYPE_TLS);
+
+        boolean validCertificate = false, validPrincipal = false;
+        try {
+            Certificate[] peerCertificates = session.getPeerCertificates();
+
+            if (peerCertificates.length > 0 &&
+                    peerCertificates[0] instanceof X509Certificate) {
+                X509Certificate peerCertificate =
+                        (X509Certificate) peerCertificates[0];
+
+                try {
+                    checker.match(hostname, peerCertificate);
+                    // Certificate matches hostname
+                    validCertificate = true;
+                } catch (CertificateException ex) {
+                    // Certificate does not match hostname
+                }
+            } else {
+                // Peer does not have any certificates or they aren't X.509
+            }
+        } catch (SSLPeerUnverifiedException ex) {
+            // Not using certificates for peers, try verifying the principal
+            try {
+                Principal peerPrincipal = session.getPeerPrincipal();
+                if (peerPrincipal instanceof KerberosPrincipal) {
+                    validPrincipal = HostnameChecker.match(hostname,
+                            (KerberosPrincipal) peerPrincipal);
+                } else {
+                    // Can't verify principal, not Kerberos
+                }
+            } catch (SSLPeerUnverifiedException ex2) {
+                // Can't verify principal, no principal
+            }
+        }
+
+        return validCertificate || validPrincipal;
+    }
+
+    public boolean verify(String hostname, SSLSession session) {
+        if (hostnameMatches(hostname, session)) {
+            return true;
+        } else {
+            if (extraHostnameVerifier != null) {
+                return extraHostnameVerifier.verify(hostname, session);
+            } else {
+                return false;
+            }
+        }
+    }
+}
From fa056c572ab0c9b6edd05a7cc508898f35cc90d5 Mon Sep 17 00:00:00 2001
From: Will Sargent <will.sargent@gmail.com>
Date: Mon, 24 Mar 2014 23:25:44 -0700
Subject: [PATCH 2/3] Use reflection to avoid the ""not part of JDK"" error
 running tests.
---
 .../AsyncHttpClientConfigBean.java            |  8 +-
 .../util/DefaultHostnameVerifier.java         | 73 ++++++++++++++++---
 2 files changed, 65 insertions(+), 16 deletions(-)",1,java,60.0,api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
cc75fdc3e610985a5f391789d33fb70c8c9114d,sebfz1/wicket-jquery-ui,train,"@@ -16,8 +16,7 @@
 package com.googlecode.wicket.jquery.core.utils;
-import org.apache.wicket.Component;
-import org.apache.wicket.ajax.AjaxRequestTarget;
+import org.apache.wicket.core.request.handler.IPartialPageRequestHandler;
 import org.apache.wicket.event.Broadcast;
 import org.apache.wicket.feedback.FeedbackMessage;
 import org.apache.wicket.markup.html.panel.FeedbackPanel;
@@ -28,6 +27,7 @@ import com.googlecode.wicket.jquery.core.ajax.FeedbackPayload;
+ * 
@@ -41,7 +41,7 @@ import com.googlecode.wicket.jquery.core.ajax.FeedbackPayload;
- *             payload.getTarget().add(this.feedbackPanel);
+ *             payload.getHandler().add(this.feedbackPanel);
@@ -61,224 +61,265 @@ public class FeedbackUtils
 	}
-	// Session based //
-
-	 * Register a debug at session level so the message is available even if the page is redirected
+	 * Aims to reload a {@link FeedbackPanel} using {@link Broadcast#BREADTH} mode.<br>
+	 * The hosting page should implement a code like:<br>
-	 * @param message the message
+	 * <pre>
+	 * <code>
+	 * public void onEvent(IEvent&lt;?&gt; event)
+	 * {
+	 *     super.onEvent(event);
+	 * 
+	 *     if (event.getPayload() instanceof FeedbackPayload)
+	 *     {
+	 *         FeedbackPayload payload = (FeedbackPayload) event.getPayload();
+	 * 
+	 *         if (payload.getLevel() == FeedbackMessage.UNDEFINED)
+	 *         {
+	 *             payload.getHandler().add(this.feedbackPanel);
+	 *         }
+	 *     }
+	 * }
+	 * </code>
+	 * </pre>
+	 * 
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void debug(String message)
+	public static void reload(IPartialPageRequestHandler handler)
 	{
-		WebSession.get().debug(message);
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler));
 	}
-	 * Register an info at session level so the message is available even if the page is redirected
+	 * Register a debug at session level so the message is available even if the page is redirected
-	public static void info(String message)
+	public static void debug(String message)
 	{
-		WebSession.get().info(message);
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
+
+		if (handler != null)
+		{
+			FeedbackUtils.debug(handler, message);
+		}
+		else
+		{
+			WebSession.get().debug(message);
+		}
 	}
-	 * Register a success at session level so the message is available even if the page is redirected
+	 * Sends an ajax {@link FeedbackMessage#DEBUG} message to the hosting page
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void success(String message)
+	public static void debug(IPartialPageRequestHandler handler, String message)
 	{
-		WebSession.get().success(message);
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.DEBUG, message));
 	}
-	 * Register a warn at session level so the message is available even if the page is redirected
+	 * Register an info at session level so the message is available even if the page is redirected
-	 * @param e the {@link Exception}
+	 * @param message the message
-	public static void warn(Exception e)
+	public static void info(String message)
 	{
-		FeedbackUtils.warn(e.getMessage());
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
+
+		if (handler != null)
+		{
+			FeedbackUtils.info(handler, message);
+		}
+		else
+		{
+			WebSession.get().info(message);
+		}
 	}
-	 * Register a warn at session level so the message is available even if the page is redirected
+	 * Sends an ajax {@link FeedbackMessage#INFO} message to the hosting page
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void warn(String message)
+	public static void info(IPartialPageRequestHandler handler, String message)
 	{
-		WebSession.get().warn(message);
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.INFO, message));
 	}
-	 * Register an error at session level so the message is available even if the page is redirected
+	 * Register a success at session level so the message is available even if the page is redirected
-	 * @param e the {@link Exception}
+	 * @param message the message
-	public static void error(Exception e)
+	public static void success(String message)
 	{
-		FeedbackUtils.error(e.getMessage());
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
+
+		if (handler != null)
+		{
+			FeedbackUtils.success(handler, message);
+		}
+		else
+		{
+			WebSession.get().success(message);
+		}
 	}
-	 * Register an error at session level so the message is available even if the page is redirected
+	 * Sends an ajax {@link FeedbackMessage#SUCCESS} message to the hosting page
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void error(String message)
+	public static void success(IPartialPageRequestHandler handler, String message)
 	{
-		WebSession.get().error(message);
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.SUCCESS, message));
 	}
-	 * Register a fatal at session level so the message is available even if the page is redirected
+	 * Register a warn at session level so the message is available even if the page is redirected
-	public static void fatal(Exception e)
+	public static void warn(Exception e)
 	{
-		FeedbackUtils.error(e.getMessage());
+		FeedbackUtils.warn(e.getMessage());
 	}
-	 * Register a fatal at session level so the message is available even if the page is redirected
+	 * Register a warn at session level so the message is available even if the page is redirected
-	public static void fatal(String message)
+	public static void warn(String message)
 	{
-		WebSession.get().fatal(message);
-	}
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
-	// Ajax based //
+		if (handler != null)
+		{
+			FeedbackUtils.warn(handler, message);
+		}
+		else
+		{
+			WebSession.get().warn(message);
+		}
+	}
-	 * Sends an ajax {@link FeedbackMessage#DEBUG} message to the hosting page
+	 * Sends an ajax {@link FeedbackMessage#WARNING} message to the hosting page
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void debug(Component component, AjaxRequestTarget target, String message)
+	public static void warn(IPartialPageRequestHandler handler, String message)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.DEBUG, message));
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.WARNING, message));
 	}
-	 * Sends an ajax {@link FeedbackMessage#INFO} message to the hosting page
+	 * Register an error at session level so the message is available even if the page is redirected
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	 * @param message the message
+	 * @param e the {@link Exception}
-	public static void info(Component component, AjaxRequestTarget target, String message)
+	public static void error(Exception e)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.INFO, message));
+		FeedbackUtils.error(e.getMessage());
 	}
-	 * Sends an ajax {@link FeedbackMessage#SUCCESS} message to the hosting page
+	 * Sends an ajax {@link FeedbackMessage#ERROR} exception message to the hosting page
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	 * @param message the message
+	 * @param handler the {@link IPartialPageRequestHandler}
+	 * @param exception the {@link Exception}
-	public static void success(Component component, AjaxRequestTarget target, String message)
+	public static void error(IPartialPageRequestHandler handler, Exception exception)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.SUCCESS, message));
+		FeedbackUtils.error(handler, exception.getMessage());
 	}
-	 * Sends an ajax {@link FeedbackMessage#WARNING} message to the hosting page
+	 * Register an error at session level so the message is available even if the page is redirected
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	public static void warn(Component component, AjaxRequestTarget target, String message)
+	public static void error(String message)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.WARNING, message));
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
+
+		if (handler != null)
+		{
+			FeedbackUtils.error(handler, message);
+		}
+		else
+		{
+			WebSession.get().error(message);
+		}
 	}
-	 * Sends an ajax {@link FeedbackMessage#ERROR} exception message to the hosting page
+	 * Sends an ajax {@link FeedbackMessage#ERROR} message to the hosting page
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	 * @param exception the {@link Exception}
+	 * @param handler the {@link IPartialPageRequestHandler}
+	 * @param message the message
-	public static void error(Component component, AjaxRequestTarget target, Exception exception)
+	public static void error(IPartialPageRequestHandler handler, String message)
 	{
-		FeedbackUtils.error(component, target, exception.getMessage());
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.ERROR, message));
 	}
-	 * Sends an ajax {@link FeedbackMessage#ERROR} message to the hosting page
+	 * Register a fatal at session level so the message is available even if the page is redirected
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	 * @param message the message
+	 * @param e the {@link Exception}
-	public static void error(Component component, AjaxRequestTarget target, String message)
+	public static void fatal(Exception e)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.ERROR, message));
+		FeedbackUtils.fatal(e.getMessage());
 	}
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
-	public static void fatal(Component component, AjaxRequestTarget target, Exception exception)
+	public static void fatal(IPartialPageRequestHandler handler, Exception exception)
 	{
-		FeedbackUtils.fatal(component, target, exception.getMessage());
+		FeedbackUtils.fatal(handler, exception.getMessage());
 	}
-	 * Sends an ajax {@link FeedbackMessage#FATAL} message to the hosting page
+	 * Register a fatal at session level so the message is available even if the page is redirected
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
-	public static void fatal(Component component, AjaxRequestTarget target, String message)
+	public static void fatal(String message)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.FATAL, message));
+		IPartialPageRequestHandler handler = RequestCycleUtils.getRequestHandler();
+
+		if (handler != null)
+		{
+			FeedbackUtils.fatal(handler, message);
+		}
+		else
+		{
+			WebSession.get().fatal(message);
+		}
 	}
-	 * Aims the reload a {@link FeedbackPanel} using {@link Broadcast#BREADTH} mode.<br>
-	 * The hosting page should implement a code like:<br>
-	 * 
-	 * <pre>
-	 * <code>
-	 * public void onEvent(IEvent&lt;?&gt; event)
-	 * {
-	 *     super.onEvent(event);
-	 * 
-	 *     if (event.getPayload() instanceof FeedbackPayload)
-	 *     {
-	 *         FeedbackPayload payload = (FeedbackPayload) event.getPayload();
-	 * 
-	 *         if (payload.getLevel() == FeedbackMessage.UNDEFINED)
-	 *         {
-	 *             payload.getTarget().add(this.feedbackPanel);
-	 *         }
-	 *     }
-	 * }
-	 * </code>
-	 * </pre>
+	 * Sends an ajax {@link FeedbackMessage#FATAL} message to the hosting page
-	 * @param component the {@link Component} sending the event
-	 * @param target the {@link AjaxRequestTarget}
+	 * @param handler the {@link IPartialPageRequestHandler}
+	 * @param message the message
-	public static void reload(Component component, AjaxRequestTarget target)
+	public static void fatal(IPartialPageRequestHandler handler, String message)
 	{
-		BroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target));
+		BroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.FATAL, message));
 	}
 }",1,java,125.0,FeedbackUtils.java
0a78612f981c541ad2d997e6a365f2a0b3e799d9,cloudfoundry/uaa,train,"@@ -0,0 +1,195 @@
+package org.cloudfoundry.identity.uaa.integration.feature;
+
+import org.cloudfoundry.identity.uaa.ServerRunning;
+import org.cloudfoundry.identity.uaa.constants.OriginKeys;
+import org.cloudfoundry.identity.uaa.integration.util.IntegrationTestUtils;
+import org.cloudfoundry.identity.uaa.integration.util.ScreenshotOnFail;
+import org.cloudfoundry.identity.uaa.login.test.LoginServerClassRunner;
+import org.cloudfoundry.identity.uaa.provider.IdentityProvider;
+import org.cloudfoundry.identity.uaa.provider.LdapIdentityProviderDefinition;
+import org.cloudfoundry.identity.uaa.scim.ScimUser;
+import org.cloudfoundry.identity.uaa.test.UaaTestAccounts;
+import org.hamcrest.Matchers;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.openqa.selenium.By;
+import org.openqa.selenium.WebDriver;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.security.oauth2.client.test.TestAccounts;
+import org.springframework.security.oauth2.common.util.RandomValueStringGenerator;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.web.client.RestOperations;
+import org.springframework.web.client.RestTemplate;
+
+import static org.cloudfoundry.identity.uaa.integration.util.IntegrationTestUtils.doesSupportZoneDNS;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+@RunWith(LoginServerClassRunner.class)
+@ContextConfiguration(classes = DefaultIntegrationTestConfig.class)
+public class LdapLoginIT {
+
+
+
+    @Autowired
+    @Rule
+    public IntegrationTestRule integrationTestRule;
+
+    @Rule
+    public ScreenshotOnFail screenShootRule = new ScreenshotOnFail();
+
+    @Autowired
+    RestOperations restOperations;
+
+    @Autowired
+    WebDriver webDriver;
+
+    @Value(""${integration.test.base_url}"")
+    String baseUrl;
+
+    @Autowired
+    TestClient testClient;
+
+    ServerRunning serverRunning = ServerRunning.isRunning();
+
+
+    @Before
+    public void clearWebDriverOfCookies() throws Exception {
+        screenShootRule.setWebDriver(webDriver);
+        webDriver.get(baseUrl + ""/logout.do"");
+        webDriver.get(baseUrl.replace(""localhost"", ""testzone1.localhost"") + ""/logout.do"");
+        webDriver.get(baseUrl.replace(""localhost"", ""testzone2.localhost"") + ""/logout.do"");
+        webDriver.manage().deleteAllCookies();
+    }
+
+    @Test
+    public void ldapLogin_withValidSelfSignedCert() throws Exception {
+        //ensure we are able to resolve DNS for hostname testzone2.localhost
+        assumeTrue(""Expected testzone1/2/3/4.localhost to resolve to 127.0.0.1"", doesSupportZoneDNS());
+        String zoneId = ""testzone2"";
+        String zoneUrl = baseUrl.replace(""localhost"", ""testzone2.localhost"");
+
+        //identity client token
+        RestTemplate identityClient = IntegrationTestUtils.getClientCredentialsTemplate(
+          IntegrationTestUtils.getClientCredentialsResource(baseUrl, new String[]{""zones.write"", ""zones.read"", ""scim.zones""}, ""identity"", ""identitysecret"")
+        );
+        //admin client token - to create users
+        RestTemplate adminClient = IntegrationTestUtils.getClientCredentialsTemplate(
+          IntegrationTestUtils.getClientCredentialsResource(baseUrl, new String[0], ""admin"", ""adminsecret"")
+        );
+        //create the zone
+        IntegrationTestUtils.createZoneOrUpdateSubdomain(identityClient, baseUrl, zoneId, zoneId);
+
+        //create a zone admin user
+        String email = new RandomValueStringGenerator().generate() +""@samltesting.org"";
+        ScimUser user = IntegrationTestUtils.createUser(adminClient, baseUrl,email ,""firstname"", ""lastname"", email, true);
+        IntegrationTestUtils.makeZoneAdmin(identityClient, baseUrl, user.getId(), zoneId);
+
+        //get the zone admin token
+        String zoneAdminToken =
+          IntegrationTestUtils.getAuthorizationCodeToken(serverRunning,
+            UaaTestAccounts.standard(serverRunning),
+            ""identity"",
+            ""identitysecret"",
+            email,
+            ""secr3T"");
+
+        LdapIdentityProviderDefinition ldapIdentityProviderDefinition = LdapIdentityProviderDefinition.searchAndBindMapGroupToScopes(
+          ""ldaps://52.87.212.253:636/"",
+          ""cn=admin,dc=test,dc=com"",
+          ""password"",
+          ""dc=test,dc=com"",
+          ""cn={0}"",
+          ""ou=scopes,dc=test,dc=com"",
+          ""member={0}"",
+          ""mail"",
+          null,
+          false,
+          true,
+          true,
+          100,
+          false);
+
+        IdentityProvider provider = new IdentityProvider();
+        provider.setIdentityZoneId(zoneId);
+        provider.setType(OriginKeys.LDAP);
+        provider.setActive(true);
+        provider.setConfig(ldapIdentityProviderDefinition);
+        provider.setOriginKey(OriginKeys.LDAP);
+        provider.setName(""simplesamlphp for uaa"");
+        provider = IntegrationTestUtils.createOrUpdateProvider(zoneAdminToken,baseUrl,provider);
+
+        webDriver.get(zoneUrl + ""/login"");
+        webDriver.findElement(By.name(""username"")).sendKeys(""marissa4"");
+        webDriver.findElement(By.name(""password"")).sendKeys(""ldap4"");
+        webDriver.findElement(By.xpath(""//input[@value='Sign in']"")).click();
+        assertThat(webDriver.findElement(By.cssSelector(""h1"")).getText(), Matchers.containsString(""Where to""));
+    }
+
+    @Test
+    public void ldapLogin_withExpiredSelfSignedCert() throws Exception {
+        //ensure we are able to resolve DNS for hostname testzone1.localhost
+        assumeTrue(""Expected testzone1/2/3/4.localhost to resolve to 127.0.0.1"", doesSupportZoneDNS());
+        String zoneId = ""testzone1"";
+        String zoneUrl = baseUrl.replace(""localhost"", ""testzone1.localhost"");
+
+        //identity client token
+        RestTemplate identityClient = IntegrationTestUtils.getClientCredentialsTemplate(
+                IntegrationTestUtils.getClientCredentialsResource(baseUrl, new String[]{""zones.write"", ""zones.read"", ""scim.zones""}, ""identity"", ""identitysecret"")
+        );
+        //admin client token - to create users
+        RestTemplate adminClient = IntegrationTestUtils.getClientCredentialsTemplate(
+                IntegrationTestUtils.getClientCredentialsResource(baseUrl, new String[0], ""admin"", ""adminsecret"")
+        );
+        //create the zone
+        IntegrationTestUtils.createZoneOrUpdateSubdomain(identityClient, baseUrl, zoneId, zoneId);
+
+        //create a zone admin user
+        String email = new RandomValueStringGenerator().generate() +""@samltesting.org"";
+        ScimUser user = IntegrationTestUtils.createUser(adminClient, baseUrl,email ,""firstname"", ""lastname"", email, true);
+        IntegrationTestUtils.makeZoneAdmin(identityClient, baseUrl, user.getId(), zoneId);
+
+        //get the zone admin token
+        String zoneAdminToken =
+                IntegrationTestUtils.getAuthorizationCodeToken(serverRunning,
+                        UaaTestAccounts.standard(serverRunning),
+                        ""identity"",
+                        ""identitysecret"",
+                        email,
+                        ""secr3T"");
+
+        LdapIdentityProviderDefinition ldapIdentityProviderDefinition = LdapIdentityProviderDefinition.searchAndBindMapGroupToScopes(
+                ""ldaps://52.20.5.106:636/"",
+                ""cn=admin,dc=test,dc=com"",
+                ""password"",
+                ""dc=test,dc=com"",
+                ""cn={0}"",
+                ""ou=scopes,dc=test,dc=com"",
+                ""member={0}"",
+                ""mail"",
+                null,
+                false,
+                true,
+                true,
+                100,
+                false);
+
+        IdentityProvider provider = new IdentityProvider();
+        provider.setIdentityZoneId(zoneId);
+        provider.setType(OriginKeys.LDAP);
+        provider.setActive(true);
+        provider.setConfig(ldapIdentityProviderDefinition);
+        provider.setOriginKey(OriginKeys.LDAP);
+        provider.setName(""simplesamlphp for uaa"");
+        provider = IntegrationTestUtils.createOrUpdateProvider(zoneAdminToken,baseUrl,provider);
+
+        webDriver.get(zoneUrl + ""/login"");
+        webDriver.findElement(By.name(""username"")).sendKeys(""marissa4"");
+        webDriver.findElement(By.name(""password"")).sendKeys(""ldap4"");
+        webDriver.findElement(By.xpath(""//input[@value='Sign in']"")).click();
+        assertThat(webDriver.findElement(By.cssSelector(""h1"")).getText(), Matchers.containsString(""Welcome to The Twiglet Zone["" + zoneId + ""]!""));
+    }
+}",1,java,156.0,LdapLoginIT.java
4092ede58da51af9a21e4825fbad0d9a3ef5a223,bcgit/bc-java,train,"@@ -321,12 +321,25 @@ public static int getLeafIndex(long index, int xmssTreeHeight)
         return out.toByteArray();
     }
-    public static Object deserialize(byte[] data)
+    public static Object deserialize(byte[] data, Class clazz)
         throws IOException, ClassNotFoundException
     {
         ByteArrayInputStream in = new ByteArrayInputStream(data);
         ObjectInputStream is = new ObjectInputStream(in);
-        return is.readObject();
+        Object obj = is.readObject();
+
+        if (is.available() != 0)
+        {
+            throw new IOException(""unexpected data found at end of ObjectInputStream"");
+        }
+        if (clazz.isInstance(obj))
+        {
+            return obj;
+        }
+        else
+        {
+            throw new IOException(""unexpected class found in ObjectInputStream"");
+        }
     }
     public static int calculateTau(int index, int height)",1,java,16.0,XMSSUtil.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -8,14 +8,16 @@
 import java.security.KeyStore;
 import javax.crypto.SecretKey;
 import org.cryptacular.CiphertextHeader;
+import org.cryptacular.CiphertextHeaderV2;
 import org.cryptacular.CryptoException;
 import org.cryptacular.EncodingException;
 import org.cryptacular.StreamException;
 import org.cryptacular.generator.Nonce;
+import org.cryptacular.util.CipherUtil;
- * CiphertextHeader} containing metadata that facilitates decryption.
+ * CiphertextHeaderV2} containing metadata that facilitates decryption.
@@ -128,14 +130,14 @@ public void setNonce(final Nonce nonce)
   @Override
   public byte[] encrypt(final byte[] input) throws CryptoException
   {
-    return process(new CiphertextHeader(nonce.generate(), keyAlias), true, input);
+    return process(header(), true, input);
   }
   @Override
   public void encrypt(final InputStream input, final OutputStream output) throws CryptoException, StreamException
   {
-    final CiphertextHeader header = new CiphertextHeader(nonce.generate(), keyAlias);
+    final CiphertextHeaderV2 header = header();
     try {
       output.write(header.encode());
     } catch (IOException e) {
@@ -148,11 +150,7 @@ public void encrypt(final InputStream input, final OutputStream output) throws C
   @Override
   public byte[] decrypt(final byte[] input) throws CryptoException, EncodingException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(input);
-    if (header.getKeyName() == null) {
-      throw new CryptoException(""Ciphertext header does not contain required key"");
-    }
-    return process(header, false, input);
+    return process(CipherUtil.decodeHeader(input, this::lookupKey), false, input);
   }
@@ -160,11 +158,7 @@ public void encrypt(final InputStream input, final OutputStream output) throws C
   public void decrypt(final InputStream input, final OutputStream output)
       throws CryptoException, EncodingException, StreamException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(input);
-    if (header.getKeyName() == null) {
-      throw new CryptoException(""Ciphertext header does not contain required key"");
-    }
-    process(header, false, input, output);
+    process(CipherUtil.decodeHeader(input, this::lookupKey), false, input, output);
   }
@@ -211,4 +205,15 @@ protected SecretKey lookupKey(final String alias)
   protected abstract void process(CiphertextHeader header, boolean mode, InputStream input, OutputStream output);
+
+
+  /**
+   * @return  New ciphertext header for a pending encryption or decryption operation performed by this instance.
+   */
+  private CiphertextHeaderV2 header()
+  {
+    final CiphertextHeaderV2 header = new CiphertextHeaderV2(nonce.generate(), keyAlias);
+    header.setKeyLookup(this::lookupKey);
+    return header;
+  }
 }",1,java,24.0,src/main/java/org/cryptacular/bean/AbstractCipherBean.java
a37b43cca82f108a8e3f5c2803a9b50911a60979,apache/activemq,train,"@@ -99,6 +99,8 @@ public class PolicyEntry extends DestinationMapEntry {
     private boolean reduceMemoryFootprint;
     private NetworkBridgeFilterFactory networkBridgeFilterFactory;
     private boolean doOptimzeMessageStorage = true;
+    private int maxDestinations = -1;
+
@@ -962,4 +964,19 @@ public class PolicyEntry extends DestinationMapEntry {
     public boolean isPersistJMSRedelivered() {
         return persistJMSRedelivered;
     }
+
+    public int getMaxDestinations() {
+        return maxDestinations;
+    }
+
+    /**
+     * Sets the maximum number of destinations that can be created
+     *
+     * @param maxDestinations
+     *            maximum number of destinations
+     */
+    public void setMaxDestinations(int maxDestinations) {
+        this.maxDestinations = maxDestinations;
+    }
+
 }",1,java,8.0,PolicyEntry.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -373,7 +373,7 @@ public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = pipeline();
                 try {
-                    SSLEngine sslEngine = createSSLEngine();
+                    SSLEngine sslEngine = SslUtils.getInstance().createClientSSLEngine(config);
                     SslHandler sslHandler = handshakeTimeoutInMillis > 0 ? new SslHandler(sslEngine, getDefaultBufferPool(), false, ImmediateExecutor.INSTANCE, nettyTimer,
                             handshakeTimeoutInMillis) : new SslHandler(sslEngine);
                     pipeline.addLast(SSL_HANDLER, sslHandler);
@@ -399,7 +399,7 @@ public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = pipeline();
                 try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
                 } catch (Throwable ex) {
                     abort(cl.future(), ex);
                 }
@@ -437,14 +437,6 @@ private Channel lookupInCache(UriComponents uri, ProxyServer proxy, ConnectionPo
         return null;
     }
-    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
-        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
-        if (sslEngine == null) {
-            sslEngine = SslUtils.getSSLEngine();
-        }
-        return sslEngine;
-    }
-
     private HttpClientCodec createHttpClientCodec() {
         return new HttpClientCodec(httpClientCodecMaxInitialLineLength, httpClientCodecMaxHeaderSize, httpClientCodecMaxChunkSize);
     }
@@ -460,7 +452,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
         } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
             return channel;
         } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
         }
         return channel;
     }
@@ -1383,7 +1375,7 @@ private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOExceptio
         if (isSecure(scheme)) {
             if (p.get(SSL_HANDLER) == null) {
                 p.addFirst(HTTP_HANDLER, createHttpClientCodec());
-                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                p.addFirst(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
             } else {
                 p.addAfter(SSL_HANDLER, HTTP_HANDLER, createHttpClientCodec());
             }",1,java,15.0,src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -31,15 +31,9 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.Day;
@@ -54,6 +48,7 @@
 import net.sf.mpxj.ProjectProperties;
 import net.sf.mpxj.RelationType;
 import net.sf.mpxj.Task;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.ganttdesigner.schema.Gantt;
 import net.sf.mpxj.ganttdesigner.schema.GanttDesignerRemark;
 import net.sf.mpxj.listener.ProjectListener;
@@ -83,6 +78,11 @@
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_taskMap = new HashMap<>();
@@ -95,19 +95,7 @@
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Gantt gantt = (Gantt) unmarshaller.unmarshal(doc);
+         Gantt gantt = (Gantt) UnmarshalHelper.unmarshal(CONTEXT, stream);
          readProjectProperties(gantt);
          readCalendar(gantt);",1,java,22.0,src/main/java/net/sf/mpxj/ganttdesigner/GanttDesignerReader.java
f268ab5a00302a89fd0d55cd58d0448402d209a4,jooby-project/jooby,train,"@@ -0,0 +1,229 @@
+/**
+ * Jooby https://jooby.io
+ * Apache License Version 2.0 https://jooby.io/LICENSE.txt
+ * Copyright 2014 Edgar Espina
+ */
+package io.jooby;
+
+import org.unbescape.html.HtmlEscape;
+import org.unbescape.javascript.JavaScriptEscape;
+import org.unbescape.json.JsonEscape;
+import org.unbescape.uri.UriEscape;
+import org.unbescape.xml.XmlEscape;
+
+import javax.annotation.Nullable;
+
+/**
+ * Set of escaping routines for fixing cross-site scripting (XSS).
+ */
+public final class XSS {
+  private XSS() {}
+
+  /**
+   * <p>
+   *   Perform am URI path <strong>escape</strong> operation
+   *   on a <tt>String</tt> input using <tt>UTF-8</tt> as encoding.
+   * </p>
+   * <p>
+   *   The following are the only allowed chars in an URI path (will not be escaped):
+   * </p>
+   * <ul>
+   *   <li><tt>A-Z a-z 0-9</tt></li>
+   *   <li><tt>- . _ ~</tt></li>
+   *   <li><tt>! $ &amp; ' ( ) * + , ; =</tt></li>
+   *   <li><tt>: @</tt></li>
+   *   <li><tt>/</tt></li>
+   * </ul>
+   * <p>
+   *   All other chars will be escaped by converting them to the sequence of bytes that
+   *   represents them in the <tt>UTF-8</tt> and then representing each byte
+   *   in <tt>%HH</tt> syntax, being <tt>HH</tt> the hexadecimal representation of the byte.
+   * </p>
+   * <p>
+   *   This method is <strong>thread-safe</strong>.
+   * </p>
+   *
+   * @param value the <tt>String</tt> to be escaped.
+   * @return The escaped result <tt>String</tt>. As a memory-performance improvement, will return the exact
+   *         same object as the <tt>text</tt> input argument if no escaping modifications were required (and
+   *         no additional <tt>String</tt> objects will be created during processing). Will
+   *         return <tt>null</tt> if input is <tt>null</tt>.
+   */
+  public static @Nullable String uri(@Nullable String value) {
+    return UriEscape.escapeUriPath(value);
+  }
+
+  /**
+   * <p>
+   *   Perform an HTML5 level 2 (result is ASCII) <strong>escape</strong> operation on a <tt>String</tt> input.
+   * </p>
+   * <p>
+   *   <em>Level 2</em> means this method will escape:
+   * </p>
+   * <ul>
+   *   <li>The five markup-significant characters: <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&amp;</tt>,
+   *       <tt>&quot;</tt> and <tt>&#39;</tt></li>
+   *   <li>All non ASCII characters.</li>
+   * </ul>
+   * <p>
+   *   This escape will be performed by replacing those chars by the corresponding HTML5 Named Character References
+   *   (e.g. <tt>'&amp;acute;'</tt>) when such NCR exists for the replaced character, and replacing by a decimal
+   *   character reference (e.g. <tt>'&amp;#8345;'</tt>) when there there is no NCR for the replaced character.
+   * </p>
+   * <p>
+   *   This method is <strong>thread-safe</strong>.
+   * </p>
+   *
+   * @param value the <tt>String</tt> to be escaped.
+   * @return The escaped result <tt>String</tt>. As a memory-performance improvement, will return the exact
+   *         same object as the <tt>text</tt> input argument if no escaping modifications were required (and
+   *         no additional <tt>String</tt> objects will be created during processing). Will
+   *         return <tt>null</tt> if input is <tt>null</tt>.
+   */
+  public static @Nullable String html(@Nullable String value) {
+    return HtmlEscape.escapeHtml5(value);
+  }
+
+  /**
+   * <p>
+   *   Perform a JavaScript level 2 (basic set and all non-ASCII chars) <strong>escape</strong> operation
+   *   on a <tt>String</tt> input.
+   * </p>
+   * <p>
+   *   <em>Level 2</em> means this method will escape:
+   * </p>
+   * <ul>
+   *   <li>The JavaScript basic escape set:
+   *         <ul>
+   *           <li>The <em>Single Escape Characters</em>:
+   *               <tt>&#92;0</tt> (<tt>U+0000</tt>),
+   *               <tt>&#92;b</tt> (<tt>U+0008</tt>),
+   *               <tt>&#92;t</tt> (<tt>U+0009</tt>),
+   *               <tt>&#92;n</tt> (<tt>U+000A</tt>),
+   *               <tt>&#92;v</tt> (<tt>U+000B</tt>),
+   *               <tt>&#92;f</tt> (<tt>U+000C</tt>),
+   *               <tt>&#92;r</tt> (<tt>U+000D</tt>),
+   *               <tt>&#92;&quot;</tt> (<tt>U+0022</tt>),
+   *               <tt>&#92;&#39;</tt> (<tt>U+0027</tt>),
+   *               <tt>&#92;&#92;</tt> (<tt>U+005C</tt>) and
+   *               <tt>&#92;&#47;</tt> (<tt>U+002F</tt>).
+   *               Note that <tt>&#92;&#47;</tt> is optional, and will only be used when the <tt>&#47;</tt>
+   *               symbol appears after <tt>&lt;</tt>, as in <tt>&lt;&#47;</tt>. This is to avoid accidentally
+   *               closing <tt>&lt;script&gt;</tt> tags in HTML. Also, note that <tt>&#92;v</tt>
+   *               (<tt>U+000B</tt>) is actually included as a Single Escape
+   *               Character in the JavaScript (ECMAScript) specification, but will not be used as it
+   *               is not supported by Microsoft Internet Explorer versions &lt; 9.
+   *           </li>
+   *           <li>
+   *               Two ranges of non-displayable, control characters (some of which are already part of the
+   *               <em>single escape characters</em> list): <tt>U+0001</tt> to <tt>U+001F</tt> and
+   *               <tt>U+007F</tt> to <tt>U+009F</tt>.
+   *           </li>
+   *         </ul>
+   *   </li>
+   *   <li>All non ASCII characters.</li>
+   * </ul>
+   * <p>
+   *   This escape will be performed by using the Single Escape Chars whenever possible. For escaped
+   *   characters that do not have an associated SEC, default to using <tt>&#92;xFF</tt> Hexadecimal Escapes
+   *   if possible (characters &lt;= <tt>U+00FF</tt>), then default to <tt>&#92;uFFFF</tt>
+   *   Hexadecimal Escapes. This type of escape <u>produces the smallest escaped string possible</u>.
+   * </p>
+   * <p>
+   *   This method is <strong>thread-safe</strong>.
+   * </p>
+   *
+   * @param value the <tt>String</tt> to be escaped.
+   * @return The escaped result <tt>String</tt>. As a memory-performance improvement, will return the exact
+   *         same object as the <tt>text</tt> input argument if no escaping modifications were required (and
+   *         no additional <tt>String</tt> objects will be created during processing). Will
+   *         return <tt>null</tt> if input is <tt>null</tt>.
+   */
+  public static @Nullable String javaScript(@Nullable String value) {
+    return JavaScriptEscape.escapeJavaScript(value);
+  }
+
+  /**
+   * <p>
+   *   Perform a JSON level 2 (basic set and all non-ASCII chars) <strong>escape</strong> operation
+   *   on a <tt>String</tt> input.
+   * </p>
+   * <p>
+   *   <em>Level 2</em> means this method will escape:
+   * </p>
+   * <ul>
+   *   <li>The JSON basic escape set:
+   *         <ul>
+   *           <li>The <em>Single Escape Characters</em>:
+   *               <tt>&#92;b</tt> (<tt>U+0008</tt>),
+   *               <tt>&#92;t</tt> (<tt>U+0009</tt>),
+   *               <tt>&#92;n</tt> (<tt>U+000A</tt>),
+   *               <tt>&#92;f</tt> (<tt>U+000C</tt>),
+   *               <tt>&#92;r</tt> (<tt>U+000D</tt>),
+   *               <tt>&#92;&quot;</tt> (<tt>U+0022</tt>),
+   *               <tt>&#92;&#92;</tt> (<tt>U+005C</tt>) and
+   *               <tt>&#92;&#47;</tt> (<tt>U+002F</tt>).
+   *               Note that <tt>&#92;&#47;</tt> is optional, and will only be used when the <tt>&#47;</tt>
+   *               symbol appears after <tt>&lt;</tt>, as in <tt>&lt;&#47;</tt>. This is to avoid accidentally
+   *               closing <tt>&lt;script&gt;</tt> tags in HTML.
+   *           </li>
+   *           <li>
+   *               Two ranges of non-displayable, control characters (some of which are already part of the
+   *               <em>single escape characters</em> list): <tt>U+0000</tt> to <tt>U+001F</tt> (required
+   *               by the JSON spec) and <tt>U+007F</tt> to <tt>U+009F</tt> (additional).
+   *           </li>
+   *         </ul>
+   *   </li>
+   *   <li>All non ASCII characters.</li>
+   * </ul>
+   * <p>
+   *   This escape will be performed by using the Single Escape Chars whenever possible. For escaped
+   *   characters that do not have an associated SEC, default to <tt>&#92;uFFFF</tt>
+   *   Hexadecimal Escapes.
+   * </p>
+   * <p>
+   *   This method is <strong>thread-safe</strong>.
+   * </p>
+   *
+   * @param value the <tt>String</tt> to be escaped.
+   * @return The escaped result <tt>String</tt>. As a memory-performance improvement, will return the exact
+   *         same object as the <tt>text</tt> input argument if no escaping modifications were required (and
+   *         no additional <tt>String</tt> objects will be created during processing). Will
+   *         return <tt>null</tt> if input is <tt>null</tt>.
+   */
+  public static @Nullable String json(@Nullable String value) {
+    return JsonEscape.escapeJson(value);
+  }
+
+  /**
+   * <p>
+   *   Perform an XML 1.1 level 2 (markup-significant and all non-ASCII chars) <strong>escape</strong> operation
+   *   on a <tt>String</tt> input.
+   * </p>
+   * <p>
+   *   <em>Level 2</em> means this method will escape:
+   * </p>
+   * <ul>
+   *   <li>The five markup-significant characters: <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&amp;</tt>,
+   *       <tt>&quot;</tt> and <tt>&#39;</tt></li>
+   *   <li>All non ASCII characters.</li>
+   * </ul>
+   * <p>
+   *   This escape will be performed by replacing those chars by the corresponding XML Character Entity References
+   *   (e.g. <tt>'&amp;lt;'</tt>) when such CER exists for the replaced character, and replacing by a hexadecimal
+   *   character reference (e.g. <tt>'&amp;#x2430;'</tt>) when there there is no CER for the replaced character.
+   * </p>
+   * <p>
+   *   This method is <strong>thread-safe</strong>.
+   * </p>
+   *
+   * @param value the <tt>String</tt> to be escaped.
+   * @return The escaped result <tt>String</tt>. As a memory-performance improvement, will return the exact
+   *         same object as the <tt>text</tt> input argument if no escaping modifications were required (and
+   *         no additional <tt>String</tt> objects will be created during processing). Will
+   *         return <tt>null</tt> if input is <tt>null</tt>.
+   */
+  public static @Nullable String xml(@Nullable String value) {
+    return XmlEscape.escapeXml11(value);
+  }
+}
",1,java,26.0,XSS.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,train,"@@ -0,0 +1,61 @@
+package org.jooby.issues;
+
+import org.jooby.test.ServerFeature;
+import org.junit.Test;
+
+public class Issue453 extends ServerFeature {
+
+  public static class Form {
+    public String text;
+  }
+
+  {
+    get(""/453"", req -> {
+      return req.param(""text"", ""html"").value();
+    });
+
+    get(""/453/h"", req -> {
+      return req.header(""text"", ""html"").value();
+    });
+
+    get(""/453/escape-form"", req -> {
+      return req.params(Form.class, req.param(""xss"").value(""html"")).text;
+    });
+
+    get(""/453/to-escape-form"", req -> {
+      return req.params(req.param(""xss"").value(""html"")).to(Form.class).text;
+    });
+
+    err((req, rsp, x) -> {
+      rsp.send(x.toMap().get(""message""));
+    });
+  }
+
+  @Test
+  public void escape() throws Exception {
+    request()
+        .get(""/453?text=%3Ch1%3EX%3C/h1%3E"")
+        .expect(""&lt;h1&gt;X&lt;/h1&gt;"");
+
+    request()
+        .get(""/453/h"")
+        .header(""text"", ""<h1>X</h1>"")
+        .expect(""&lt;h1&gt;X&lt;/h1&gt;"");
+  }
+
+  @Test
+  public void escapeForm() throws Exception {
+    request()
+        .get(""/453/escape-form?text=%3Ch1%3EX%3C/h1%3E"")
+        .expect(""&lt;h1&gt;X&lt;/h1&gt;"");
+
+    request()
+        .get(""/453/escape-form?text=%3Ch1%3EX%3C/h1%3E&xss=none"")
+        .expect(""<h1>X</h1>"");
+
+    request()
+        .get(""/453/to-escape-form?text=%3Ch1%3EX%3C/h1%3E"")
+        .expect(""&lt;h1&gt;X&lt;/h1&gt;"");
+  }
+
+}
",1,java,48.0,Issue453.java
1117a37b01a1058897a34e11ff5156e465efb69,apache/storm,train,"@@ -32,14 +32,19 @@ import java.io.PrintStream;
 import java.io.RandomAccessFile;
 import java.nio.file.FileSystems;
 import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.zip.GZIPInputStream;
@@ -378,52 +383,9 @@ public class ServerUtils {
-    public static void unJar(File jarFile, File toDir)
-        throws IOException {
-        JarFile jar = new JarFile(jarFile);
-        try {
-            Enumeration<JarEntry> entries = jar.entries();
-            while (entries.hasMoreElements()) {
-                final JarEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = jar.getInputStream(entry);
-                    try {
-                        File file = new File(toDir, entry.getName());
-                        ensureDirectory(file.getParentFile());
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            copyBytes(in, out, 8192);
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            jar.close();
-        }
-    }
-
-    /**
-     * Copies from one stream to another.
-     *
-     * @param in       InputStream to read from
-     * @param out      OutputStream to write to
-     * @param buffSize the size of the buffer
-     */
-    public static void copyBytes(InputStream in, OutputStream out, int buffSize)
-        throws IOException {
-        PrintStream ps = out instanceof PrintStream ? (PrintStream) out : null;
-        byte buf[] = new byte[buffSize];
-        int bytesRead = in.read(buf);
-        while (bytesRead >= 0) {
-            out.write(buf, 0, bytesRead);
-            if ((ps != null) && ps.checkError()) {
-                throw new IOException(""Unable to write to output stream."");
-            }
-            bytesRead = in.read(buf);
+    public static void unJar(File jarFile, File toDir) throws IOException {
+        try (JarFile jar = new JarFile(jarFile)) {
+            extractZipFile(jar, toDir, null);
         }
     }
@@ -446,20 +408,17 @@ public class ServerUtils {
+     * @param symlinksDisabled true if symlinks should be disabled, else false.
-    public static void unTar(File inFile, File untarDir) throws IOException {
-        if (!untarDir.mkdirs()) {
-            if (!untarDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create "" + untarDir);
-            }
-        }
+    public static void unTar(File inFile, File untarDir, boolean symlinksDisabled) throws IOException {
+        ensureDirectory(untarDir);
         boolean gzipped = inFile.toString().endsWith(""gz"");
-        if (Utils.isOnWindows()) {
+        if (Utils.isOnWindows() || symlinksDisabled) {
-            unTarUsingJava(inFile, untarDir, gzipped);
+            unTarUsingJava(inFile, untarDir, gzipped, symlinksDisabled);
         } else {
@@ -496,7 +455,9 @@ public class ServerUtils {
     }
     private static void unTarUsingJava(File inFile, File untarDir,
-                                       boolean gzipped) throws IOException {
+                                       boolean gzipped, boolean symlinksDisabled) throws IOException {
+        final String base = untarDir.getCanonicalPath();
+        LOG.trace(""java untar {} to {}"", inFile, base);
         InputStream inputStream = null;
         try {
             if (gzipped) {
@@ -507,7 +468,7 @@ public class ServerUtils {
             }
             try (TarArchiveInputStream tis = new TarArchiveInputStream(inputStream)) {
                 for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null; ) {
-                    unpackEntries(tis, entry, untarDir);
+                    unpackEntries(tis, entry, untarDir, base, symlinksDisabled);
                     entry = tis.getNextTarEntry();
                 }
             }
@@ -519,47 +480,99 @@ public class ServerUtils {
     }
     private static void unpackEntries(TarArchiveInputStream tis,
-                                      TarArchiveEntry entry, File outputDir) throws IOException {
+                                      TarArchiveEntry entry, File outputDir, final String base,
+                                      boolean symlinksDisabled) throws IOException {
+        File target = new File(outputDir, entry.getName());
+        String found = target.getCanonicalPath();
+        if (!found.startsWith(base)) {
+            LOG.error(""Invalid location {} is outside of {}"", found, base);
+            return;
+        }
         if (entry.isDirectory()) {
-            File subDir = new File(outputDir, entry.getName());
-            if (!subDir.mkdirs() && !subDir.isDirectory()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                                      + outputDir);
-            }
+            LOG.trace(""Extracting dir {}"", target);
+            ensureDirectory(target);
             for (TarArchiveEntry e : entry.getDirectoryEntries()) {
-                unpackEntries(tis, e, subDir);
+                unpackEntries(tis, e, target, base, symlinksDisabled);
             }
-            return;
+        } else if (entry.isSymbolicLink()) {
+            if (symlinksDisabled) {
+                LOG.info(""Symlinks disabled skipping {}"", target);
+            } else {
+                Path src = target.toPath();
+                Path dest = Paths.get(entry.getLinkName());
+                LOG.trace(""Extracting sym link {} to {}"", target, dest);
+                // Create symbolic link relative to tar parent dir
+                Files.createSymbolicLink(src, dest);
+            }
+        } else if (entry.isFile()) {
+            LOG.trace(""Extracting file {}"", target);
+            ensureDirectory(target.getParentFile());
+            try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target))) {
+                IOUtils.copy(tis, outputStream);
+            }
+        } else {
+            LOG.error(""{} is not a currently supported tar entry type."", entry);
         }
-        File outputFile = new File(outputDir, entry.getName());
-        if (!outputFile.getParentFile().exists()) {
-            if (!outputFile.getParentFile().mkdirs()) {
-                throw new IOException(""Mkdirs failed to create tar internal dir ""
-                                      + outputDir);
+
+        Path p = target.toPath();
+        if (Files.exists(p)) {
+            try {
+                //We created it so lets chmod it properly
+                int mode = entry.getMode();
+                Files.setPosixFilePermissions(p, parsePerms(mode));
+            } catch (UnsupportedOperationException e) {
+                //Ignored the file system we are on does not support this, so don't do it.
             }
         }
-        int count;
-        byte data[] = new byte[2048];
-        BufferedOutputStream outputStream = new BufferedOutputStream(
-            new FileOutputStream(outputFile));
+    }
-        while ((count = tis.read(data)) != -1) {
-            outputStream.write(data, 0, count);
+    private static Set<PosixFilePermission> parsePerms(int mode) {
+        Set<PosixFilePermission> ret = new HashSet<>();
+        if ((mode & 0001) > 0) {
+            ret.add(PosixFilePermission.OTHERS_EXECUTE);
+        }
+        if ((mode & 0002) > 0) {
+            ret.add(PosixFilePermission.OTHERS_WRITE);
+        }
+        if ((mode & 0004) > 0) {
+            ret.add(PosixFilePermission.OTHERS_READ);
+        }
+        if ((mode & 0010) > 0) {
+            ret.add(PosixFilePermission.GROUP_EXECUTE);
         }
-        outputStream.flush();
-        outputStream.close();
+        if ((mode & 0020) > 0) {
+            ret.add(PosixFilePermission.GROUP_WRITE);
+        }
+        if ((mode & 0040) > 0) {
+            ret.add(PosixFilePermission.GROUP_READ);
+        }
+        if ((mode & 0100) > 0) {
+            ret.add(PosixFilePermission.OWNER_EXECUTE);
+        }
+        if ((mode & 0200) > 0) {
+            ret.add(PosixFilePermission.OWNER_WRITE);
+        }
+        if ((mode & 0400) > 0) {
+            ret.add(PosixFilePermission.OWNER_READ);
+        }
+        return ret;
     }
-    public static void unpack(File localrsrc, File dst) throws IOException {
+    public static void unpack(File localrsrc, File dst, boolean symLinksDisabled) throws IOException {
         String lowerDst = localrsrc.getName().toLowerCase();
-        if (lowerDst.endsWith("".jar"")) {
+        if (lowerDst.endsWith("".jar"") ||
+            lowerDst.endsWith(""_jar"")) {
             unJar(localrsrc, dst);
-        } else if (lowerDst.endsWith("".zip"")) {
+        } else if (lowerDst.endsWith("".zip"") ||
+            lowerDst.endsWith(""_zip"")) {
             unZip(localrsrc, dst);
         } else if (lowerDst.endsWith("".tar.gz"") ||
-                   lowerDst.endsWith("".tgz"") ||
-                   lowerDst.endsWith("".tar"")) {
-            unTar(localrsrc, dst);
+            lowerDst.endsWith(""_tar_gz"") ||
+            lowerDst.endsWith("".tgz"") ||
+            lowerDst.endsWith(""_tgz"") ||
+            lowerDst.endsWith("".tar"") ||
+            lowerDst.endsWith(""_tar"")) {
+            unTar(localrsrc, dst, symLinksDisabled);
         } else {
             LOG.warn(""Cannot unpack "" + localrsrc);
             if (!localrsrc.renameTo(dst)) {
@@ -572,48 +585,45 @@ public class ServerUtils {
         }
     }
+    private static void extractZipFile(ZipFile zipFile, File toDir, String prefix) throws IOException {
+        ensureDirectory(toDir);
+        final String base = toDir.getCanonicalPath();
+
+        Enumeration<? extends ZipEntry> entries = zipFile.entries();
+        while (entries.hasMoreElements()) {
+            ZipEntry entry = entries.nextElement();
+            if (!entry.isDirectory()) {
+                if (prefix != null && !entry.getName().startsWith(prefix)) {
+                    //No need to extract it, it is not what we are looking for.
+                    continue;
+                }
+                File file = new File(toDir, entry.getName());
+                String found = file.getCanonicalPath();
+                if (!found.startsWith(base)) {
+                    LOG.error(""Invalid location {} is outside of {}"", found, base);
+                    continue;
+                }
+
+                try (InputStream in = zipFile.getInputStream(entry)) {
+                    ensureDirectory(file.getParentFile());
+                    try (OutputStream out = new FileOutputStream(file)) {
+                        IOUtils.copy(in, out);
+                    }
+                }
+            }
+        }
+    }
+
-     * Given a File input it will unzip the file in a the unzip directory passed as the second parameter
+     * Given a File input it will unzip the file in a the unzip directory passed as the second parameter.
-     * @param unzipDir The unzip directory where to unzip the zip file.
+     * @param toDir The unzip directory where to unzip the zip file.
-    public static void unZip(File inFile, File unzipDir) throws IOException {
-        Enumeration<? extends ZipEntry> entries;
-        ZipFile zipFile = new ZipFile(inFile);
-
-        try {
-            entries = zipFile.entries();
-            while (entries.hasMoreElements()) {
-                ZipEntry entry = entries.nextElement();
-                if (!entry.isDirectory()) {
-                    InputStream in = zipFile.getInputStream(entry);
-                    try {
-                        File file = new File(unzipDir, entry.getName());
-                        if (!file.getParentFile().mkdirs()) {
-                            if (!file.getParentFile().isDirectory()) {
-                                throw new IOException(""Mkdirs failed to create "" +
-                                                      file.getParentFile().toString());
-                            }
-                        }
-                        OutputStream out = new FileOutputStream(file);
-                        try {
-                            byte[] buffer = new byte[8192];
-                            int i;
-                            while ((i = in.read(buffer)) != -1) {
-                                out.write(buffer, 0, i);
-                            }
-                        } finally {
-                            out.close();
-                        }
-                    } finally {
-                        in.close();
-                    }
-                }
-            }
-        } finally {
-            zipFile.close();
+    public static void unZip(File inFile, File toDir) throws IOException {
+        try (ZipFile zipFile = new ZipFile(inFile)) {
+            extractZipFile(zipFile, toDir, null);
         }
     }
@@ -741,18 +751,7 @@ public class ServerUtils {
     public void extractDirFromJarImpl(String jarpath, String dir, File destdir) {
         try (JarFile jarFile = new JarFile(jarpath)) {
-            Enumeration<JarEntry> jarEnums = jarFile.entries();
-            while (jarEnums.hasMoreElements()) {
-                JarEntry entry = jarEnums.nextElement();
-                if (!entry.isDirectory() && entry.getName().startsWith(dir)) {
-                    File aFile = new File(destdir, entry.getName());
-                    aFile.getParentFile().mkdirs();
-                    try (FileOutputStream out = new FileOutputStream(aFile);
-                         InputStream in = jarFile.getInputStream(entry)) {
-                        IOUtils.copy(in, out);
-                    }
-                }
-            }
+            extractZipFile(jarFile, destdir, dir);
         } catch (IOException e) {
             LOG.info(""Could not extract {} from {}"", dir, jarpath);
         }",1,java,241.0,ServerUtils.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,train,"@@ -26,6 +26,12 @@ private BigInteger validate(BigInteger y, DHParameters dhParams)
             throw new NullPointerException(""y value cannot be null"");
         }
+        // TLS check
+        if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)
+        {
+            throw new IllegalArgumentException(""invalid DH public key"");
+        }
+
         if (dhParams.getQ() != null)
         {
             if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))
@@ -37,12 +43,6 @@ private BigInteger validate(BigInteger y, DHParameters dhParams)
         }
         else
         {
-            // TLS check
-            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)
-            {
-                throw new IllegalArgumentException(""invalid DH public key"");
-            }
-
             return y;         // we can't validate without Q.
         }
     }",1,java,8.0,DHPublicKeyParameters.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -1526,6 +1526,14 @@ public void setMaxResultBuffer(String maxResultBuffer) {
     return Logger.getLogger(""org.postgresql"");
   }
+  public String getXmlFactoryFactory() {
+    return PGProperty.XML_FACTORY_FACTORY.get(properties);
+  }
+
+  public void setXmlFactoryFactory(String xmlFactoryFactory) {
+    PGProperty.XML_FACTORY_FACTORY.set(properties, xmlFactoryFactory);
+  }
+",1,java,7.0,pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -4,17 +4,8 @@ import uk.gov.hmcts.ccd.domain.model.draft.DraftResponse;
 import uk.gov.hmcts.ccd.domain.model.std.CaseDataContent;
 
 public interface UpsertDraftOperation {
-    DraftResponse executeSave(String uid,
-                              String jurisdictionId,
-                              String caseTypeId,
-                              String eventTriggerId,
-                              CaseDataContent caseDataContent);
+    DraftResponse executeSave(String caseTypeId, CaseDataContent caseDataContent);
 
-    DraftResponse executeUpdate(String uid,
-                        String jurisdictionId,
-                        String caseTypeId,
-                        String eventTriggerId,
-                        String draftId,
-                        CaseDataContent caseDataContent);
+    DraftResponse executeUpdate(String caseTypeId, String draftId, CaseDataContent caseDataContent);
 
 }
",1,java,13.0,UpsertDraftOperation.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -121,4 +121,8 @@ public static boolean defaultRemoveQueryParamOnRedirect() {
     public static HostnameVerifier defaultHostnameVerifier() {
         return new DefaultHostnameVerifier();
     }
+    
+    public static boolean defaultAcceptAnyCertificate() {
+        return getBoolean(ASYNC_CLIENT + ""acceptAnyCertificate"", false);
+    }
 }",1,java,4.0,src/main/java/com/ning/http/client/AsyncHttpClientConfigDefaults.java
1a1d6ca1bc3ae840238dc345fa1eb2c7c28c8cb,apache/hive,train,"@@ -0,0 +1,253 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.ql.security.authorization.plugin.fallback;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hadoop.hive.ql.parse.SemanticException;
+import org.apache.hadoop.hive.ql.security.HiveAuthenticationProvider;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.AbstractHiveAuthorizer;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.DisallowTransformHook;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAccessControlException;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthzContext;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthzPluginException;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveAuthzSessionContext;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveOperationType;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HivePrincipal;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HivePrivilege;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HivePrivilegeInfo;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HivePrivilegeObject;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.HiveRoleGrant;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.SettableConfigUpdater;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.Operation2Privilege;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLAuthorizationUtils;
+import org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLPrivTypeGrant;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class FallbackHiveAuthorizer extends AbstractHiveAuthorizer {
+  private static final Log LOG = LogFactory.getLog(FallbackHiveAuthorizer.class);
+
+  private final HiveAuthzSessionContext sessionCtx;
+  private final HiveAuthenticationProvider authenticator;
+  private String[] admins = null;
+
+  FallbackHiveAuthorizer(HiveConf hiveConf, HiveAuthenticationProvider hiveAuthenticator,
+                                HiveAuthzSessionContext ctx) {
+    this.authenticator = hiveAuthenticator;
+    this.sessionCtx = applyTestSettings(ctx, hiveConf);
+    String adminString = hiveConf.getVar(HiveConf.ConfVars.USERS_IN_ADMIN_ROLE);
+    if (adminString != null) {
+      admins = hiveConf.getVar(HiveConf.ConfVars.USERS_IN_ADMIN_ROLE).split("","");
+    }
+  }
+
+  /**
+   * Change the session context based on configuration to aid in testing of sql
+   * std auth
+   *
+   * @param ctx
+   * @param conf
+   * @return
+   */
+  static HiveAuthzSessionContext applyTestSettings(HiveAuthzSessionContext ctx, HiveConf conf) {
+    if (conf.getBoolVar(HiveConf.ConfVars.HIVE_TEST_AUTHORIZATION_SQLSTD_HS2_MODE)
+            && ctx.getClientType() == HiveAuthzSessionContext.CLIENT_TYPE.HIVECLI) {
+      // create new session ctx object with HS2 as client type
+      HiveAuthzSessionContext.Builder ctxBuilder = new HiveAuthzSessionContext.Builder(ctx);
+      ctxBuilder.setClientType(HiveAuthzSessionContext.CLIENT_TYPE.HIVESERVER2);
+      return ctxBuilder.build();
+    }
+    return ctx;
+  }
+
+  @Override
+  public VERSION getVersion() {
+    return VERSION.V1;
+  }
+
+  @Override
+  public void grantPrivileges(List<HivePrincipal> hivePrincipals, List<HivePrivilege> hivePrivileges,
+                              HivePrivilegeObject hivePrivObject, HivePrincipal grantorPrincipal, boolean
+                                        grantOption) throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""grantPrivileges not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void revokePrivileges(List<HivePrincipal> hivePrincipals, List<HivePrivilege> hivePrivileges,
+                               HivePrivilegeObject hivePrivObject, HivePrincipal grantorPrincipal, boolean
+                                         grantOption) throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""revokePrivileges not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void createRole(String roleName, HivePrincipal adminGrantor) throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""createRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void dropRole(String roleName) throws HiveAuthzPluginException, HiveAccessControlException {
+    throw new HiveAuthzPluginException(""dropRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public List<HiveRoleGrant> getPrincipalGrantInfoForRole(String roleName) throws HiveAuthzPluginException,
+          HiveAccessControlException {
+    throw new HiveAuthzPluginException(""getPrincipalGrantInfoForRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public List<HiveRoleGrant> getRoleGrantInfoForPrincipal(HivePrincipal principal) throws HiveAuthzPluginException,
+          HiveAccessControlException {
+    throw new HiveAuthzPluginException(""getRoleGrantInfoForPrincipal not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void grantRole(List<HivePrincipal> hivePrincipals, List<String> roles, boolean grantOption, HivePrincipal
+          grantorPrinc) throws HiveAuthzPluginException, HiveAccessControlException {
+    throw new HiveAuthzPluginException(""grantRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void revokeRole(List<HivePrincipal> hivePrincipals, List<String> roles, boolean grantOption, HivePrincipal
+          grantorPrinc) throws HiveAuthzPluginException, HiveAccessControlException {
+    throw new HiveAuthzPluginException(""revokeRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> inputHObjs,
+                              List<HivePrivilegeObject> outputHObjs, HiveAuthzContext context) throws
+          HiveAuthzPluginException, HiveAccessControlException {
+    String userName = authenticator.getUserName();
+    // check privileges on input and output objects
+    List<String> deniedMessages = new ArrayList<>();
+    checkPrivileges(hiveOpType, inputHObjs, userName, Operation2Privilege.IOType.INPUT, deniedMessages);
+    checkPrivileges(hiveOpType, outputHObjs, userName, Operation2Privilege.IOType.OUTPUT, deniedMessages);
+
+    SQLAuthorizationUtils.assertNoDeniedPermissions(new HivePrincipal(userName,
+            HivePrincipal.HivePrincipalType.USER), hiveOpType, deniedMessages);
+  }
+
+  // Adapted from SQLStdHiveAuthorizationValidator, only check privileges for LOAD/ADD/DFS/COMPILE and admin privileges
+  private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,
+                               String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {
+
+    if (hiveObjects == null) {
+      return;
+    }
+    if (admins != null && Arrays.stream(admins).parallel().anyMatch(n -> n.equals(userName))) {
+      return; // Skip rest of checks if user is admin
+    }
+
+    // Special-casing for ADMIN-level operations that do not require object checking.
+    if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {
+      // Require ADMIN privilege
+      deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + "" on "" + ioType);
+      return; // Ignore object, fail if not admin, succeed if admin.
+    }
+
+    boolean needAdmin = false;
+    for (HivePrivilegeObject hiveObj : hiveObjects) {
+      // If involving local file system
+      if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {
+        needAdmin = true;
+        break;
+      }
+    }
+    if (!needAdmin) {
+      switch (hiveOpType) {
+        case ADD:
+        case DFS:
+        case COMPILE:
+          needAdmin = true;
+          break;
+        default:
+          break;
+      }
+    }
+    if (needAdmin) {
+      deniedMessages.add(""ADMIN"");
+    }
+  }
+
+  @Override
+  public List<HivePrivilegeObject> filterListCmdObjects(List<HivePrivilegeObject> listObjs, HiveAuthzContext context) {
+    return listObjs;
+  }
+
+  @Override
+  public List<String> getAllRoles() throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""getAllRoles not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public List<HivePrivilegeInfo> showPrivileges(HivePrincipal principal, HivePrivilegeObject privObj) throws
+          HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""showPrivileges not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void setCurrentRole(String roleName) throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""setCurrentRole not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public List<String> getCurrentRoleNames() throws HiveAuthzPluginException {
+    throw new HiveAuthzPluginException(""getCurrentRoleNames not implemented in FallbackHiveAuthorizer"");
+  }
+
+  @Override
+  public void applyAuthorizationConfigPolicy(HiveConf hiveConf) throws HiveAuthzPluginException {
+    // from SQLStdHiveAccessController.applyAuthorizationConfigPolicy()
+    if (sessionCtx.getClientType() == HiveAuthzSessionContext.CLIENT_TYPE.HIVESERVER2
+            && hiveConf.getBoolVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_ENABLED)) {
+
+      // Configure PREEXECHOOKS with DisallowTransformHook to disallow transform queries
+      String hooks = hiveConf.getVar(HiveConf.ConfVars.PREEXECHOOKS).trim();
+      if (hooks.isEmpty()) {
+        hooks = DisallowTransformHook.class.getName();
+      } else {
+        hooks = hooks + "","" + DisallowTransformHook.class.getName();
+      }
+      LOG.debug(""Configuring hooks : "" + hooks);
+      hiveConf.setVar(HiveConf.ConfVars.PREEXECHOOKS, hooks);
+
+      SettableConfigUpdater.setHiveConfWhiteList(hiveConf);
+      String curBlackList = hiveConf.getVar(HiveConf.ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST);
+      if (curBlackList != null && curBlackList.trim().equals(""reflect,reflect2,java_method"")) {
+        hiveConf.setVar(HiveConf.ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, ""reflect,reflect2,java_method,in_file"");
+      }
+
+    }
+  }
+
+  @Override
+  public List<HivePrivilegeObject> applyRowFilterAndColumnMasking(HiveAuthzContext context, List<HivePrivilegeObject>
+          privObjs) throws SemanticException {
+    return privObjs;
+  }
+
+  @Override
+  public boolean needTransform() {
+    return false;
+  }
+}",1,java,188.0,FallbackHiveAuthorizer.java
e6aa166246d1734f4798a9e31f78842f4c85c28b,jenkinsci/jenkins,train,"@@ -1,9 +1,15 @@
 package jenkins.security;
+import hudson.Main;
 import hudson.util.Secret;
+import jenkins.model.Jenkins;
+import org.kohsuke.accmod.Restricted;
+import org.kohsuke.accmod.restrictions.DoNotUse;
+import org.kohsuke.accmod.restrictions.NoExternalUse;
 import javax.crypto.Cipher;
 import javax.crypto.SecretKey;
+import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
@@ -15,6 +21,9 @@
 public class CryptoConfidentialKey extends ConfidentialKey {
+    @Restricted(NoExternalUse.class) //TODO remove when in mainline
+    public static final int DEFAULT_IV_LENGTH = 16;
+
     private volatile SecretKey secret;
     public CryptoConfidentialKey(String id) {
         super(id);
@@ -35,7 +44,7 @@ private SecretKey getKey() {
                             store(payload);
                         }
-                        secret = new SecretKeySpec(payload,0,128/8, ALGORITHM);
+                        secret = new SecretKeySpec(payload,0,128/8, KEY_ALGORITHM);
                     }
                 }
             }
@@ -47,10 +56,12 @@ private SecretKey getKey() {
+     * @deprecated use {@link #encrypt(byte[])}
+    @Deprecated
     public Cipher encrypt() {
         try {
-            Cipher cipher = Secret.getCipher(ALGORITHM);
+            Cipher cipher = Secret.getCipher(KEY_ALGORITHM);
             cipher.init(Cipher.ENCRYPT_MODE, getKey());
             return cipher;
         } catch (GeneralSecurityException e) {
@@ -58,12 +69,68 @@ public Cipher encrypt() {
         }
     }
+    /**
+     * Returns a {@link Cipher} object for encrypting with this key using the provided initialization vector.
+     * @param iv the initialization vector
+     * @return the cipher
+     */
+    @Restricted(NoExternalUse.class) //TODO remove when in mainline
+    public Cipher encrypt(byte[] iv) {
+        try {
+            Cipher cipher = Secret.getCipher(ALGORITHM);
+            cipher.init(Cipher.ENCRYPT_MODE, getKey(), new IvParameterSpec(iv));
+            return cipher;
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Returns a {@link Cipher} object for decrypting with this key using the provided initialization vector.
+     * @param iv the initialization vector
+     * @return the cipher
+     */
+    @Restricted(NoExternalUse.class) //TODO remove when in mainline
+    public Cipher decrypt(byte[] iv) {
+        try {
+            Cipher cipher = Secret.getCipher(ALGORITHM);
+            cipher.init(Cipher.DECRYPT_MODE, getKey(), new IvParameterSpec(iv));
+            return cipher;
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    /**
+     * Generates a new Initialization Vector.
+     * @param length the length of the salt
+     * @return some random bytes
+     * @see #encrypt(byte[])
+     */
+    @Restricted(NoExternalUse.class) //TODO remove when in mainline
+    public byte[] newIv(int length) {
+        return ConfidentialStore.get().randomBytes(length);
+    }
+
+    /**
+     * Generates a new Initialization Vector of default length.
+     * @return some random bytes
+     * @see #newIv(int)
+     * @see #encrypt(byte[])
+     */
+    @Restricted(NoExternalUse.class) //TODO remove when in mainline
+    public byte[] newIv() {
+        return newIv(DEFAULT_IV_LENGTH);
+    }
+
+     * @deprecated use {@link #decrypt(byte[])}
+    @Deprecated
     public Cipher decrypt() {
         try {
-            Cipher cipher = Secret.getCipher(ALGORITHM);
+            Cipher cipher = Secret.getCipher(KEY_ALGORITHM);
             cipher.init(Cipher.DECRYPT_MODE, getKey());
             return cipher;
         } catch (GeneralSecurityException e) {
@@ -72,5 +139,18 @@ public Cipher decrypt() {
     }
-    private static final String ALGORITHM = ""AES"";
+    private static final String KEY_ALGORITHM = ""AES"";
+    private static final String ALGORITHM = ""AES/CBC/PKCS5Padding"";
+
+    /**
+     * Reset the internal secret key for testing.
+     */
+    @Restricted(NoExternalUse.class)
+    public void resetForTest() {
+        if (Main.isUnitTest) {
+            this.secret = null;
+        } else {
+            throw new IllegalStateException(""Only for testing"");
+        }
+    }
 }",1,java,55.0,core/src/main/java/jenkins/security/CryptoConfidentialKey.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -134,4 +134,8 @@ public class CaseType implements Serializable {
             .stream()
             .anyMatch(caseEvent -> caseEvent.getCanSaveDraft() != null && caseEvent.getCanSaveDraft());
     }
+
+    public boolean hasEventId(String eventId) {
+        return events.stream().anyMatch(event -> event.getId().equals(eventId));
+    }
 }
",1,java,4.0,CaseType.java
0a78612f981c541ad2d997e6a365f2a0b3e799d9,cloudfoundry/uaa,train,"@@ -14,6 +14,8 @@
 package org.cloudfoundry.identity.uaa.provider.ldap;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -21,6 +23,7 @@ public class ProcessLdapProperties {
     public static final String LDAP_SOCKET_FACTORY = ""java.naming.ldap.factory.socket"";
     public static final String SKIP_SSL_VERIFICATION_SOCKET_FACTORY = ""org.apache.directory.api.util.DummySSLSocketFactory"";
+    public static final String EXPIRY_CHECKING_SOCKET_FACTORY = ""org.cloudfoundry.identity.uaa.security.LdapSocketFactory"";
     private boolean disableSslVerification;
     private String baseUrl;
@@ -30,10 +33,14 @@ public class ProcessLdapProperties {
         this.disableSslVerification = disableSslVerification;
     }
-    public Map process(Map map) {
+    public Map process(Map map) throws KeyManagementException, NoSuchAlgorithmException {
         Map result = new LinkedHashMap(map);
-        if (isDisableSslVerification() && isLdapsUrl()) {
-            result.put(LDAP_SOCKET_FACTORY, SKIP_SSL_VERIFICATION_SOCKET_FACTORY);
+        if(isLdapsUrl()) {
+            if (isDisableSslVerification()) {
+                result.put(LDAP_SOCKET_FACTORY, SKIP_SSL_VERIFICATION_SOCKET_FACTORY);
+            } else {
+                result.put(LDAP_SOCKET_FACTORY, EXPIRY_CHECKING_SOCKET_FACTORY);
+            }
         }
         return result;
     }",1,java,13.0,ProcessLdapProperties.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -94,6 +94,7 @@ public class QueryEndpoint {
     @ApiResponses(value = {
         @ApiResponse(code = 200, message = ""List of case types for the given access criteria""),
         @ApiResponse(code = 404, message = ""No case types found for given access criteria"")})
+    @SuppressWarnings(""squid:CallToDeprecatedMethod"")
     public List<CaseType> getCaseTypes(@PathVariable(""jid"") final String jurisdictionId,
                                        @RequestParam(value = ""access"", required = true) String access) {
         return getCaseTypesOperation.execute(jurisdictionId, ofNullable(accessMap.get(access))
@@ -192,7 +193,7 @@ public class QueryEndpoint {
                              @PathVariable(""ctid"") final String caseTypeId,
                              @PathVariable(""cid"") final String cid) {
         Instant start = Instant.now();
-        CaseView caseView = getCaseViewOperation.execute(jurisdictionId, caseTypeId, cid);
+        CaseView caseView = getCaseViewOperation.execute(cid);
         final Duration between = Duration.between(start, Instant.now());
         LOG.info(""findCase has been completed in {} millisecs..."", between.toMillis());
         return caseView;
",1,java,3.0,QueryEndpoint.java
9b75b603e3a5f5ba6deff13cbb45b070bf2d2239,keycloak/keycloak,train,"@@ -22,6 +22,9 @@ import org.openqa.selenium.By;
 import org.openqa.selenium.WebElement;
 import org.openqa.selenium.support.FindBy;
+import java.util.LinkedList;
+import java.util.List;
+
@@ -50,26 +53,72 @@ public class AccountFederatedIdentityPage extends AbstractAccountPage {
     public boolean isCurrent() {
         return driver.getTitle().contains(""Account Management"") && driver.getPageSource().contains(""Federated Identities"");
     }
-    
-    public WebElement findAddProviderButton(String alias) {
-        return driver.findElement(By.id(""add-"" + alias));
+
+    public List<FederatedIdentity> getIdentities() {
+        List<FederatedIdentity> identities = new LinkedList<>();
+        WebElement identitiesElement = driver.findElement(By.id(""federated-identities""));
+        for (WebElement i : identitiesElement.findElements(By.className(""row""))) {
+
+            String providerId = i.findElement(By.tagName(""label"")).getText();
+            String subject = i.findElement(By.tagName(""input"")).getAttribute(""value"");
+            WebElement button = i.findElement(By.tagName(""button""));
+
+            identities.add(new FederatedIdentity(providerId, subject, button));
+        }
+        return identities;
     }
-    
-    public WebElement findRemoveProviderButton(String alias) {
-        return driver.findElement(By.id(""remove-"" + alias));
+
+    public WebElement findAddProvider(String providerId) {
+        return driver.findElement(By.id(""add-link-"" + providerId));
     }
-    public void clickAddProvider(String alias) {
-        WebElement addButton = findAddProviderButton(alias);
-        addButton.click();
+    public void clickAddProvider(String providerId) {
+        findAddProvider(providerId).click();
     }
-    public void clickRemoveProvider(String alias) {
-        WebElement addButton = findRemoveProviderButton(alias);
-        addButton.click();
+    public void clickRemoveProvider(String providerId) {
+        driver.findElement(By.id(""remove-link-"" + providerId)).click();
     }
     public String getError() {
         return errorMessage.getText();
     }
+
+    public static class FederatedIdentity {
+
+        private String providerId;
+        private String subject;
+        private WebElement action;
+
+        public FederatedIdentity(String providerId, String subject, WebElement action) {
+            this.providerId = providerId;
+            this.subject = subject;
+            this.action = action;
+        }
+
+        public String getProvider() {
+            return providerId;
+        }
+
+        public void setProviderId(String providerId) {
+            this.providerId = providerId;
+        }
+
+        public String getSubject() {
+            return subject;
+        }
+
+        public void setSubject(String subject) {
+            this.subject = subject;
+        }
+
+        public WebElement getAction() {
+            return action;
+        }
+
+        public void setAction(WebElement action) {
+            this.action = action;
+        }
+    }
+
 }",1,java,56.0,AccountFederatedIdentityPage.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,train,"@@ -186,7 +186,7 @@ private HttpURLConnection createUrlConnection(Request request) throws IOExceptio
             SSLContext sslContext = config.getSSLContext();
             if (sslContext == null) {
                 try {
-                    sslContext = SslUtils.getSSLContext();
+                    sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
                 } catch (NoSuchAlgorithmException e) {
                     throw new IOException(e.getMessage());
                 } catch (GeneralSecurityException e) {",1,java,2.0,src/main/java/com/ning/http/client/providers/jdk/JDKAsyncHttpProvider.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -15,6 +15,7 @@ import uk.gov.hmcts.ccd.domain.model.draft.UpdateCaseDraftRequest;
 import uk.gov.hmcts.ccd.domain.model.std.CaseDataContent;
 import uk.gov.hmcts.ccd.domain.types.sanitiser.CaseSanitiser;
 import uk.gov.hmcts.ccd.endpoint.exceptions.ValidationException;
+import uk.gov.hmcts.ccd.infrastructure.user.UserAuthorisation;
 
 import javax.inject.Inject;
 
@@ -26,6 +27,7 @@ public class DefaultUpsertDraftOperation implements UpsertDraftOperation {
     private final ApplicationParams applicationParams;
     private final CaseDefinitionRepository caseDefinitionRepository;
     private final CaseSanitiser caseSanitiser;
+    private final UserAuthorisation userAuthorisation;
 
     protected static final String CASE_DATA_CONTENT = ""CaseDataContent"";
 
@@ -33,47 +35,58 @@ public class DefaultUpsertDraftOperation implements UpsertDraftOperation {
     public DefaultUpsertDraftOperation(@Qualifier(CachedDraftGateway.QUALIFIER) final DraftGateway draftGateway,
                                        @Qualifier(CachedCaseDefinitionRepository.QUALIFIER) final CaseDefinitionRepository caseDefinitionRepository,
                                        final CaseSanitiser caseSanitiser,
-
+                                       final UserAuthorisation userAuthorisation,
                                        ApplicationParams applicationParams) {
         this.draftGateway = draftGateway;
         this.applicationParams = applicationParams;
         this.caseDefinitionRepository = caseDefinitionRepository;
         this.caseSanitiser = caseSanitiser;
+        this.userAuthorisation = userAuthorisation;
     }
 
     @Override
-    public DraftResponse executeSave(final String uid,
-                                     final String jurisdictionId,
-                                     final String caseTypeId,
-                                     final String eventTriggerId,
-                                     final CaseDataContent caseDataContent) {
+    public DraftResponse executeSave(final String caseTypeId, final CaseDataContent caseDataContent) {
         final DraftResponse draftResponse = new DraftResponse();
-        draftResponse.setId(draftGateway.create(buildCreateCaseDraft(uid, jurisdictionId, caseTypeId, eventTriggerId, caseDataContent)).toString());
+        CaseType caseType = caseDefinitionRepository.getCaseType(caseTypeId);
+        final String eventId = caseDataContent.getEventId();
+        if (!caseType.hasEventId(eventId)) {
+            throw new ValidationException(""Validation error. Event id "" + eventId + "" is not found in case type definition"");
+        }
+        draftResponse.setId(createDraft(caseDataContent, caseType, eventId));
         return draftResponse;
     }
 
     @Override
-    public DraftResponse executeUpdate(final String uid,
-                                       final String jurisdictionId,
-                                       final String caseTypeId,
-                                       final String eventTriggerId,
-                                       final String draftId,
-                                       final CaseDataContent caseDataContent) {
-        return draftGateway.update(buildUpdateCaseDraft(uid, jurisdictionId, caseTypeId, eventTriggerId, caseDataContent),
+    public DraftResponse executeUpdate(final String caseTypeId, final String draftId, final CaseDataContent caseDataContent) {
+        CaseType caseType = caseDefinitionRepository.getCaseType(caseTypeId);
+        final String eventId = caseDataContent.getEventId();
+        if (!caseType.hasEventId(eventId)) {
+            throw new ValidationException(""Validation error. Event id "" + eventId + "" is not found in case type definition"");
+        }
+        return draftGateway.update(buildUpdateCaseDraft(userAuthorisation.getUserId(),
+                                                        caseType,
+                                                        eventId,
+                                                        caseDataContent),
                                    draftId);
     }
 
+    private String createDraft(CaseDataContent caseDataContent, CaseType caseType, String eventId) {
+        return draftGateway.create(buildCreateCaseDraft(userAuthorisation.getUserId(),
+                                                        caseType,
+                                                        eventId,
+                                                        caseDataContent)).toString();
+    }
+
     private CreateCaseDraftRequest buildCreateCaseDraft(String uid,
-                                                        String jurisdictionId,
-                                                        String caseTypeId,
+                                                        CaseType caseType,
                                                         String eventTriggerId,
                                                         CaseDataContent caseDataContent) {
-        sanitiseData(caseTypeId, caseDataContent);
+        caseDataContent.setData(caseSanitiser.sanitise(caseType, caseDataContent.getData()));
 
         final CaseDraft caseDraft = new CaseDraft();
         caseDraft.setUserId(uid);
-        caseDraft.setJurisdictionId(jurisdictionId);
-        caseDraft.setCaseTypeId(caseTypeId);
+        caseDraft.setJurisdictionId(caseType.getJurisdictionId());
+        caseDraft.setCaseTypeId(caseType.getId());
         caseDraft.setEventTriggerId(eventTriggerId);
         caseDraft.setCaseDataContent(caseDataContent);
 
@@ -85,16 +98,15 @@ public class DefaultUpsertDraftOperation implements UpsertDraftOperation {
     }
 
     private UpdateCaseDraftRequest buildUpdateCaseDraft(String uid,
-                                                        String jurisdictionId,
-                                                        String caseTypeId,
+                                                        CaseType caseType,
                                                         String eventTriggerId,
                                                         CaseDataContent caseDataContent) {
-        sanitiseData(caseTypeId, caseDataContent);
+        caseDataContent.setData(caseSanitiser.sanitise(caseType, caseDataContent.getData()));
 
         final CaseDraft caseDraft = new CaseDraft();
         caseDraft.setUserId(uid);
-        caseDraft.setJurisdictionId(jurisdictionId);
-        caseDraft.setCaseTypeId(caseTypeId);
+        caseDraft.setJurisdictionId(caseType.getJurisdictionId());
+        caseDraft.setCaseTypeId(caseType.getId());
         caseDraft.setEventTriggerId(eventTriggerId);
         caseDraft.setCaseDataContent(caseDataContent);
 
@@ -104,12 +116,4 @@ public class DefaultUpsertDraftOperation implements UpsertDraftOperation {
         return updateCaseDraftRequest;
     }
 
-    private void sanitiseData(String caseTypeId, CaseDataContent caseDataContent) {
-        final CaseType caseType = caseDefinitionRepository.getCaseType(caseTypeId);
-        if (caseType == null) {
-            throw new ValidationException(""Cannot find case type definition for "" + caseTypeId);
-        }
-        caseDataContent.setData(caseSanitiser.sanitise(caseType, caseDataContent.getData()));
-    }
-
 }
",1,java,65.0,DefaultUpsertDraftOperation.java
8c6c7528f1e24c6b71f3e36db0cb8a697256ce25,vt-middleware/cryptacular,train,"@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.util.function.Function;
 import javax.crypto.SecretKey;
 import org.bouncycastle.crypto.BlockCipher;
 import org.bouncycastle.crypto.modes.AEADBlockCipher;
@@ -13,6 +14,7 @@
 import org.bouncycastle.crypto.params.KeyParameter;
 import org.bouncycastle.crypto.params.ParametersWithIV;
 import org.cryptacular.CiphertextHeader;
+import org.cryptacular.CiphertextHeaderV2;
 import org.cryptacular.CryptoException;
 import org.cryptacular.EncodingException;
 import org.cryptacular.StreamException;
@@ -37,15 +39,15 @@ private CipherUtil() {}
-   * Encrypts data using an AEAD cipher. A {@link CiphertextHeader} is prepended to the resulting ciphertext and used as
-   * AAD (Additional Authenticated Data) passed to the AEAD cipher.
+   * Encrypts data using an AEAD cipher. A {@link CiphertextHeaderV2} is prepended to the resulting ciphertext and
+   * used as AAD (Additional Authenticated Data) passed to the AEAD cipher.
-   * @return  Concatenation of encoded {@link CiphertextHeader} and encrypted data that completely fills the returned
+   * @return  Concatenation of encoded {@link CiphertextHeaderV2} and encrypted data that completely fills the returned
@@ -54,22 +56,22 @@ private CipherUtil() {}
     throws CryptoException
   {
     final byte[] iv = nonce.generate();
-    final byte[] header = new CiphertextHeader(iv).encode();
+    final byte[] header = new CiphertextHeaderV2(iv, ""1"").encode(key);
     cipher.init(true, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, iv, header));
     return encrypt(new AEADBlockCipherAdapter(cipher), header, data);
   }
-   * Encrypts data using an AEAD cipher. A {@link CiphertextHeader} is prepended to the resulting ciphertext and used as
-   * AAD (Additional Authenticated Data) passed to the AEAD cipher.
+   * Encrypts data using an AEAD cipher. A {@link CiphertextHeaderV2} is prepended to the resulting ciphertext and used
+   * as AAD (Additional Authenticated Data) passed to the AEAD cipher.
-   * @param  output  Output stream that receives a {@link CiphertextHeader} followed by ciphertext data produced by the
-   *                 AEAD cipher in encryption mode.
+   * @param  output  Output stream that receives a {@link CiphertextHeaderV2} followed by ciphertext data produced by
+   *                 the AEAD cipher in encryption mode.
@@ -83,7 +85,7 @@ public static void encrypt(
     throws CryptoException, StreamException
   {
     final byte[] iv = nonce.generate();
-    final byte[] header = new CiphertextHeader(iv).encode();
+    final byte[] header = new CiphertextHeaderV2(iv, ""1"").encode(key);
     cipher.init(true, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, iv, header));
     writeHeader(header, output);
     process(new AEADBlockCipherAdapter(cipher), input, output);
@@ -95,7 +97,7 @@ public static void encrypt(
-   * @param  data  Ciphertext data containing a prepended {@link CiphertextHeader}. The header is treated as AAD input
+   * @param  data  Ciphertext data containing a prepended {@link CiphertextHeaderV2}. The header is treated as AAD input
@@ -106,7 +108,7 @@ public static void encrypt(
   public static byte[] decrypt(final AEADBlockCipher cipher, final SecretKey key, final byte[] data)
       throws CryptoException, EncodingException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(data);
+    final CiphertextHeader header = decodeHeader(data, String -> key);
     final byte[] nonce = header.getNonce();
     final byte[] hbytes = header.encode();
     cipher.init(false, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, nonce, hbytes));
@@ -119,7 +121,7 @@ public static void encrypt(
-   * @param  input  Input stream containing a {@link CiphertextHeader} followed by ciphertext data. The header is
+   * @param  input  Input stream containing a {@link CiphertextHeaderV2} followed by ciphertext data. The header is
@@ -134,7 +136,7 @@ public static void decrypt(
     final OutputStream output)
     throws CryptoException, EncodingException, StreamException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(input);
+    final CiphertextHeader header = decodeHeader(input, String -> key);
     final byte[] nonce = header.getNonce();
     final byte[] hbytes = header.encode();
     cipher.init(false, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, nonce, hbytes));
@@ -143,7 +145,7 @@ public static void decrypt(
-   * Encrypts data using the given block cipher with PKCS5 padding. A {@link CiphertextHeader} is prepended to the
+   * Encrypts data using the given block cipher with PKCS5 padding. A {@link CiphertextHeaderV2} is prepended to the
@@ -152,7 +154,7 @@ public static void decrypt(
-   * @return  Concatenation of encoded {@link CiphertextHeader} and encrypted data that completely fills the returned
+   * @return  Concatenation of encoded {@link CiphertextHeaderV2} and encrypted data that completely fills the returned
@@ -161,7 +163,7 @@ public static void decrypt(
     throws CryptoException
   {
     final byte[] iv = nonce.generate();
-    final byte[] header = new CiphertextHeader(iv).encode();
+    final byte[] header = new CiphertextHeaderV2(iv, ""1"").encode(key);
     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());
     padded.init(true, new ParametersWithIV(new KeyParameter(key.getEncoded()), iv));
     return encrypt(new BufferedBlockCipherAdapter(padded), header, data);
@@ -191,7 +193,7 @@ public static void encrypt(
     throws CryptoException, StreamException
   {
     final byte[] iv = nonce.generate();
-    final byte[] header = new CiphertextHeader(iv).encode();
+    final byte[] header = new CiphertextHeaderV2(iv, ""1"").encode(key);
     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());
     padded.init(true, new ParametersWithIV(new KeyParameter(key.getEncoded()), iv));
     writeHeader(header, output);
@@ -214,7 +216,7 @@ public static void encrypt(
   public static byte[] decrypt(final BlockCipher cipher, final SecretKey key, final byte[] data)
     throws CryptoException, EncodingException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(data);
+    final CiphertextHeader header = decodeHeader(data, String -> key);
     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());
     padded.init(false, new ParametersWithIV(new KeyParameter(key.getEncoded()), header.getNonce()));
     return decrypt(new BufferedBlockCipherAdapter(padded), data, header.getLength());
@@ -240,13 +242,62 @@ public static void decrypt(
     final OutputStream output)
     throws CryptoException, EncodingException, StreamException
   {
-    final CiphertextHeader header = CiphertextHeader.decode(input);
+    final CiphertextHeader header = decodeHeader(input, String -> key);
     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());
     padded.init(false, new ParametersWithIV(new KeyParameter(key.getEncoded()), header.getNonce()));
     process(new BufferedBlockCipherAdapter(padded), input, output);
   }
+  /**
+   * Decodes the ciphertext header at the start of the given byte array.
+   * Supports both original (deprecated) and v2 formats.
+   *
+   * @param  data  Ciphertext data with prepended header.
+   * @param  keyLookup  Decryption key lookup function.
+   *
+   * @return  Ciphertext header instance.
+   */
+  public static CiphertextHeader decodeHeader(final byte[] data, final Function<String, SecretKey> keyLookup)
+  {
+    try {
+      return CiphertextHeaderV2.decode(data, keyLookup);
+    } catch (EncodingException e) {
+      return CiphertextHeader.decode(data);
+    }
+  }
+
+
+  /**
+   * Decodes the ciphertext header at the start of the given input stream.
+   * Supports both original (deprecated) and v2 formats.
+   *
+   * @param  in  Ciphertext stream that is positioned at the start of the ciphertext header.
+   * @param  keyLookup  Decryption key lookup function.
+   *
+   * @return  Ciphertext header instance.
+   */
+  public static CiphertextHeader decodeHeader(final InputStream in, final Function<String, SecretKey> keyLookup)
+  {
+    CiphertextHeader header;
+    try {
+      // Mark the stream start position so we can try again with old format header
+      if (in.markSupported()) {
+        in.mark(4);
+      }
+      header = CiphertextHeaderV2.decode(in, keyLookup);
+    } catch (EncodingException e) {
+      try {
+        in.reset();
+      } catch (IOException ioe) {
+        throw new StreamException(""Stream error trying to process old header format: "" + ioe.getMessage());
+      }
+      header = CiphertextHeader.decode(in);
+    }
+    return header;
+  }
+
+
@@ -325,6 +376,7 @@ private static void process(final BlockCipherAdapter cipher, final InputStream i
   }
+",1,java,44.0,src/main/java/org/cryptacular/util/CipherUtil.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,train,"@@ -19,13 +19,16 @@ package org.apache.ignite.internal.client.marshaller.jdk;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.ObjectInput;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
+import java.io.ObjectStreamClass;
 import java.nio.ByteBuffer;
 import org.apache.ignite.internal.client.marshaller.GridClientMarshaller;
 import org.apache.ignite.internal.util.io.GridByteArrayOutputStream;
+import org.apache.ignite.lang.IgnitePredicate;
@@ -34,6 +37,23 @@ public class GridClientJdkMarshaller implements GridClientMarshaller {
     public static final byte ID = 2;
+    /** Class name filter. */
+    private final IgnitePredicate<String> clsFilter;
+
+    /**
+     * Default constructor.
+     */
+    public GridClientJdkMarshaller() {
+        this(null);
+    }
+
+    /**
+     * @param clsFilter Class filter.
+     */
+    public GridClientJdkMarshaller(IgnitePredicate<String> clsFilter) {
+        this.clsFilter = clsFilter;
+    }
+
     @Override public ByteBuffer marshal(Object obj, int off) throws IOException {
         GridByteArrayOutputStream bOut = new GridByteArrayOutputStream();
@@ -60,7 +80,7 @@ public class GridClientJdkMarshaller implements GridClientMarshaller {
     @Override public <T> T unmarshal(byte[] bytes) throws IOException {
         ByteArrayInputStream tmp = new ByteArrayInputStream(bytes);
-        ObjectInput in = new ObjectInputStream(tmp);
+        ObjectInput in = new ClientJdkInputStream(tmp, clsFilter);
         try {
             return (T)in.readObject();
@@ -69,4 +89,33 @@ public class GridClientJdkMarshaller implements GridClientMarshaller {
             throw new IOException(""Failed to unmarshal target object: "" + e.getMessage(), e);
         }
     }
+
+    /**
+     * Wrapper with class resolving control.
+     */
+    private static class ClientJdkInputStream extends ObjectInputStream {
+        /** Class name filter. */
+        private final IgnitePredicate<String> clsFilter;
+
+
+        /**
+         * @param in Input stream.
+         * @param clsFilter Class filter.
+         */
+        public ClientJdkInputStream(InputStream in, IgnitePredicate<String> clsFilter) throws IOException {
+            super(in);
+
+            this.clsFilter = clsFilter;
+        }
+
+        /** {@inheritDoc} */
+        @Override protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
+            String clsName = desc.getName();
+
+            if (clsFilter != null && !clsFilter.apply(clsName))
+                throw new RuntimeException(""Deserialization of class "" + clsName + "" is disallowed."");
+
+            return super.resolveClass(desc);
+        }
+    }
 }
\ No newline at end of file",1,java,25.0,GridClientJdkMarshaller.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,train,"@@ -1,9 +1,14 @@
 package com.dotmarketing.portlets.languagesmanager.model;
 import java.io.Serializable;
+import java.util.Locale;
+
 import org.apache.commons.lang.builder.EqualsBuilder;
 import org.apache.commons.lang.builder.HashCodeBuilder;
+import com.dotmarketing.exception.DotRuntimeException;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+
@@ -74,6 +79,20 @@ public String getCountry() {
         return country;
     }
+    @JsonIgnore
+    public Locale asLocale() {
+      if(this.languageCode==null) {
+        throw new DotRuntimeException(""Locale requires a language code"");
+      }
+      else if(this.countryCode==null) {
+        return new Locale(this.languageCode);
+      }else {
+        return new Locale(this.languageCode, this.countryCode);
+      }
+    }
+    
+    
+    ",1,java,15.0,dotCMS/src/main/java/com/dotmarketing/portlets/languagesmanager/model/Language.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -42,12 +42,6 @@ public class DefaultGetCaseViewOperation extends AbstractDefaultGetCaseViewOpera
         this.eventTriggerService = eventTriggerService;
     }
 
-    @Override
-    @Deprecated
-    public CaseView execute(String jurisdictionId, String caseTypeId, String caseReference) {
-        return execute(caseReference);
-    }
-
     @Override
     public CaseView execute(String caseReference) {
         validateCaseReference(caseReference);
",1,java,6.0,DefaultGetCaseViewOperation.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,train,"@@ -37,6 +37,9 @@
 import org.postgresql.util.PGobject;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
+import org.postgresql.xml.DefaultPGXmlFactoryFactory;
+import org.postgresql.xml.LegacyInsecurePGXmlFactoryFactory;
+import org.postgresql.xml.PGXmlFactoryFactory;
 import java.io.IOException;
 import java.sql.Array;
@@ -156,6 +159,9 @@
   private final LruCache<FieldMetadata.Key, FieldMetadata> fieldMetadataCache;
+  private final String xmlFactoryFactoryClass;
+  private PGXmlFactoryFactory xmlFactoryFactory;
+
   final CachedQuery borrowQuery(String sql) throws SQLException {
     return queryExecutor.borrowQuery(sql);
   }
@@ -311,6 +317,8 @@ public TimeZone get() {
         false);
     replicationConnection = PGProperty.REPLICATION.get(info) != null;
+
+    xmlFactoryFactoryClass = PGProperty.XML_FACTORY_FACTORY.get(info);
   }
   private static ReadOnlyBehavior getReadOnlyBehavior(String property) {
@@ -1823,4 +1831,36 @@ public final String getParameterStatus(String parameterName) {
     return queryExecutor.getParameterStatus(parameterName);
   }
+  @Override
+  public PGXmlFactoryFactory getXmlFactoryFactory() throws SQLException {
+    if (xmlFactoryFactory == null) {
+      if (xmlFactoryFactoryClass == null || xmlFactoryFactoryClass.equals("""")) {
+        xmlFactoryFactory = DefaultPGXmlFactoryFactory.INSTANCE;
+      } else if (xmlFactoryFactoryClass.equals(""LEGACY_INSECURE"")) {
+        xmlFactoryFactory = LegacyInsecurePGXmlFactoryFactory.INSTANCE;
+      } else {
+        Class<?> clazz;
+        try {
+          clazz = Class.forName(xmlFactoryFactoryClass);
+        } catch (ClassNotFoundException ex) {
+          throw new PSQLException(
+              GT.tr(""Could not instantiate xmlFactoryFactory: {0}"", xmlFactoryFactoryClass),
+              PSQLState.INVALID_PARAMETER_VALUE, ex);
+        }
+        if (!clazz.isAssignableFrom(PGXmlFactoryFactory.class)) {
+          throw new PSQLException(
+              GT.tr(""Connection property xmlFactoryFactory must implement PGXmlFactoryFactory: {0}"", xmlFactoryFactoryClass),
+              PSQLState.INVALID_PARAMETER_VALUE);
+        }
+        try {
+          xmlFactoryFactory = (PGXmlFactoryFactory) clazz.newInstance();
+        } catch (Exception ex) {
+          throw new PSQLException(
+              GT.tr(""Could not instantiate xmlFactoryFactory: {0}"", xmlFactoryFactoryClass),
+              PSQLState.INVALID_PARAMETER_VALUE, ex);
+        }
+      }
+    }
+    return xmlFactoryFactory;
+  }
 }",1,java,39.0,pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
f268ab5a00302a89fd0d55cd58d0448402d209a4,jooby-project/jooby,train,"@@ -11,6 +11,7 @@ import io.jooby.SneakyThrows;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CoderResult;
 import java.nio.charset.StandardCharsets;
@@ -24,118 +25,135 @@ public final class UrlParser {
       return NO_QUERY_STRING;
     }
     QueryStringValue result = new QueryStringValue(""?"" + queryString);
-    parse(queryString, 0, queryString.length(), result);
+    decodeParams(result, queryString, 0, StandardCharsets.UTF_8, 1024);
     return result;
   }
 
-  private static void parse(String source, int start, int length, HashValue root) {
-    int nameStart = start;
-    int nameEnd = length;
-    // %00 size = 3
-    int decodedSize = (length - start) / 3;
-    StringBuilder decodedBuffer = new StringBuilder(decodedSize);
-    ByteBuffer decoderInput = ByteBuffer.allocate(decodedSize);
-    CharBuffer decoderOutput = CharBuffer.allocate(decodedSize);
-    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();
-    for (int i = nameStart; i < length; i++) {
-      char ch = source.charAt(i);
-      if (ch == '=') {
-        // Parameter name ready
-        nameEnd = i;
-      } else if (ch == '&' || ch == ';') {
-        newParam(root, source, nameStart, nameEnd, nameEnd + 1, i, decodedBuffer,
-            decoderInput,
-            decoderOutput, decoder);
-        nameStart = i + 1;
-      }
+  public static String decodePathSegment(String value) {
+    if (value == null || value.length() == 0) {
+      return """";
     }
-    newParam(root, source, nameStart, nameEnd, nameEnd + 1, length, decodedBuffer, decoderInput,
-        decoderOutput, decoder);
+    return decodeComponent(value, 0, value.length(), StandardCharsets.UTF_8, true);
   }
 
-  private static void newParam(HashValue root, String source, int nameStart, int nameEnd,
-      int valueStart, int valueEnd, StringBuilder decodedBuffer,
-      ByteBuffer decoderInput, CharBuffer decoderOutput, CharsetDecoder decoder) {
-    if (nameStart < valueEnd) {
-      // returnType target
-      String name = decode(source, nameStart, nameEnd, decodedBuffer, decoderInput,
-          decoderOutput,
-          decoder);
-      String value = decode(source, valueStart, valueEnd, decodedBuffer, decoderInput,
-          decoderOutput, decoder);
-      root.put(name, value);
+  private static void decodeParams(HashValue root, String s, int from, Charset charset,
+      int paramsLimit) {
+    int len = s.length();
+    if (from >= len) {
+      return;
     }
+    if (s.charAt(from) == '?') {
+      from++;
+    }
+    int nameStart = from;
+    int valueStart = -1;
+    int i;
+    loop:
+    for (i = from; i < len; i++) {
+      switch (s.charAt(i)) {
+        case '=':
+          if (nameStart == i) {
+            nameStart = i + 1;
+          } else if (valueStart < nameStart) {
+            valueStart = i + 1;
+          }
+          break;
+        case '&':
+        case ';':
+          if (addParam(root, s, nameStart, valueStart, i, charset)) {
+            paramsLimit--;
+            if (paramsLimit == 0) {
+              return;
+            }
+          }
+          nameStart = i + 1;
+          break;
+        case '#':
+          break loop;
+        default:
+          // continue
+      }
+    }
+    addParam(root, s, nameStart, valueStart, i, charset);
   }
 
-  public static String decodePath(String path) {
-    // %00 size = 3
-    int len = path.length();
-    int decodedSize = len / 3;
-    StringBuilder decodedBuffer = new StringBuilder(decodedSize);
-    ByteBuffer decoderInput = ByteBuffer.allocate(decodedSize);
-    CharBuffer decoderOutput = CharBuffer.allocate(decodedSize);
-    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();
-    return decode(path, 0, len, decodedBuffer, decoderInput, decoderOutput, decoder, false);
-  }
-
-  private static String decode(String source, int start, int len, StringBuilder decodedBuffer,
-      ByteBuffer decoderInput, CharBuffer decoderOutput, CharsetDecoder decoder) {
-    return decode(source, start, len, decodedBuffer, decoderInput, decoderOutput, decoder,
-        true);
+  private static boolean addParam(HashValue root, String s, int nameStart, int valueStart,
+      int valueEnd, Charset charset) {
+    if (nameStart >= valueEnd) {
+      return false;
+    }
+    if (valueStart <= nameStart) {
+      valueStart = valueEnd + 1;
+    }
+    String name = decodeComponent(s, nameStart, valueStart - 1, charset, false);
+    String value = decodeComponent(s, valueStart, valueEnd, charset, false);
+    root.put(name, value);
+    return true;
   }
 
-  private static String decode(String source, int start, int len, StringBuilder decodedBuffer,
-      ByteBuffer decoderInput, CharBuffer decoderOutput, CharsetDecoder decoder,
-      boolean encodePlus) {
-    decodedBuffer.setLength(0);
-    for (int i = start; i < len; i++) {
-      char ch = source.charAt(i);
-      if (ch == '%') {
-        decodedBuffer.append(source, start, i);
-        i = decodePercent(source, i, len, decoderInput, decoderOutput, decoder);
-        decodedBuffer.append(decoderOutput.flip().toString());
-        start = i + 1;
-      } else if (ch == '+' && encodePlus) {
-        decodedBuffer.append(source, start, i);
-        decodedBuffer.append(SPACE);
-        start = i + 1;
+  private static String decodeComponent(String s, int from, int toExcluded, Charset charset,
+      boolean isPath) {
+    int len = toExcluded - from;
+    if (len <= 0) {
+      return """";
+    }
+    int firstEscaped = -1;
+    for (int i = from; i < toExcluded; i++) {
+      char c = s.charAt(i);
+      if (c == '%' || c == '+' && !isPath) {
+        firstEscaped = i;
+        break;
       }
     }
-    if (decodedBuffer.length() > 0) {
-      decodedBuffer.append(source, start, len);
-      return decodedBuffer.toString();
+    if (firstEscaped == -1) {
+      return s.substring(from, toExcluded);
     }
-    return source.substring(start, len);
-  }
 
-  private static int decodePercent(String source, int pos, int len, ByteBuffer decoderInput,
-      CharBuffer decoderOutput, CharsetDecoder decoder) {
-    decoderOutput.clear();
-    decoderInput.clear();
-    do {
-      if (pos + 3 > len) {
-        throw new IllegalArgumentException(
-            ""Unterminated escape sequence at index "" + pos + "" of: "" + source);
-      }
-      decoderInput.put(decodeHexByte(source, pos + 1));
-      pos += 3;
-    } while (pos < len && source.charAt(pos) == '%');
-    pos--;
-    /** Decode using UTF-8: */
-    decoderInput.flip();
-    CoderResult result = decoder.decode(decoderInput, decoderOutput, true);
-    try {
-      if (!result.isUnderflow()) {
-        result.throwException();
+    CharsetDecoder decoder = charset.newDecoder();
+
+    // Each encoded byte takes 3 characters (e.g. ""%20"")
+    int decodedCapacity = (toExcluded - firstEscaped) / 3;
+    ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);
+    CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);
+
+    StringBuilder strBuf = new StringBuilder(len);
+    strBuf.append(s, from, firstEscaped);
+
+    for (int i = firstEscaped; i < toExcluded; i++) {
+      char c = s.charAt(i);
+      if (c != '%') {
+        strBuf.append(c != '+' || isPath ? c : SPACE);
+        continue;
       }
-      result = decoder.flush(decoderOutput);
-      if (!result.isUnderflow()) {
-        result.throwException();
+
+      byteBuf.clear();
+      do {
+        if (i + 3 > toExcluded) {
+          throw new IllegalArgumentException(
+              ""unterminated escape sequence at index "" + i + "" of: "" + s);
+        }
+        byteBuf.put(decodeHexByte(s, i + 1));
+        i += 3;
+      } while (i < toExcluded && s.charAt(i) == '%');
+      i--;
+
+      byteBuf.flip();
+      charBuf.clear();
+      CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);
+      try {
+        if (!result.isUnderflow()) {
+          result.throwException();
+        }
+        result = decoder.flush(charBuf);
+        if (!result.isUnderflow()) {
+          result.throwException();
+        }
+      } catch (CharacterCodingException ex) {
+        throw SneakyThrows.propagate(ex);
       }
-    } catch (CharacterCodingException ex) {
-      throw SneakyThrows.propagate(ex);
+      strBuf.append(charBuf.flip());
     }
-    return pos;
+    return strBuf.toString();
   }
 
   /**
@@ -145,7 +163,7 @@ public final class UrlParser {
    * @return The hexadecimal value represented in the ASCII character
    * given, or {@code -1} if the character is invalid.
    */
-  public static int decodeHexNibble(final char c) {
+  private static int decodeHexNibble(final char c) {
     // Character.digit() is not used here, as it addresses a larger
     // set of characters (both ASCII and full-width latin letters).
     if (c >= '0' && c <= '9') {
@@ -163,7 +181,7 @@ public final class UrlParser {
   /**
    * Decode a 2-digit hex byte from within a string.
    */
-  public static byte decodeHexByte(CharSequence s, int pos) {
+  private static byte decodeHexByte(CharSequence s, int pos) {
     int hi = decodeHexNibble(s.charAt(pos));
     int lo = decodeHexNibble(s.charAt(pos + 1));
     if (hi == -1 || lo == -1) {
",1,java,197.0,UrlParser.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -0,0 +1,51 @@
+/*
+ * file:       XmlReaderHelper.java
+ * author:     Jon Iles
+ * copyright:  (c) Packwood Software 2020
+ * date:       29/08/2020
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at your
+ * option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+package net.sf.mpxj.common;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+
+/**
+ * Utility methods for working with XmlReader.
+ */
+public final class XmlReaderHelper
+{
+   /**
+    * Create a new XmlReader instance.
+    *
+    * @return XmlReader instance
+    */
+   public static final XMLReader createXmlReader() throws SAXException, ParserConfigurationException
+   {
+      SAXParserFactory factory = SAXParserFactory.newInstance();
+      factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
+      factory.setNamespaceAware(true);
+      SAXParser saxParser = factory.newSAXParser();
+      return saxParser.getXMLReader();
+   }
+}",1,java,18.0,src/main/java/net/sf/mpxj/common/XmlReaderHelper.java
c3e457f7a16facfe563eade82b0fa8736a8c96f9,joniles/mpxj,train,"@@ -37,15 +37,9 @@
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 import net.sf.mpxj.ChildTaskContainer;
 import net.sf.mpxj.ConstraintType;
@@ -76,6 +70,7 @@
 import net.sf.mpxj.common.Pair;
 import net.sf.mpxj.common.ResourceFieldLists;
 import net.sf.mpxj.common.TaskFieldLists;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.ganttproject.schema.Allocation;
 import net.sf.mpxj.ganttproject.schema.Allocations;
 import net.sf.mpxj.ganttproject.schema.Calendars;
@@ -118,6 +113,11 @@
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_resourcePropertyDefinitions = new HashMap<>();
@@ -137,19 +137,7 @@
          m_eventManager.addProjectListeners(m_projectListeners);
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project ganttProject = (Project) unmarshaller.unmarshal(doc);
+         Project ganttProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, stream);
          readProjectProperties(ganttProject);
          readCalendars(ganttProject);",1,java,22.0,src/main/java/net/sf/mpxj/ganttproject/GanttProjectReader.java
3bca8f8d25d7d55f20676a6f12e15940917e33f6,hmcts/ccd-data-store-api,train,"@@ -62,7 +62,7 @@ public class DraftsEndpoint {
         @PathVariable(""etid"") final String eventTriggerId,
         @RequestBody final CaseDataContent caseDataContent) {
 
-        return upsertDraftOperation.executeSave(uid, jurisdictionId, caseTypeId, eventTriggerId, caseDataContent);
+        return upsertDraftOperation.executeSave(caseTypeId, caseDataContent);
     }
 
     @RequestMapping(value = ""/caseworkers/{uid}/jurisdictions/{jid}/case-types/{ctid}/event-trigger/{etid}/drafts/{did}"", method = RequestMethod.PUT)
@@ -87,7 +87,7 @@ public class DraftsEndpoint {
         @PathVariable(""did"") final String draftId,
         @RequestBody final CaseDataContent caseDataContent) {
 
-        return upsertDraftOperation.executeUpdate(uid, jurisdictionId, caseTypeId, eventTriggerId, draftId, caseDataContent);
+        return upsertDraftOperation.executeUpdate(caseTypeId, draftId, caseDataContent);
     }
 
     @Transactional
@@ -101,7 +101,7 @@ public class DraftsEndpoint {
                               @PathVariable(""ctid"") final String caseTypeId,
                               @PathVariable(""did"") final String did) {
         Instant start = Instant.now();
-        CaseView caseView = getDraftViewOperation.execute(jurisdictionId, caseTypeId, did);
+        CaseView caseView = getDraftViewOperation.execute(did);
         final Duration between = Duration.between(start, Instant.now());
         LOG.info(""findDraft has been completed in {} millisecs..."", between.toMillis());
         return caseView;
",1,java,6.0,DraftsEndpoint.java
e6aa166246d1734f4798a9e31f78842f4c85c28b,jenkinsci/jenkins,train,"@@ -2,6 +2,7 @@
+ * Copyright (c) 2016, CloudBees Inc.
@@ -29,12 +30,12 @@
 import com.thoughtworks.xstream.io.HierarchicalStreamReader;
 import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
 import com.trilead.ssh2.crypto.Base64;
+import java.util.Arrays;
 import jenkins.model.Jenkins;
 import hudson.Util;
 import jenkins.security.CryptoConfidentialKey;
 import org.kohsuke.stapler.Stapler;
-import javax.crypto.SecretKey;
 import javax.crypto.Cipher;
 import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
@@ -44,6 +45,8 @@
 import org.kohsuke.accmod.Restricted;
 import org.kohsuke.accmod.restrictions.NoExternalUse;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
@@ -58,13 +61,20 @@
 public final class Secret implements Serializable {
+    private static final byte PAYLOAD_V1 = 1;
     private final String value;
+    private byte[] iv;
+
+    /*package*/ Secret(String value) {
+        this.value = value;
+    }
-    private Secret(String value) {
+    /*package*/ Secret(String value, byte[] iv) {
         this.value = value;
+        this.iv = iv;
     }
@@ -100,20 +110,6 @@ public int hashCode() {
         return value.hashCode();
     }
-    /**
-     * Turns {@link Jenkins#getSecretKey()} into an AES key.
-     *
-     * @deprecated
-     * This is no longer the key we use to encrypt new information, but we still need this
-     * to be able to decrypt what's already persisted.
-     */
-    @Deprecated
-    /*package*/ static SecretKey getLegacyKey() throws GeneralSecurityException {
-        String secret = SECRET;
-        if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();
-        return Util.toAes128Key(secret);
-    }
-
@@ -121,56 +117,95 @@ public int hashCode() {
     public String getEncryptedValue() {
         try {
-            Cipher cipher = KEY.encrypt();
-            // add the magic suffix which works like a check sum.
-            return new String(Base64.encode(cipher.doFinal((value+MAGIC).getBytes(""UTF-8""))));
+            synchronized (this) {
+                if (iv == null) { //if we were created from plain text or other reason without iv
+                    iv = KEY.newIv();
+                }
+            }
+            Cipher cipher = KEY.encrypt(iv);
+            byte[] encrypted = cipher.doFinal(this.value.getBytes(UTF_8));
+            byte[] payload = new byte[1 + 8 + iv.length + encrypted.length];
+            int pos = 0;
+            // For PAYLOAD_V1 we use this byte shifting model, V2 probably will need DataOutput
+            payload[pos++] = PAYLOAD_V1;
+            payload[pos++] = (byte)(iv.length >> 24);
+            payload[pos++] = (byte)(iv.length >> 16);
+            payload[pos++] = (byte)(iv.length >> 8);
+            payload[pos++] = (byte)(iv.length);
+            payload[pos++] = (byte)(encrypted.length >> 24);
+            payload[pos++] = (byte)(encrypted.length >> 16);
+            payload[pos++] = (byte)(encrypted.length >> 8);
+            payload[pos++] = (byte)(encrypted.length);
+            System.arraycopy(iv, 0, payload, pos, iv.length);
+            pos+=iv.length;
+            System.arraycopy(encrypted, 0, payload, pos, encrypted.length);
+            return ""{""+new String(Base64.encode(payload))+""}"";
         } catch (GeneralSecurityException e) {
             throw new Error(e); // impossible
-        } catch (UnsupportedEncodingException e) {
-            throw new Error(e); // impossible
         }
     }
-     * Pattern matching a possible output of {@link #getEncryptedValue}.
-     * Basically, any Base64-encoded value.
-     * You must then call {@link #decrypt} to eliminate false positives.
+     * Pattern matching a possible output of {@link #getEncryptedValue}
+     * Basically, any Base64-encoded value optionally wrapped by {@code {}}.
+     * You must then call {@link #decrypt(String)} to eliminate false positives.
+     * @see #ENCRYPTED_VALUE_PATTERN
     @Restricted(NoExternalUse.class)
-    public static final Pattern ENCRYPTED_VALUE_PATTERN = Pattern.compile(""[A-Za-z0-9+/]+={0,2}"");
+    public static final Pattern ENCRYPTED_VALUE_PATTERN = Pattern.compile(""\\{?[A-Za-z0-9+/]+={0,2}}?"");
     public static Secret decrypt(String data) {
-        if(data==null)      return null;
-        try {
-            byte[] in = Base64.decode(data.toCharArray());
-            Secret s = tryDecrypt(KEY.decrypt(), in);
-            if (s!=null)    return s;
+        if (data == null) return null;
-            // try our historical key for backward compatibility
-            Cipher cipher = getCipher(""AES"");
-            cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());
-            return tryDecrypt(cipher, in);
-        } catch (GeneralSecurityException e) {
-            return null;
-        } catch (UnsupportedEncodingException e) {
-            throw new Error(e); // impossible
-        } catch (IOException e) {
-            return null;
-        }
-    }
-
-    /*package*/ static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {
-        try {
-            String plainText = new String(cipher.doFinal(in), ""UTF-8"");
-            if(plainText.endsWith(MAGIC))
-                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));
-            return null;
-        } catch (GeneralSecurityException e) {
-            return null; // if the key doesn't match with the bytes, it can result in BadPaddingException
+        if (data.startsWith(""{"") && data.endsWith(""}"")) { //likely CBC encrypted/containing metadata but could be plain text
+            byte[] payload;
+            try {
+                payload = Base64.decode(data.substring(1, data.length()-1).toCharArray());
+            } catch (IOException e) {
+                return null;
+            }
+            switch (payload[0]) {
+                case PAYLOAD_V1:
+                    // For PAYLOAD_V1 we use this byte shifting model, V2 probably will need DataOutput
+                    int ivLength = ((payload[1] & 0xff) << 24)
+                            | ((payload[2] & 0xff) << 16)
+                            | ((payload[3] & 0xff) << 8)
+                            | (payload[4] & 0xff);
+                    int dataLength = ((payload[5] & 0xff) << 24)
+                            | ((payload[6] & 0xff) << 16)
+                            | ((payload[7] & 0xff) << 8)
+                            | (payload[8] & 0xff);
+                    if (payload.length != 1 + 8 + ivLength + dataLength) {
+                        // not valid v1
+                        return null;
+                    }
+                    byte[] iv = Arrays.copyOfRange(payload, 9, 9 + ivLength);
+                    byte[] code = Arrays.copyOfRange(payload, 9+ivLength, payload.length);
+                    String text;
+                    try {
+                        text = new String(KEY.decrypt(iv).doFinal(code), UTF_8);
+                    } catch (GeneralSecurityException e) {
+                        // it's v1 which cannot be historical, but not decrypting
+                        return null;
+                    }
+                    return new Secret(text, iv);
+                default:
+                    return null;
+            }
+        } else {
+            try {
+                return HistoricalSecrets.decrypt(data, KEY);
+            } catch (GeneralSecurityException e) {
+                return null;
+            } catch (UnsupportedEncodingException e) {
+                throw new Error(e); // impossible
+            } catch (IOException e) {
+                return null;
+            }
         }
     }
@@ -228,8 +263,6 @@ public Object unmarshal(HierarchicalStreamReader reader, final UnmarshallingCont
         }
     }
-    private static final String MAGIC = ""::::MAGIC::::"";
-
@@ -246,6 +279,14 @@ public Object unmarshal(HierarchicalStreamReader reader, final UnmarshallingCont
     private static final CryptoConfidentialKey KEY = new CryptoConfidentialKey(Secret.class.getName());
+    /**
+     * Reset the internal secret key for testing.
+     */
+    @Restricted(NoExternalUse.class)
+    /*package*/ static void resetKeyForTest() {
+        KEY.resetForTest();
+    }
+
     private static final long serialVersionUID = 1L;
     static {",1,java,112.0,core/src/main/java/hudson/util/Secret.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,droolsjbpm/jbpm-designer,test,"@@ -1,23 +1,27 @@
 package org.jbpm.designer.filter;
 
-import org.apache.commons.httpclient.HttpClient;
-
-import javax.servlet.*;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.Iterator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
 public class DesignerInjectionFilter implements Filter {
+
     private FilterConfig fc = null;
     private ServletContext sc = null;
     private InjectionConfig cf;
     private InjectionRules rules;
-    public static HttpClient client;
 
     public void init(FilterConfig filterConfig) throws ServletException {
         fc = filterConfig;
",1,java,15.0,DesignerInjectionFilter.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,droolsjbpm/jbpm-designer,test,"@@ -1,6 +1,6 @@
 package org.jbpm.designer.repository;
 
-import org.apache.commons.httpclient.URIException;
+import org.uberfire.java.nio.EncodingUtil;
 
 public class UriUtils {
 
@@ -13,22 +13,14 @@ public class UriUtils {
         if (value.matches(URL_ENCODED_REGEX)) {
             return value;
         }
-        try {
-            return org.apache.commons.httpclient.util.URIUtil.encodePath(value);
-        } catch (URIException e) {
-            throw new IllegalArgumentException(""Invalid value "" + value + "" given, error: "" + e.getMessage(), e);
-        }
+        return EncodingUtil.encodePath(value);
     }
 
     public static String decode(String value) {
         if(value == null) {
             return value;
         }
-        try {
-            return org.apache.commons.httpclient.util.URIUtil.decode(value);
-        } catch (URIException e) {
-            throw new IllegalArgumentException(""Invalid value "" + value + "" given, error: "" + e.getMessage(), e);
-        }
+        return EncodingUtil.decode(value);
 
     }
 }
",1,java,14.0,UriUtils.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,droolsjbpm/jbpm-designer,test,"@@ -34,12 +34,11 @@ package org.jbpm.designer.server;
  **/
 
 import java.io.ByteArrayInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.URL;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.ListIterator;
 
@@ -47,7 +46,6 @@ import javax.servlet.ServletContext;
 import javax.servlet.http.HttpServletRequest;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.Source;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerException;
@@ -55,16 +53,25 @@ import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.HttpException;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.PostMethod;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
 
 public class Repository {
 
+    private static final Logger logger = LoggerFactory.getLogger(Repository.class);
+    
 	public static final String NEW_MODEL_SVG_STRING = ""<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:oryx=\""http://oryx-editor.org\"" id=\""oryx_98F1C176-75F8-4C0A-899E-0F5E352A5F58\"" width=\""10\"" height=\""10\"" xlink=\""http://www.w3.org/1999/xlink\"" svg=\""http://www.w3.org/2000/svg\""><defs/><g stroke=\""none\"" font-family=\""Verdana\"" font-size=\""12\""><g class=\""stencils\"" transform=\""translate(0)\""><g class=\""me\""/><g class=\""children\""/><g class=\""edge\""/></g></g></svg>"";
 	public static final String DEFAULT_STENCILSET = ""/stencilsets/bpmn1.1/bpmn1.1.json"";
 	public static final String DEFAULT_TYPE = ""http://b3mn.org/stencilset/bpmn1.1#"";
@@ -127,17 +134,21 @@ public class Repository {
 
 	public String getModel(String path, String representationType) {
 		String result = """";
+		
+		String urlString = baseUrl + path + ""/"" + representationType;
 		try {
-		    HttpClient client = new HttpClient();
-		    GetMethod method = new GetMethod( baseUrl + path + ""/"" + representationType);
-		    int statusCode = client.executeMethod( method );
-			if( statusCode != -1 ) {
-				result = method.getResponseBodyAsString();
+		    HttpClient client = HttpClientBuilder.create().build();
+		    HttpGet get = new HttpGet( urlString);
+		    HttpResponse response = client.execute( get );
+		    int statusCode = response.getStatusLine().getStatusCode();
+			if( statusCode != -1 ) { 
+			    HttpEntity entity = response.getEntity();
+				result = EntityUtils.toString(entity);
 			} else {
-				 // TODO handle error
+				 logger.error(""GET to '{}' failed with status {}"", urlString, statusCode );
 			}
 		} catch( Exception e ) {
-			// TODO handle exception
+		    logger.error(""GET to '{}' failed:"" + e.getMessage(), e );
 		}
 		return result;
 	}
@@ -332,34 +343,56 @@ public class Repository {
 	}
 
 	public String saveNewModel(String newModel, String name, String summary, String type, String stencilset, String svg){
-		String result = """";
-		String url = baseUrl + ""backend/poem/repository/new?stencilset="" + stencilset;
-		try {
-		    HttpClient client = new HttpClient();
-		    PostMethod method = new PostMethod(url);
-			// configure the form parameters
-			method.addParameter(""data"", newModel);
-			method.addParameter(""title"", name);
-			method.addParameter(""summary"", summary);
-			method.addParameter(""type"", type);
-			method.addParameter(""svg"", svg);
-			// execute the POST method
-			int statusCode = client.executeMethod(method);
-			if(statusCode != -1) {
-				Header header = method.getResponseHeader(""location"");
-				result = header.getValue();
-				// hack for reverse proxies:
-				result = result.substring(result.lastIndexOf(""http://""));
+	    String result = """";
+
+	    // setup 
+	    String url = baseUrl + ""backend/poem/repository/new?stencilset="" + stencilset;
+	    HttpClient client = HttpClientBuilder.create().build();
 
-				if (result.startsWith(baseUrl)){
-					result = result.substring(baseUrl.length());
+	    // configure the form parameters
+	    List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+	    formParams.add(new BasicNameValuePair(""data"", newModel));
+	    formParams.add(new BasicNameValuePair(""title"", name));
+	    formParams.add(new BasicNameValuePair(""summary"", summary));
+	    formParams.add(new BasicNameValuePair(""type"", type));
+	    formParams.add(new BasicNameValuePair(""svg"", svg));
+	    UrlEncodedFormEntity formEntity;
+
+	    try {
+	        formEntity = new UrlEncodedFormEntity(formParams);
+	    } catch( UnsupportedEncodingException uee ) {
+	        logger.error(""Could not encode authentication parameters into request body"", uee);
+	        return result;
+	    }
+
+	    // create POST method and add form 
+	    HttpPost post = new HttpPost( url);
+	    post.setEntity(formEntity);
+	    
+	    try {
+	        // execute the POST method
+	        HttpResponse response = client.execute( post );
+            int statusCode = response.getStatusLine().getStatusCode();
+            if( statusCode != -1 ) { 
+                Header [] headers = response.getHeaders(""location"");
+				if( headers.length > 0 ) { 
+				    result = headers[0].getValue();
+				    // hack for reverse proxies:
+				    result = result.substring(result.lastIndexOf(""http://""));
+				    if (result.startsWith(baseUrl)){
+				        result = result.substring(baseUrl.length());
+				    }
+				} else {
+				    logger.error(""GET to '{}' failed with status {}"", url, statusCode );
 				}
-			} else {
-				// TODO handle error
-			}
-		} catch( Exception e ) {
-			e.printStackTrace();
-		}
+            } 
+            else { 
+               logger.error( ""POST to [{}] resulted in status code {} "", url, statusCode);
+            }
+		} catch( Exception e ) { 
+		    logger.error(""POST to ["" + url + ""] failed: "" + e.getMessage(), e );
+		} 
+			
 		return result;
 	}
 	
@@ -390,27 +423,33 @@ public class Repository {
 		}
 		String modelTagsUrl = modelUrl + ""/tags"";
 
-		HttpClient client = new HttpClient();
-	    PostMethod method = new PostMethod(modelTagsUrl);
+		HttpClient client = HttpClientBuilder.create().build();
+		HttpPost post = new HttpPost(modelTagsUrl);
 	    
 		// configure the form parameters
-		method.addParameter(""tag_name"", tagName);
+        List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+        formParams.add(new BasicNameValuePair(""tag_name"", tagName));
+        UrlEncodedFormEntity formEntity;
+
+        try {
+            formEntity = new UrlEncodedFormEntity(formParams);
+        } catch( UnsupportedEncodingException uee ) {
+            logger.error(""Could not encode authentication parameters into request body"", uee);
+            return;
+        }
 
 		// execute the POST method
 		int statusCode;
 		try {
-			statusCode = client.executeMethod(method);
+			HttpResponse response = client.execute(post);
+			statusCode = response.getStatusLine().getStatusCode();
 			if (statusCode != -1) {
-				// TODO return result
+				// TODO return result 
 			} else {
-				// TODO handle error
+			    logger.error( ""POST to ["" + modelTagsUrl + ""] failed with status code "" + statusCode );
 			}
-		} catch (HttpException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
+		} catch (Exception e) {
+			logger.error( ""POST to ["" + modelTagsUrl + ""] failed: "" + e.getMessage(), e );
 		}
 	}
 	
",1,java,123.0,Repository.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,droolsjbpm/jbpm-designer,test,"@@ -2,18 +2,33 @@ package org.jbpm.designer.server.service;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.util.*;
-import javax.annotation.PostConstruct;
+import java.net.MalformedURLException;
+import java.net.Socket;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
 import javax.enterprise.context.ApplicationScoped;
 import javax.enterprise.event.Event;
 import javax.enterprise.inject.Instance;
 import javax.inject.Inject;
 
 import org.apache.commons.codec.binary.Base64;
-import org.apache.commons.httpclient.HttpClient;
-import org.apache.commons.httpclient.NameValuePair;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.protocol.Protocol;
+import org.apache.http.HttpEntity;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.DefaultBHttpClientConnection;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.util.EntityUtils;
 import org.jboss.errai.bus.server.annotations.Service;
 import org.jbpm.designer.repository.Asset;
 import org.jbpm.designer.repository.AssetBuilderFactory;
@@ -22,9 +37,10 @@ import org.jbpm.designer.repository.UriUtils;
 import org.jbpm.designer.repository.impl.AssetBuilder;
 import org.jbpm.designer.service.BPMN2DataServices;
 import org.jbpm.designer.service.DesignerAssetService;
-import org.jbpm.designer.util.OSProtocolSocketFactory;
 import org.jbpm.designer.util.Utils;
 import org.json.JSONArray;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.uberfire.backend.server.util.Paths;
 import org.uberfire.backend.vfs.Path;
 import org.uberfire.mvp.PlaceRequest;
@@ -35,6 +51,8 @@ import org.uberfire.workbench.events.ResourceOpenedEvent;
 @ApplicationScoped
 public class DefaultDesignerAssetService implements DesignerAssetService {
 
+    private static Logger logger = LoggerFactory.getLogger(DefaultDesignerAssetService.class);
+
     @Inject
     private Repository repository;
     
@@ -46,6 +64,9 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
 
     @Inject
     private Event<ResourceOpenedEvent> resourceOpenedEvent;
+   
+    // socket buffer size in bytes: can be tuned for performance
+    private final static int socketBufferSize = 8 * 1024;
 
     public static final String PROCESS_STUB = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?> \n"" +
     ""<bpmn2:definitions xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" xmlns=\""http://www.omg.org/bpmn20\"" xmlns:bpmn2=\""http://www.omg.org/spec/BPMN/20100524/MODEL\"" xmlns:bpmndi=\""http://www.omg.org/spec/BPMN/20100524/DI\"" xmlns:bpsim=\""http://www.bpsim.org/schemas/1.0\"" xmlns:dc=\""http://www.omg.org/spec/DD/20100524/DC\"" xmlns:drools=\""http://www.jboss.org/drools\"" \n"" +
@@ -63,11 +84,6 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
     ""</bpmn2:definitions>"";
 
 
-    @PostConstruct
-    public void configure() {
-        Protocol.registerProtocol(""http"", new Protocol(""http"", new OSProtocolSocketFactory(), 80));
-    }
-
     @Override
     public Map<String, String> getEditorParameters( final Path path,
                                   final String editorID,
@@ -132,9 +148,6 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
         resourceOpenedEvent.fire(new ResourceOpenedEvent( path, sessionInfo ));
 
         return editorParamsMap;
-//        String editorURL = hostInfo + ""/editor/?uuid="" + path.toURI() + ""&profile=jbpm&pp=&editorid="" + editorID + ""&readonly="" + readOnly +
-//                ""&activenodes="" + encodedActiveNodesParam + ""&completednodes="" + encodedCompletedNodesParam;
-//        return getEditorResponse( editorURL, encodedProcessSource );
     }
 
     @Override
@@ -163,31 +176,74 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
 
     private String getEditorResponse( String urlpath,
                                       String encProcessSrc ) {
-        HttpClient httpclient = new HttpClient();
-
-        PostMethod authMethod = new PostMethod( urlpath );
-        NameValuePair[] data = { new NameValuePair( ""j_username"", ""admin"" ),
-                new NameValuePair( ""j_password"", ""admin"" ) };
-        authMethod.setRequestBody( data );
+        CloseableHttpClient httpClient = HttpClientBuilder.create().build();
+    
+        // convert string to url in order to get host and port
+        URL url;
+        try { 
+            url = new URL(urlpath);
+        } catch( MalformedURLException murle ) { 
+            logger.error( ""Incorrect URL: "" + murle.getMessage(), murle );
+            return null;
+        }
+       
+        // configure socket to ignore local addresses (this constructur instead of full constructor)
+        Socket socket;
         try {
-            httpclient.executeMethod( authMethod );
-        } catch ( IOException e ) {
+            socket = new Socket(url.getHost(), url.getPort());
+        DefaultBHttpClientConnection conn = new DefaultBHttpClientConnection(socketBufferSize);
+        conn.bind(socket);
+        } catch( Exception  e ) {
             e.printStackTrace();
+        }
+      
+        // TODO: tiho, if it's possible to do preemptive basic authentication here (which it is?, I think?), please let me know. 
+        // Then you can do everything in one request, which will improve performance.. :) -- mriet
+       
+        // setup form authentication
+        List<NameValuePair> formParams = new ArrayList<NameValuePair>(2);
+        formParams.add(new BasicNameValuePair(""j_username"", ""admin""));
+        formParams.add(new BasicNameValuePair(""j_password"", ""admin""));
+        UrlEncodedFormEntity formEntity;
+        try {
+            formEntity = new UrlEncodedFormEntity(formParams);
+        } catch( UnsupportedEncodingException uee ) {
+            logger.error(""Could not encode authentication parameters into request body"", uee);
+            return null;
+        }
+       
+        // do form authentication
+        HttpPost authMethod = new HttpPost(urlpath);
+        authMethod.setEntity(formEntity);
+        try {
+            httpClient.execute(authMethod);
+        } catch (IOException ioe) {
+            logger.error(""Could not initialize form-based authentication"", ioe);
             return null;
         } finally {
             authMethod.releaseConnection();
         }
-
-        PostMethod theMethod = new PostMethod( urlpath );
-        theMethod.setParameter( ""processsource"", encProcessSrc );
-        StringBuffer sb = new StringBuffer();
+       
+        // create post method and add query parameter
+        HttpPost theMethod = new HttpPost( urlpath );
+        BasicHttpParams params = new BasicHttpParams();
+        params.setParameter( ""processsource"", encProcessSrc );
+        theMethod.setParams(params);
+        
+        // execute post method and return response content
         try {
-            httpclient.executeMethod( theMethod );
-            sb.append( theMethod.getResponseBodyAsString() );
-            return sb.toString();
-
+            // post
+            CloseableHttpResponse response = httpClient.execute( theMethod );
+            
+            // extract content
+            HttpEntity respEntity = response.getEntity();
+            String responseBody = null;
+            if( respEntity != null ) { 
+                responseBody = EntityUtils.toString(respEntity);
+            }
+            return responseBody;
         } catch ( Exception e ) {
-            e.printStackTrace();
+            logger.error(""Could not do POST method and retrieve content: "" + e.getMessage(), e);
             return null;
         } finally {
             theMethod.releaseConnection();
@@ -200,9 +256,9 @@ public class DefaultDesignerAssetService implements DesignerAssetService {
             location = location.replaceFirst( ""/"", """" );
         }
         location = location.replaceAll( ""/"", ""."" );
-
+            
         if(location.length() > 0) {
-            String[] locationParts = location.split(""\\."");
+       String[] locationParts = location.split(""\\."");
             location = locationParts[0];
         }
 
",1,java,91.0,DefaultDesignerAssetService.java
bfc2426ec068dfe3cc551777b843842f1ebd6bcf,droolsjbpm/jbpm-designer,test,"@@ -1,63 +0,0 @@
-package org.jbpm.designer.util;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-
-import org.apache.commons.httpclient.ConnectTimeoutException;
-import org.apache.commons.httpclient.params.HttpConnectionParams;
-import org.apache.commons.httpclient.protocol.ProtocolSocketFactory;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class OSProtocolSocketFactory implements ProtocolSocketFactory {
-
-    private static Logger log = LoggerFactory.getLogger(OSProtocolSocketFactory.class);
-
-    public OSProtocolSocketFactory() {
-    }
-
-    @Override
-    public Socket createSocket(String host,
-                               int port,
-                               InetAddress localAddress,
-                               int localPort) throws IOException, UnknownHostException {
-        if (log.isDebugEnabled()) {
-            log.debug(""createSocket called. host = "" + host + "", port = "" + port
-                    + "", ignoring localAddress = "" + ((localAddress != null) ? localAddress.toString() : ""null"")
-                    + "", ignoring localPort = "" + localPort);
-        }
-
-        Socket socket = null;
-        try {
-            socket = new Socket(host, port);
-            log.debug(""Socket created"");
-        }
-        catch (IOException e) {
-            log.error(""Error creating socket: "" + e.getMessage());
-            throw e;
-        }
-        return socket;
-    }
-
-    @Override
-    public Socket createSocket(String host, int port, InetAddress localAddress,
-                               int localPort, HttpConnectionParams params) throws IOException,
-            UnknownHostException, ConnectTimeoutException {
-
-        log.debug(""createSocket called with HttpConnectionParams -- ignoring the timeout value and proceeding"");
-
-        return this.createSocket(host, port, localAddress, localPort);
-    }
-
-    @Override
-    public Socket createSocket(String host, int port) throws IOException,
-            UnknownHostException,IOException {
-
-        log.debug(""createSocket called with just host and port. proceeding.."");
-
-        return this.createSocket(host, port, null, 0);
-    }
-
-}
\ No newline at end of file
",1,java,50.0,OSProtocolSocketFactory.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -27,21 +27,21 @@ import javax.servlet.http.HttpServletResponse;
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.core.Ordered;
-import org.springframework.web.HttpRequestHandler;
-import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
-import org.springframework.web.cors.CorsProcessor;
-import org.springframework.web.cors.CorsConfiguration;
-import org.springframework.web.cors.CorsConfigurationSource;
 import org.springframework.util.AntPathMatcher;
 import org.springframework.util.Assert;
 import org.springframework.util.PathMatcher;
+import org.springframework.web.HttpRequestHandler;
 import org.springframework.web.context.request.WebRequestInterceptor;
 import org.springframework.web.context.support.WebApplicationObjectSupport;
+import org.springframework.web.cors.CorsConfiguration;
+import org.springframework.web.cors.CorsConfigurationSource;
+import org.springframework.web.cors.CorsProcessor;
+import org.springframework.web.cors.CorsUtils;
+import org.springframework.web.cors.DefaultCorsProcessor;
+import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
 import org.springframework.web.servlet.HandlerExecutionChain;
 import org.springframework.web.servlet.HandlerInterceptor;
 import org.springframework.web.servlet.HandlerMapping;
-import org.springframework.web.cors.DefaultCorsProcessor;
-import org.springframework.web.cors.CorsUtils;
 import org.springframework.web.util.UrlPathHelper;
@@ -471,7 +471,7 @@ public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport
 	}
-	private class PreFlightHandler implements HttpRequestHandler {
+	private class PreFlightHandler implements HttpRequestHandler, CorsConfigurationSource {
 		private final CorsConfiguration config;
@@ -485,10 +485,15 @@ public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport
 			corsProcessor.processRequest(this.config, request, response);
 		}
+
+		@Override
+		public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
+			return this.config;
+		}
 	}
-	private class CorsInterceptor extends HandlerInterceptorAdapter {
+	private class CorsInterceptor extends HandlerInterceptorAdapter implements CorsConfigurationSource {
 		private final CorsConfiguration config;
@@ -502,6 +507,11 @@ public abstract class AbstractHandlerMapping extends WebApplicationObjectSupport
 			return corsProcessor.processRequest(this.config, request, response);
 		}
+
+		@Override
+		public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
+			return this.config;
+		}
 	}
 }",1,java,26.0,AbstractHandlerMapping.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -30,6 +30,8 @@ import org.springframework.util.Assert;
 import org.springframework.util.CollectionUtils;
 import org.springframework.web.servlet.HandlerExecutionChain;
 import org.springframework.web.servlet.HandlerMapping;
+import org.springframework.web.servlet.support.MatchableHandlerMapping;
+import org.springframework.web.servlet.support.RequestMatchResult;
@@ -50,7 +52,8 @@ import org.springframework.web.servlet.HandlerMapping;
-public abstract class AbstractUrlHandlerMapping extends AbstractHandlerMapping {
+public abstract class AbstractUrlHandlerMapping extends AbstractHandlerMapping
+		implements MatchableHandlerMapping {
 	private Object rootHandler;
@@ -279,6 +282,20 @@ public abstract class AbstractUrlHandlerMapping extends AbstractHandlerMapping {
 		request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, uriTemplateVariables);
 	}
+	@Override
+	public RequestMatchResult match(HttpServletRequest request, String pattern) {
+		String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
+		if (getPathMatcher().match(pattern, lookupPath)) {
+			return new RequestMatchResult(pattern, lookupPath, getPathMatcher());
+		}
+		else if (useTrailingSlashMatch()) {
+			if (!pattern.endsWith(""/"") && getPathMatcher().match(pattern + ""/"", lookupPath)) {
+				return new RequestMatchResult(pattern + ""/"", lookupPath, getPathMatcher());
+			}
+		}
+		return null;
+	}
+",1,java,18.0,AbstractUrlHandlerMapping.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -20,6 +20,8 @@ import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Set;
+import javax.servlet.http.HttpServletRequest;
 import org.springframework.context.EmbeddedValueResolverAware;
 import org.springframework.core.annotation.AnnotatedElementUtils;
@@ -38,6 +40,8 @@ import org.springframework.web.servlet.mvc.condition.CompositeRequestCondition;
 import org.springframework.web.servlet.mvc.condition.RequestCondition;
 import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
 import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;
+import org.springframework.web.servlet.support.MatchableHandlerMapping;
+import org.springframework.web.servlet.support.RequestMatchResult;
@@ -50,7 +54,7 @@ import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMappi
 public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping
-		implements EmbeddedValueResolverAware {
+		implements EmbeddedValueResolverAware, MatchableHandlerMapping {
 	private boolean useSuffixPatternMatch = true;
@@ -274,6 +278,18 @@ public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMappi
 		}
 	}
+	@Override
+	public RequestMatchResult match(HttpServletRequest request, String pattern) {
+		RequestMappingInfo info = RequestMappingInfo.paths(pattern).options(this.config).build();
+		RequestMappingInfo matchingInfo = info.getMatchingCondition(request);
+		if (matchingInfo == null) {
+			return null;
+		}
+		Set<String> patterns = matchingInfo.getPatternsCondition().getPatterns();
+		String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
+		return new RequestMatchResult(patterns.iterator().next(), lookupPath, getPathMatcher());
+	}
+
 	@Override
 	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mappingInfo) {
 		HandlerMethod handlerMethod = createHandlerMethod(handler, method);",1,java,17.0,RequestMappingHandlerMapping.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -0,0 +1,192 @@
+/*
+ * Copyright 2002-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.web.servlet.support;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+
+import org.springframework.beans.factory.BeanFactoryUtils;
+import org.springframework.context.ApplicationContext;
+import org.springframework.core.annotation.AnnotationAwareOrderComparator;
+import org.springframework.core.io.ClassPathResource;
+import org.springframework.core.io.Resource;
+import org.springframework.core.io.support.PropertiesLoaderUtils;
+import org.springframework.util.ClassUtils;
+import org.springframework.util.StringUtils;
+import org.springframework.web.cors.CorsConfiguration;
+import org.springframework.web.cors.CorsConfigurationSource;
+import org.springframework.web.servlet.DispatcherServlet;
+import org.springframework.web.servlet.HandlerExecutionChain;
+import org.springframework.web.servlet.HandlerInterceptor;
+import org.springframework.web.servlet.HandlerMapping;
+
+/**
+ * Helper class to get information from the {@code HandlerMapping} that would
+ * serve a specific request.
+ *
+ * <p>Provides the following methods:
+ * <ul>
+ * <li>{@link #getMatchableHandlerMapping} -- obtain a {@code HandlerMapping}
+ * to check request-matching criteria against.
+ * <li>{@link #getCorsConfiguration} -- obtain the CORS configuration for the
+ * request.
+ * </ul>
+ *
+ * @author Rossen Stoyanchev
+ * @since 4.3
+ */
+public class HandlerMappingIntrospector implements CorsConfigurationSource {
+
+	private final List<HandlerMapping> handlerMappings;
+
+
+	/**
+	 * Constructor that detects the configured {@code HandlerMapping}s in the
+	 * given {@code ApplicationContext} or falling back on
+	 * ""DispatcherServlet.properties"" like the {@code DispatcherServlet}.
+	 */
+	public HandlerMappingIntrospector(ApplicationContext context) {
+		this.handlerMappings = initHandlerMappings(context);
+	}
+
+
+	private static List<HandlerMapping> initHandlerMappings(ApplicationContext context) {
+
+		Map<String, HandlerMapping> beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(
+				context, HandlerMapping.class, true, false);
+
+		if (!beans.isEmpty()) {
+			List<HandlerMapping> mappings = new ArrayList<HandlerMapping>(beans.values());
+			AnnotationAwareOrderComparator.sort(mappings);
+			return mappings;
+		}
+
+		return initDefaultHandlerMappings(context);
+	}
+
+	private static List<HandlerMapping> initDefaultHandlerMappings(ApplicationContext context) {
+		Properties props;
+		String path = ""DispatcherServlet.properties"";
+		try {
+			Resource resource = new ClassPathResource(path, DispatcherServlet.class);
+			props = PropertiesLoaderUtils.loadProperties(resource);
+		}
+		catch (IOException ex) {
+			throw new IllegalStateException(""Could not load '"" + path + ""': "" + ex.getMessage());
+		}
+
+		String value = props.getProperty(HandlerMapping.class.getName());
+		String[] names = StringUtils.commaDelimitedListToStringArray(value);
+		List<HandlerMapping> result = new ArrayList<HandlerMapping>(names.length);
+		for (String name : names) {
+			try {
+				Class<?> clazz = ClassUtils.forName(name, DispatcherServlet.class.getClassLoader());
+				Object mapping = context.getAutowireCapableBeanFactory().createBean(clazz);
+				result.add((HandlerMapping) mapping);
+			}
+			catch (ClassNotFoundException ex) {
+				throw new IllegalStateException(""Could not find default HandlerMapping ["" + name + ""]"");
+			}
+		}
+		return result;
+	}
+
+
+	/**
+	 * Return the configured HandlerMapping's.
+	 */
+	public List<HandlerMapping> getHandlerMappings() {
+		return this.handlerMappings;
+	}
+
+
+	/**
+	 * Find the {@link HandlerMapping} that would handle the given request and
+	 * return it as a {@link MatchableHandlerMapping} that can be used to
+	 * test request-matching criteria. If the matching HandlerMapping is not an
+	 * instance of {@link MatchableHandlerMapping}, an IllegalStateException is
+	 * raised.
+	 *
+	 * @param request the current request
+	 * @return the resolved matcher, or {@code null}
+	 * @throws Exception if any of the HandlerMapping's raise an exception
+	 */
+	public MatchableHandlerMapping getMatchableHandlerMapping(HttpServletRequest request) throws Exception {
+		HttpServletRequest wrapper = new RequestAttributeChangeIgnoringWrapper(request);
+		for (HandlerMapping handlerMapping : this.handlerMappings) {
+			Object handler = handlerMapping.getHandler(wrapper);
+			if (handler == null) {
+				continue;
+			}
+			if (handlerMapping instanceof MatchableHandlerMapping) {
+				return ((MatchableHandlerMapping) handlerMapping);
+			}
+			throw new IllegalStateException(""HandlerMapping is not a MatchableHandlerMapping"");
+		}
+		return null;
+	}
+
+	@Override
+	public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
+		HttpServletRequest wrapper = new RequestAttributeChangeIgnoringWrapper(request);
+		for (HandlerMapping handlerMapping : this.handlerMappings) {
+			HandlerExecutionChain handler = null;
+			try {
+				handler = handlerMapping.getHandler(wrapper);
+			}
+			catch (Exception ex) {
+				// Ignore
+			}
+			if (handler == null) {
+				continue;
+			}
+			if (handler.getInterceptors() != null) {
+				for (HandlerInterceptor interceptor : handler.getInterceptors()) {
+					if (interceptor instanceof CorsConfigurationSource) {
+						return ((CorsConfigurationSource) interceptor).getCorsConfiguration(wrapper);
+					}
+				}
+			}
+			if (handler.getHandler() instanceof CorsConfigurationSource) {
+				return ((CorsConfigurationSource) handler.getHandler()).getCorsConfiguration(wrapper);
+			}
+		}
+		return null;
+	}
+
+
+	/**
+	 * Request wrapper that ignores request attribute changes.
+	 */
+	private static class RequestAttributeChangeIgnoringWrapper extends HttpServletRequestWrapper {
+
+
+		private RequestAttributeChangeIgnoringWrapper(HttpServletRequest request) {
+			super(request);
+		}
+
+		@Override
+		public void setAttribute(String name, Object value) {
+			// Ignore attribute change
+		}
+	}
+
+}
\ No newline at end of file",1,java,115.0,HandlerMappingIntrospector.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -0,0 +1,41 @@
+/*
+ * Copyright 2002-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.web.servlet.support;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.springframework.web.servlet.HandlerMapping;
+
+/**
+ * Additional interface that a {@link HandlerMapping} can implement to expose
+ * a request matching API aligned with its internal request matching
+ * configuration and implementation.
+ *
+ * @author Rossen Stoyanchev
+ * @since 4.3
+ * @see HandlerMappingIntrospector
+ */
+public interface MatchableHandlerMapping {
+
+	/**
+	 * Whether the given request matches the request criteria.
+	 * @param request the current request
+	 * @param pattern the pattern to match
+	 * @return the result from request matching or {@code null}
+	 */
+	RequestMatchResult match(HttpServletRequest request, String pattern);
+
+}",1,java,7.0,MatchableHandlerMapping.java
a30ab30e4e9ae021fdda04e9abfc228476b846b5,spring-projects/spring-framework,test,"@@ -0,0 +1,77 @@
+/*
+ * Copyright 2002-2016 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.web.servlet.support;
+
+import java.util.Collections;
+import java.util.Map;
+
+import org.springframework.util.Assert;
+import org.springframework.util.PathMatcher;
+
+/**
+ * Container for the result from request pattern matching via
+ * {@link MatchableHandlerMapping} with a method to further extract URI template
+ * variables from the pattern.
+ *
+ * @author Rossen Stoyanchev
+ * @since 4.3
+ */
+public class RequestMatchResult {
+
+	private final String matchingPattern;
+
+	private final String lookupPath;
+
+	private final PathMatcher pathMatcher;
+
+
+	/**
+	 * Create an instance with a matching pattern.
+	 * @param matchingPattern the matching pattern, possibly not the same as the
+	 * input pattern, e.g. inputPattern=""/foo"" and matchingPattern=""/foo/"".
+	 * @param lookupPath the lookup path extracted from the request
+	 * @param pathMatcher the PathMatcher used
+	 */
+	public RequestMatchResult(String matchingPattern, String lookupPath, PathMatcher pathMatcher) {
+		Assert.hasText(matchingPattern, ""'matchingPattern' is required"");
+		Assert.hasText(lookupPath, ""'lookupPath' is required"");
+		Assert.notNull(pathMatcher, ""'pathMatcher' is required"");
+		this.matchingPattern = matchingPattern;
+		this.lookupPath = lookupPath;
+		this.pathMatcher = pathMatcher;
+	}
+
+
+	/**
+	 * Whether the pattern was matched to the request.
+	 */
+	public boolean isMatch() {
+		return (this.matchingPattern != null);
+	}
+
+	/**
+	 * Extract URI template variables from the matching pattern as defined in
+	 * {@link PathMatcher#extractUriTemplateVariables}.
+	 * @return a map with URI template variables
+	 */
+	public Map<String, String> extractUriTemplateVariables() {
+		if (!isMatch()) {
+			return Collections.<String, String>emptyMap();
+		}
+		return this.pathMatcher.extractUriTemplateVariables(this.matchingPattern, this.lookupPath);
+	}
+
+}",1,java,28.0,RequestMatchResult.java
ea2060f5ae7368a693f2099878ec24410aa75d77,jooby-project/jooby,val,"@@ -23,21 +23,24 @@ import static java.util.Objects.requireNonNull;
 import java.io.File;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Locale.LanguageRange;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
-import java.util.Set;
 import java.util.function.BiFunction;
+import java.util.function.BinaryOperator;
+import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 
 import org.jooby.Cookie;
+import org.jooby.Env;
 import org.jooby.Err;
 import org.jooby.MediaType;
 import org.jooby.Mutant;
@@ -53,7 +56,6 @@ import org.jooby.spi.NativeRequest;
 import org.jooby.spi.NativeUpload;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.inject.Injector;
 import com.google.inject.Key;
 import com.typesafe.config.Config;
@@ -166,24 +168,41 @@ public class RequestImpl implements Request {
     return MediaType.matcher(accept()).first(types);
   }
 
+  @Override
+  public Mutant params(final String... xss) {
+    return _params(xss(xss));
+  }
+
   @Override
   public Mutant params() {
-    ImmutableMap.Builder<String, Mutant> params = ImmutableMap.<String, Mutant> builder();
-    Set<String> names = new LinkedHashSet<>();
-    for (Object name : route.vars().keySet()) {
-      if (name instanceof String) {
-        names.add((String) name);
+    return _params(null);
+  }
+
+  private Mutant _params(final Function<String, String> xss) {
+    Map<String, Mutant> params = new HashMap<>();
+    for (Object segment : route.vars().keySet()) {
+      if (segment instanceof String) {
+        String name = (String) segment;
+        params.put(name, _param(name, xss));
       }
     }
-    names.addAll(paramNames());
-    for (String name : names) {
-      params.put(name, param(name));
+    for (String name : paramNames()) {
+      params.put(name, _param(name, xss));
     }
-    return new MutantImpl(require(ParserExecutor.class), params.build());
+    return new MutantImpl(require(ParserExecutor.class), params);
+  }
+
+  @Override
+  public Mutant param(final String name, final String... xss) {
+    return _param(name, xss(xss));
   }
 
   @Override
   public Mutant param(final String name) {
+    return _param(name, null);
+  }
+
+  private Mutant _param(final String name, final Function<String, String> xss) {
     Mutant param = this.params.get(name);
     if (param == null) {
       List<NativeUpload> files = Try.of(() -> req.files(name)).getOrElseThrow(
@@ -197,14 +216,8 @@ public class RequestImpl implements Request {
 
         this.params.put(name, param);
       } else {
-        ImmutableList.Builder<String> values = ImmutableList.builder();
-        String pathvar = route.vars().get(name);
-        if (pathvar != null) {
-          values.add(pathvar);
-        }
-        values.addAll(params(name));
         StrParamReferenceImpl paramref = new StrParamReferenceImpl(""parameter"", name,
-            values.build());
+            params(name, xss));
         param = new MutantImpl(require(ParserExecutor.class), paramref);
 
         if (paramref.size() > 0) {
@@ -217,9 +230,24 @@ public class RequestImpl implements Request {
 
   @Override
   public Mutant header(final String name) {
-    requireNonNull(name, ""Header's name is missing."");
+    return _header(name, null);
+  }
+
+  @Override
+  public Mutant header(final String name, final String... xss) {
+    return _header(name, xss(xss));
+  }
+
+  private Mutant _header(final String name, final Function<String, String> xss) {
+    requireNonNull(name, ""Name required."");
+    List<String> headers = req.headers(name);
+    if (xss != null) {
+      headers = headers.stream()
+          .map(xss::apply)
+          .collect(Collectors.toList());
+    }
     return new MutantImpl(require(ParserExecutor.class),
-        new StrParamReferenceImpl(""header"", name, req.headers(name)));
+        new StrParamReferenceImpl(""header"", name, headers));
   }
 
   @Override
@@ -402,10 +430,33 @@ public class RequestImpl implements Request {
     }
   }
 
-  private List<String> params(final String name) {
+  private Function<String, String> xss(final String... xss) {
+    Map<String, Function<String, String>> fn = require(Env.class).xss();
+    BinaryOperator<Function<String, String>> reduce = Function::andThen;
+    return Arrays.asList(xss)
+        .stream()
+        .map(fn::get)
+        .filter(Objects::nonNull)
+        .reduce(Function.identity(), reduce);
+
+  }
+
+  private List<String> params(final String name, final Function<String, String> xss) {
     try {
-      return req.params(name);
-    } catch (Exception ex) {
+      List<String> values = new ArrayList<>();
+      String pathvar = route.vars().get(name);
+      if (pathvar != null) {
+        values.add(pathvar);
+      }
+      values.addAll(req.params(name));
+      if (xss == null) {
+        return values;
+      }
+      for (int i = 0; i < values.size(); i++) {
+        values.set(i, xss.apply(values.get(i)));
+      }
+      return values;
+    } catch (Throwable ex) {
       throw new Err(Status.BAD_REQUEST, ""Parameter '"" + name + ""' resulted in error"", ex);
     }
   }
",1,java,91.0,RequestImpl.java
566a8ddb885f0bef9bc848e60455c0aabbf0c1d3,jenkinsci/jenkins,val,"@@ -30,6 +30,8 @@ import hudson.model.AbstractDescribableImpl;
 import hudson.util.CaseInsensitiveComparator;
 import org.apache.commons.lang.StringUtils;
 import org.jenkinsci.Symbol;
+import org.kohsuke.accmod.Restricted;
+import org.kohsuke.accmod.restrictions.ProtectedExternally;
 import org.kohsuke.stapler.DataBoundConstructor;
 import javax.annotation.Nonnull;
@@ -50,16 +52,32 @@ public abstract class IdStrategy extends AbstractDescribableImpl<IdStrategy> imp
     public static IdStrategy CASE_INSENSITIVE = new CaseInsensitive();
-     * Converts an ID into a name that for use as a filename.
+     * Converts an ID into a name for use as a filename.  The return value must not contain any filesystem unsafe
+     * characters or names. See https://msdn.microsoft.com/en-us/library/aa365247.aspx for information on reserved
+     * names.
-     * @param id the id. Note, this method assumes that the id does not contain any filesystem unsafe characters.
-     * @return the name.
+     * @param id the id.
+     * @return the name.  Must be filesystem safe.
     @Nonnull
     public abstract String filenameOf(@Nonnull String id);
-     * Converts a filename into the corresponding id.
+     * Converts an ID into a name for use as a filename.
+     *
+     * Legacy implementation used only for migrating old style config files to the new implementation.
+     * @param id the id
+     * @return the name
+     */
+    @Nonnull
+    @Restricted(ProtectedExternally.class)
+    public String legacyFilenameOf(@Nonnull String id) {
+        return filenameOf(id);
+    }
+
+
+    /**
+     * Converts a filename into the corresponding id.  This may contain filesystem unsafe characters.
@@ -156,9 +174,142 @@ public abstract class IdStrategy extends AbstractDescribableImpl<IdStrategy> imp
         @Override
         @Nonnull
         public String filenameOf(@Nonnull String id) {
+            if (id.isEmpty() || id.matches(""[a-zA-Z0-9_. @-]+"")) {
+                id = id.toLowerCase(Locale.ENGLISH);
+                switch (id) {
+                    case """":
+                    case ""."":
+                        return ""$002f"";
+                    case "".."":
+                        return ""$002e$002e"";
+                    case ""con"":
+                        return ""$0063on"";
+                    case ""prn"":
+                        return ""$0070rn"";
+                    case ""aux"":
+                        return ""$0061ux"";
+                    case ""nul"":
+                        return ""$006eul"";
+                    case ""com1"":
+                        return ""$0063om1"";
+                    case ""com2"":
+                        return ""$0063om2"";
+                    case ""com3"":
+                        return ""$0063om3"";
+                    case ""com4"":
+                        return ""$0063om4"";
+                    case ""com5"":
+                        return ""$0063om5"";
+                    case ""com6"":
+                        return ""$0063om6"";
+                    case ""com7"":
+                        return ""$0063om7"";
+                    case ""com8"":
+                        return ""$0063om8"";
+                    case ""com9"":
+                        return ""$0063om9"";
+                    case ""lpt1"":
+                        return ""$006cpt1"";
+                    case ""lpt2"":
+                        return ""$006cpt2"";
+                    case ""lpt3"":
+                        return ""$006cpt3"";
+                    case ""lpt4"":
+                        return ""$006cpt4"";
+                    case ""lpt5"":
+                        return ""$006cpt5"";
+                    case ""lpt6"":
+                        return ""$006cpt6"";
+                    case ""lpt7"":
+                        return ""$006cpt7"";
+                    case ""lpt8"":
+                        return ""$006cpt8"";
+                    case ""lpt9"":
+                        return ""$006cpt9"";
+                    default:
+                        if (id.endsWith(""."")) {
+                            return id.substring(0,id.length()-1)+""$002e"";
+                        } else if (id.startsWith(""-"")) {
+                            return ""$002d"" + id.substring(1);
+                        }
+                        return id;
+                }
+            } else {
+                StringBuilder buf = new StringBuilder(id.length() + 16);
+                for (char c : id.toCharArray()) {
+                    if ('a' <= c && c <= 'z') {
+                        buf.append(c);
+                    } else if ('A' <= c && c <= 'Z') {
+                        buf.append(Character.toLowerCase(c));
+                    } else if ('0' <= c && c <= '9') {
+                        buf.append(c);
+                    } else if ('_' == c || '-' == c || ' ' == c || '@' == c || '.' == c) {
+                        buf.append(c);
+                    } else {
+                        buf.append('$');
+                        buf.append(StringUtils.leftPad(Integer.toHexString(c & 0xffff), 4, '0'));
+                    }
+                }
+                return buf.toString();
+            }
+        }
+
+        @Nonnull
+        @Override
+        public String legacyFilenameOf(@Nonnull String id) {
             return id.toLowerCase(Locale.ENGLISH);
         }
+        @Override
+        public String idFromFilename(@Nonnull String filename) {
+            if (filename.matches(""[A-Za-z0-9_. @-]+"")) {
+                return filename.toLowerCase(Locale.ENGLISH);
+            } else {
+                StringBuilder buf = new StringBuilder(filename.length());
+                final char[] chars = filename.toCharArray();
+                for (int i = 0; i < chars.length; i++) {
+                    char c = chars[i];
+                    if ('a' <= c && c <= 'z') {
+                        buf.append(c);
+                    } else if ('A' <= c && c <= 'a') {
+                        buf.append(Character.toLowerCase(c));
+                    } else if ('0' <= c && c <= '9') {
+                        buf.append(c);
+                    } else if ('_' == c || '.' == c || '-' == c || ' ' == c || '@' == c) {
+                        buf.append(c);
+                    } else if (c == '$') {
+                        StringBuilder hex = new StringBuilder(4);
+                        i++;
+                        if (i < chars.length) {
+                            hex.append(chars[i]);
+                        } else {
+                            break;
+                        }
+                        i++;
+                        if (i < chars.length) {
+                            hex.append(chars[i]);
+                        } else {
+                            break;
+                        }
+                        i++;
+                        if (i < chars.length) {
+                            hex.append(chars[i]);
+                        } else {
+                            break;
+                        }
+                        i++;
+                        if (i < chars.length) {
+                            hex.append(chars[i]);
+                        } else {
+                            break;
+                        }
+                        buf.append(Character.valueOf((char)Integer.parseInt(hex.toString(), 16)));
+                    }
+                }
+                return buf.toString();
+            }
+        }
+
@@ -203,7 +354,93 @@ public abstract class IdStrategy extends AbstractDescribableImpl<IdStrategy> imp
         @Override
         @Nonnull
         public String filenameOf(@Nonnull String id) {
-            if (id.matches(""[a-z0-9_. -]+"")) {
+            if (id.isEmpty() || id.matches(""[a-z0-9_. @-]+"")) {
+                switch (id) {
+                    case """":
+                    case ""."":
+                        return ""$002f"";
+                    case "".."":
+                        return ""$002e$002e"";
+                    case ""con"":
+                        return ""$0063on"";
+                    case ""prn"":
+                        return ""$0070rn"";
+                    case ""aux"":
+                        return ""$0061ux"";
+                    case ""nul"":
+                        return ""$006eul"";
+                    case ""com1"":
+                        return ""$0063om1"";
+                    case ""com2"":
+                        return ""$0063om2"";
+                    case ""com3"":
+                        return ""$0063om3"";
+                    case ""com4"":
+                        return ""$0063om4"";
+                    case ""com5"":
+                        return ""$0063om5"";
+                    case ""com6"":
+                        return ""$0063om6"";
+                    case ""com7"":
+                        return ""$0063om7"";
+                    case ""com8"":
+                        return ""$0063om8"";
+                    case ""com9"":
+                        return ""$0063om9"";
+                    case ""lpt1"":
+                        return ""$006cpt1"";
+                    case ""lpt2"":
+                        return ""$006cpt2"";
+                    case ""lpt3"":
+                        return ""$006cpt3"";
+                    case ""lpt4"":
+                        return ""$006cpt4"";
+                    case ""lpt5"":
+                        return ""$006cpt5"";
+                    case ""lpt6"":
+                        return ""$006cpt6"";
+                    case ""lpt7"":
+                        return ""$006cpt7"";
+                    case ""lpt8"":
+                        return ""$006cpt8"";
+                    case ""lpt9"":
+                        return ""$006cpt9"";
+                    default:
+                        if (id.endsWith(""."")) {
+                            return id.substring(0,id.length()-1)+""$002e"";
+                        } else if (id.startsWith(""-"")) {
+                            return ""$002d"" + id.substring(1);
+                        }
+                        return id;
+                }
+            } else {
+                StringBuilder buf = new StringBuilder(id.length() + 16);
+                for (char c : id.toCharArray()) {
+                    if ('a' <= c && c <= 'z') {
+                        buf.append(c);
+                    } else if ('0' <= c && c <= '9') {
+                        buf.append(c);
+                    } else if ('_' == c || '-' == c || ' ' == c || '@' == c || '.' == c) {
+                        buf.append(c);
+                    } else if ('A' <= c && c <= 'Z') {
+                        buf.append('~');
+                        buf.append(Character.toLowerCase(c));
+                    } else {
+                        buf.append('$');
+                        buf.append(StringUtils.leftPad(Integer.toHexString(c & 0xffff), 4, '0'));
+                    }
+                }
+                return buf.toString();
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Nonnull
+        @Override
+        public String legacyFilenameOf(@Nonnull String id) {
+            if (id.matches(""[a-z0-9_. @-]+"")) {
                 return id;
             } else {
                 StringBuilder buf = new StringBuilder(id.length() + 16);",1,java,222.0,IdStrategy.java
ae9ba6cfd32ed80469f162e5e3583e2477862ddf,ctripcorp/apollo,val,"@@ -1,6 +1,7 @@
 package com.ctrip.framework.apollo.core.signature;
 import com.google.common.collect.Maps;
+import com.google.common.net.HttpHeaders;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Map;
@@ -16,7 +17,6 @@
   private static final String AUTHORIZATION_FORMAT = ""Apollo %s:%s"";
   private static final String DELIMITER = ""\n"";
-  public static final String HTTP_HEADER_AUTHORIZATION = ""Authorization"";
   public static final String HTTP_HEADER_TIMESTAMP = ""Timestamp"";
   public static String signature(String timestamp, String pathWithQuery, String secret) {
@@ -32,7 +32,7 @@ public static String signature(String timestamp, String pathWithQuery, String se
     String signature = signature(timestamp, pathWithQuery, secret);
     Map<String, String> headers = Maps.newHashMap();
-    headers.put(HTTP_HEADER_AUTHORIZATION, String.format(AUTHORIZATION_FORMAT, appId, signature));
+    headers.put(HttpHeaders.AUTHORIZATION, String.format(AUTHORIZATION_FORMAT, appId, signature));
     headers.put(HTTP_HEADER_TIMESTAMP, timestamp);
     return headers;
   }",1,java,4.0,apollo-core/src/main/java/com/ctrip/framework/apollo/core/signature/Signature.java
c014f78b148685527c5646b1204cd7f595005afa,bcgit/bc-java,val,"@@ -1,5 +1,6 @@
 package org.bouncycastle.asn1.x509;
 
+import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -15,6 +16,7 @@
 import org.bouncycastle.util.Arrays;
 import org.bouncycastle.util.Integers;
 import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
 
 public class PKIXNameConstraintValidator
     implements NameConstraintValidator
@@ -29,6 +31,8 @@
 
     private Set excludedSubtreesIP = new HashSet();
 
+    private Set excludedSubtreesOtherName = new HashSet();
+
     private Set permittedSubtreesDN;
 
     private Set permittedSubtreesDNS;
@@ -39,6 +43,8 @@
 
     private Set permittedSubtreesIP;
 
+    private Set permittedSubtreesOtherName;
+
     public PKIXNameConstraintValidator()
     {
     }
@@ -54,6 +60,9 @@ public void checkPermitted(GeneralName name)
     {
         switch (name.getTagNo())
         {
+        case GeneralName.otherName:
+            checkPermittedOtherName(permittedSubtreesOtherName, OtherName.getInstance(name.getName()));
+            break;
         case GeneralName.rfc822Name:
             checkPermittedEmail(permittedSubtreesEmail,
                 extractNameAsString(name));
@@ -73,6 +82,9 @@ public void checkPermitted(GeneralName name)
             byte[] ip = ASN1OctetString.getInstance(name.getName()).getOctets();
 
             checkPermittedIP(permittedSubtreesIP, ip);
+            break;
+        default:
+            throw new IllegalStateException(""Unknown tag encountered: "" + name.getTagNo());
         }
     }
 
@@ -88,6 +100,9 @@ public void checkExcluded(GeneralName name)
     {
         switch (name.getTagNo())
         {
+        case GeneralName.otherName:
+            checkExcludedOtherName(excludedSubtreesOtherName, OtherName.getInstance(name.getName()));
+            break;
         case GeneralName.rfc822Name:
             checkExcludedEmail(excludedSubtreesEmail, extractNameAsString(name));
             break;
@@ -106,6 +121,9 @@ public void checkExcluded(GeneralName name)
             byte[] ip = ASN1OctetString.getInstance(name.getName()).getOctets();
 
             checkExcludedIP(excludedSubtreesIP, ip);
+            break;
+        default:
+            throw new IllegalStateException(""Unknown tag encountered: "" + name.getTagNo());
         }
     }
 
@@ -141,8 +159,13 @@ public void intersectPermittedSubtree(GeneralSubtree[] permitted)
             Map.Entry entry = (Map.Entry)it.next();
 
             // go through all subtree groups
-            switch (((Integer)entry.getKey()).intValue())
+            int nameType = ((Integer)entry.getKey()).intValue();
+            switch (nameType)
             {
+            case GeneralName.otherName:
+                permittedSubtreesOtherName = intersectOtherName(permittedSubtreesOtherName,
+                    (Set)entry.getValue());
+                break;
             case GeneralName.rfc822Name:
                 permittedSubtreesEmail = intersectEmail(permittedSubtreesEmail,
                     (Set)entry.getValue());
@@ -162,6 +185,9 @@ public void intersectPermittedSubtree(GeneralSubtree[] permitted)
             case GeneralName.iPAddress:
                 permittedSubtreesIP = intersectIP(permittedSubtreesIP,
                     (Set)entry.getValue());
+                break;
+            default:
+                throw new IllegalStateException(""Unknown tag encountered: "" + nameType);
             }
         }
     }
@@ -170,6 +196,9 @@ public void intersectEmptyPermittedSubtree(int nameType)
     {
         switch (nameType)
         {
+        case GeneralName.otherName:
+            permittedSubtreesOtherName = new HashSet();
+            break;
         case GeneralName.rfc822Name:
             permittedSubtreesEmail = new HashSet();
             break;
@@ -184,6 +213,9 @@ public void intersectEmptyPermittedSubtree(int nameType)
             break;
         case GeneralName.iPAddress:
             permittedSubtreesIP = new HashSet();
+            break;
+        default:
+            throw new IllegalStateException(""Unknown tag encountered: "" + nameType);
         }
     }
 
@@ -198,6 +230,10 @@ public void addExcludedSubtree(GeneralSubtree subtree)
 
         switch (base.getTagNo())
         {
+        case GeneralName.otherName:
+            excludedSubtreesOtherName = unionOtherName(excludedSubtreesOtherName,
+                OtherName.getInstance(base.getName()));
+            break;
         case GeneralName.rfc822Name:
             excludedSubtreesEmail = unionEmail(excludedSubtreesEmail,
                 extractNameAsString(base));
@@ -218,6 +254,8 @@ public void addExcludedSubtree(GeneralSubtree subtree)
             excludedSubtreesIP = unionIP(excludedSubtreesIP, ASN1OctetString
                 .getInstance(base.getName()).getOctets());
             break;
+        default:
+            throw new IllegalStateException(""Unknown tag encountered: "" + base.getTagNo());
         }
     }
 
@@ -228,11 +266,13 @@ public int hashCode()
             + hashCollection(excludedSubtreesEmail)
             + hashCollection(excludedSubtreesIP)
             + hashCollection(excludedSubtreesURI)
+            + hashCollection(excludedSubtreesOtherName)
             + hashCollection(permittedSubtreesDN)
             + hashCollection(permittedSubtreesDNS)
             + hashCollection(permittedSubtreesEmail)
             + hashCollection(permittedSubtreesIP)
-            + hashCollection(permittedSubtreesURI);
+            + hashCollection(permittedSubtreesURI)
+            + hashCollection(permittedSubtreesOtherName);
     }
 
     public boolean equals(Object o)
@@ -247,11 +287,13 @@ public boolean equals(Object o)
             && collectionsAreEqual(constraintValidator.excludedSubtreesEmail, excludedSubtreesEmail)
             && collectionsAreEqual(constraintValidator.excludedSubtreesIP, excludedSubtreesIP)
             && collectionsAreEqual(constraintValidator.excludedSubtreesURI, excludedSubtreesURI)
+            && collectionsAreEqual(constraintValidator.excludedSubtreesOtherName, excludedSubtreesOtherName)
             && collectionsAreEqual(constraintValidator.permittedSubtreesDN, permittedSubtreesDN)
             && collectionsAreEqual(constraintValidator.permittedSubtreesDNS, permittedSubtreesDNS)
             && collectionsAreEqual(constraintValidator.permittedSubtreesEmail, permittedSubtreesEmail)
             && collectionsAreEqual(constraintValidator.permittedSubtreesIP, permittedSubtreesIP)
-            && collectionsAreEqual(constraintValidator.permittedSubtreesURI, permittedSubtreesURI);
+            && collectionsAreEqual(constraintValidator.permittedSubtreesURI, permittedSubtreesURI)
+            && collectionsAreEqual(constraintValidator.permittedSubtreesOtherName, permittedSubtreesOtherName);
     }
 
     public String toString()
@@ -283,6 +325,11 @@ public String toString()
             temp += ""IP:\n"";
             temp += stringifyIPCollection(permittedSubtreesIP) + ""\n"";
         }
+        if (permittedSubtreesOtherName != null)
+        {
+            temp += ""OtherName:\n"";
+            temp += stringifyOtherNameCollection(permittedSubtreesOtherName) + ""\n"";
+        }
         temp += ""excluded:\n"";
         if (!excludedSubtreesDN.isEmpty())
         {
@@ -309,6 +356,11 @@ public String toString()
             temp += ""IP:\n"";
             temp += stringifyIPCollection(excludedSubtreesIP) + ""\n"";
         }
+        if (!excludedSubtreesOtherName.isEmpty())
+        {
+            temp += ""OtherName:\n"";
+            temp += stringifyOtherNameCollection(excludedSubtreesOtherName) + ""\n"";
+        }
         return temp;
     }
 
@@ -474,6 +526,25 @@ else if (withinDNSubtree(subtree, dn))
         }
     }
 
+    private Set intersectOtherName(Set permitted, Set otherNames)
+    {
+        Set intersect = new HashSet(permitted);
+
+        intersect.retainAll(otherNames);
+
+        return intersect;
+    }
+
+
+    private Set unionOtherName(Set permitted, OtherName otherName)
+    {
+        Set union = new HashSet(permitted);
+
+        union.add(otherName);
+
+        return union;
+    }
+
     private Set intersectEmail(Set permitted, Set emails)
     {
         Set intersect = new HashSet();
@@ -774,6 +845,52 @@ private void checkPermittedEmail(Set permitted, String email)
             ""Subject email address is not from a permitted subtree."");
     }
 
+    private void checkPermittedOtherName(Set permitted, OtherName name)
+        throws NameConstraintValidatorException
+    {
+        if (permitted == null)
+        {
+            return;
+        }
+
+        Iterator it = permitted.iterator();
+
+        while (it.hasNext())
+        {
+            OtherName str = ((OtherName)it.next());
+
+            if (otherNameIsConstrained(name, str))
+            {
+                return;
+            }
+        }
+
+        throw new NameConstraintValidatorException(
+            ""Subject OtherName is not from a permitted subtree."");
+    }
+
+    private void checkExcludedOtherName(Set excluded, OtherName name)
+        throws NameConstraintValidatorException
+    {
+        if (excluded.isEmpty())
+        {
+            return;
+        }
+
+        Iterator it = excluded.iterator();
+
+        while (it.hasNext())
+        {
+            OtherName str = OtherName.getInstance(it.next());
+
+            if (otherNameIsConstrained(name, str))
+            {
+                throw new NameConstraintValidatorException(
+                    ""OtherName is from an excluded subtree."");
+            }
+        }
+    }
+
     private void checkExcludedEmail(Set excluded, String email)
         throws NameConstraintValidatorException
     {
@@ -899,6 +1016,16 @@ private boolean isIPConstrained(byte ip[], byte[] constraint)
         return Arrays.areEqual(permittedSubnetAddress, ipSubnetAddress);
     }
 
+    private boolean otherNameIsConstrained(OtherName name, OtherName constraint)
+    {
+        if (constraint.equals(name))
+        {
+            return true;
+        }
+
+        return false;
+    }
+
     private boolean emailIsConstrained(String email, String constraint)
     {
         String sub = email.substring(email.indexOf('@') + 1);
@@ -1887,34 +2014,73 @@ private boolean equals(Object o1, Object o2)
      */
     private String stringifyIP(byte[] ip)
     {
-        String temp = """";
+        StringBuilder temp = new StringBuilder();
         for (int i = 0; i < ip.length / 2; i++)
         {
-            temp += Integer.toString(ip[i] & 0x00FF) + ""."";
+            if (temp.length() > 0)
+            {
+                temp.append(""."");
+            }
+            temp.append(Integer.toString(ip[i] & 0x00FF));
         }
-        temp = temp.substring(0, temp.length() - 1);
-        temp += ""/"";
+
+        temp.append(""/"");
+        boolean first = true;
         for (int i = ip.length / 2; i < ip.length; i++)
         {
-            temp += Integer.toString(ip[i] & 0x00FF) + ""."";
+            if (first)
+            {
+                first = false;
+            }
+            else
+            {
+                temp.append(""."");
+            }
+            temp.append(Integer.toString(ip[i] & 0x00FF));
         }
-        temp = temp.substring(0, temp.length() - 1);
-        return temp;
+
+        return temp.toString();
     }
 
     private String stringifyIPCollection(Set ips)
     {
-        String temp = """";
-        temp += ""["";
+        StringBuilder temp = new StringBuilder();
+        temp.append(""["");
         for (Iterator it = ips.iterator(); it.hasNext(); )
         {
-            temp += stringifyIP((byte[])it.next()) + "","";
+            if (temp.length() > 1)
+            {
+                temp.append("","");
+            }
+            temp.append(stringifyIP((byte[])it.next()));
         }
-        if (temp.length() > 1)
+        temp.append(""]"");
+        return temp.toString();
+    }
+
+    private String stringifyOtherNameCollection(Set otherNames)
+    {
+        StringBuilder temp = new StringBuilder();
+        temp.append(""["");
+        for (Iterator it = otherNames.iterator(); it.hasNext(); )
         {
-            temp = temp.substring(0, temp.length() - 1);
+            if (temp.length() > 1)
+            {
+                temp.append("","");
+            }
+            OtherName name = OtherName.getInstance(it.next());
+            temp.append(name.getTypeID().getId());
+            temp.append("":"");
+            try
+            {
+                temp.append(Hex.toHexString(name.getValue().toASN1Primitive().getEncoded()));
+            }
+            catch (IOException e)
+            {
+                temp.append(e.toString());
+            }
         }
-        temp += ""]"";
-        return temp;
+        temp.append(""]"");
+        return temp.toString();
     }
 }
",1,java,177.0,PKIXNameConstraintValidator.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,val,"@@ -25,7 +25,6 @@ package net.sf.mpxj.conceptdraw;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -36,16 +35,9 @@ import java.util.UUID;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.bind.UnmarshallerHandler;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
 
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLFilter;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.DateRange;
 import net.sf.mpxj.Duration;
@@ -65,6 +57,7 @@ import net.sf.mpxj.ResourceAssignment;
 import net.sf.mpxj.Task;
 import net.sf.mpxj.TimeUnit;
 import net.sf.mpxj.common.AlphanumComparator;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.conceptdraw.schema.Document;
 import net.sf.mpxj.conceptdraw.schema.Document.Calendars.Calendar;
 import net.sf.mpxj.conceptdraw.schema.Document.Calendars.Calendar.ExceptedDays.ExceptedDay;
@@ -99,6 +92,11 @@ public final class ConceptDrawProjectReader extends AbstractProjectReader
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
          m_calendarMap = new HashMap<>();
@@ -113,23 +111,7 @@ public final class ConceptDrawProjectReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         XMLFilter filter = new NamespaceFilter();
-         filter.setParent(xmlReader);
-         UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();
-         filter.setContentHandler(unmarshallerHandler);
-         filter.parse(new InputSource(new InputStreamReader(stream)));
-         Document cdp = (Document) unmarshallerHandler.getResult();
+         Document cdp = (Document) UnmarshalHelper.unmarshal(CONTEXT, stream, new NamespaceFilter());
 
          readProjectProperties(cdp);
          readCalendars(cdp);
",1,java,28.0,ConceptDrawProjectReader.java
14b62aca4764d496813f55a43d050b017e01eb65,pgjdbc/pgjdbc,val,"@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020, PostgreSQL Global Development Group
+ * See the LICENSE file in the project root for more information.
+ */
+
+package org.postgresql.xml;
+
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.sax.SAXTransformerFactory;
+
+public interface PGXmlFactoryFactory {
+  DocumentBuilder newDocumentBuilder() throws ParserConfigurationException;
+
+  TransformerFactory newTransformerFactory();
+
+  SAXTransformerFactory newSAXTransformerFactory();
+
+  XMLInputFactory newXMLInputFactory();
+
+  XMLOutputFactory newXMLOutputFactory();
+
+  XMLReader createXMLReader() throws SAXException;
+}",1,java,18.0,pgjdbc/src/main/java/org/postgresql/xml/PGXmlFactoryFactory.java
413b42f4d770456508585c830cfcde95f9b0e93b,bcgit/bc-java,val,"@@ -5,6 +5,7 @@
 import org.bouncycastle.crypto.DataLengthException;
 import org.bouncycastle.crypto.OutputLengthException;
 import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.util.Arrays;
 import org.bouncycastle.util.Pack;
@@ -415,6 +416,8 @@ private static int subWord(int x)
     private int         C0, C1, C2, C3;
     private boolean     forEncryption;
+    private byte[]      s;
+
     private static final int BLOCK_SIZE = 16;
@@ -440,6 +443,14 @@ public void init(
         {
             WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);
             this.forEncryption = forEncryption;
+            if (forEncryption)
+            {
+                s = Arrays.clone(S);
+            }
+            else
+            {
+                s = Arrays.clone(Si);
+            }
             return;
         }
@@ -578,10 +589,10 @@ private void encryptBlock(int[][] KW)
-        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0];
-        this.C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1];
-        this.C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];
-        this.C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];
+        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[r][0];
+        this.C1 = (s[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[r][1];
+        this.C2 = (s[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];
+        this.C3 = (s[r3&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];
     }
     private void decryptBlock(int[][] KW)
@@ -610,9 +621,9 @@ private void decryptBlock(int[][] KW)
-        this.C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
-        this.C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1];
-        this.C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2];
-        this.C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3];
+        this.C0 = (Si[r0&255]&255) ^ ((s[(r3>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
+        this.C1 = (s[r1&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (s[(r2>>24)&255]<<24) ^ KW[0][1];
+        this.C2 = (s[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[0][2];
+        this.C3 = (Si[r3&255]&255) ^ ((s[(r2>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[0][3];
     }
 }",1,java,26.0,core/src/main/java/org/bouncycastle/crypto/engines/AESEngine.java
82a7b8209fcf56971d12cb10410a38ed632215b,apache/ignite,val,"@@ -17,6 +17,8 @@
 package org.apache.ignite.internal.processors.hadoop.mapreduce;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.IgniteException;
 import org.apache.ignite.internal.client.GridClient;
 import org.apache.ignite.internal.client.GridClientConfiguration;
 import org.apache.ignite.internal.client.GridClientException;
@@ -26,6 +28,8 @@ import org.apache.ignite.internal.client.marshaller.jdk.GridClientJdkMarshaller;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.ignite.lang.IgnitePredicate;
+import org.apache.ignite.marshaller.MarshallerUtils;
 import static org.apache.ignite.internal.client.GridClientProtocol.TCP;
@@ -83,7 +87,17 @@ public class MapReduceClient {
                     cliCfg.setProtocol(TCP);
                     cliCfg.setServers(addrs);
-                    cliCfg.setMarshaller(new GridClientJdkMarshaller());
+
+                    try {
+                        IgnitePredicate<String> clsFilter =
+                            MarshallerUtils.classNameFilter(this.getClass().getClassLoader());
+
+                        cliCfg.setMarshaller(new GridClientJdkMarshaller(clsFilter));
+                    }
+                    catch (IgniteCheckedException e) {
+                        throw new IgniteException(e);
+                    }
+
                     cliCfg.setMaxConnectionIdleTime(24 * 60 * 60 * 1000L); // 1 day.
                     cliCfg.setDaemon(true);",1,java,13.0,MapReduceClient.java
f268ab5a00302a89fd0d55cd58d0448402d209a4,jooby-project/jooby,val,"@@ -128,7 +128,7 @@ public interface DefaultContext extends Context {
     String value = pathMap().get(name);
     return value == null
         ? new MissingValue(name)
-        : new SingleValue(name, UrlParser.decodePath(value));
+        : new SingleValue(name, UrlParser.decodePathSegment(value));
   }
 
   @Override @Nonnull default <T> T path(@Nonnull Reified<T> type) {
",1,java,2.0,DefaultContext.java
20b38856a9cb328b8d2b501ee99c139575083590,AsyncHttpClient/async-http-client,val,"@@ -363,7 +363,7 @@ public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = pipeline();
                 try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
                 } catch (Throwable ex) {
                     abort(cl.future(), ex);
                 }
@@ -386,7 +386,7 @@ public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = pipeline();
                 try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
                 } catch (Throwable ex) {
                     abort(cl.future(), ex);
                 }
@@ -425,14 +425,6 @@ private Channel lookupInCache(URI uri, ConnectionPoolKeyStrategy connectionPoolK
         return null;
     }
-    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
-        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
-        if (sslEngine == null) {
-            sslEngine = SslUtils.getSSLEngine();
-        }
-        return sslEngine;
-    }
-
     private HttpClientCodec createHttpClientCodec() {
         return new HttpClientCodec(httpClientCodecMaxInitialLineLength, httpClientCodecMaxHeaderSize, httpClientCodecMaxChunkSize);
     }
@@ -448,7 +440,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
         } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
             return channel;
         } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
         }
         return channel;
     }
@@ -1392,7 +1384,7 @@ private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOExceptio
         if (isSecure(scheme)) {
             if (p.get(SSL_HANDLER) == null) {
                 p.addFirst(HTTP_HANDLER, createHttpClientCodec());
-                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                p.addFirst(SSL_HANDLER, new SslHandler(SslUtils.getInstance().createClientSSLEngine(config)));
             } else {
                 p.addAfter(SSL_HANDLER, HTTP_HANDLER, createHttpClientCodec());
             }",1,java,15.0,src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
c014f78b148685527c5646b1204cd7f595005afa,bcgit/bc-java,val,"@@ -10,6 +10,7 @@
 import org.bouncycastle.asn1.ASN1TaggedObject;
 import org.bouncycastle.asn1.DEROctetString;
 import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.util.Arrays;
 
 /**
  * The DigestInfo object.
@@ -51,7 +52,7 @@ public DigestInfo(
         AlgorithmIdentifier  algId,
         byte[]               digest)
     {
-        this.digest = digest;
+        this.digest = Arrays.clone(digest);
         this.algId = algId;
     }
 
@@ -71,7 +72,7 @@ public AlgorithmIdentifier getAlgorithmId()
 
     public byte[] getDigest()
     {
-        return digest;
+        return Arrays.clone(digest);
     }
 
     public ASN1Primitive toASN1Primitive()
",1,java,5.0,DigestInfo.java
0d830e8cbe5213968abb1bcb1c816ca2ee00aa53,joniles/mpxj,val,"@@ -39,15 +39,9 @@ import java.util.Set;
 
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
-import javax.xml.bind.Unmarshaller;
 import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.SAXParserFactory;
-import javax.xml.transform.sax.SAXSource;
 
-import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
 
 import net.sf.mpxj.ConstraintType;
 import net.sf.mpxj.DateRange;
@@ -73,6 +67,7 @@ import net.sf.mpxj.TaskType;
 import net.sf.mpxj.TimeUnit;
 import net.sf.mpxj.common.DateHelper;
 import net.sf.mpxj.common.NumberHelper;
+import net.sf.mpxj.common.UnmarshalHelper;
 import net.sf.mpxj.listener.ProjectListener;
 import net.sf.mpxj.planner.schema.Allocation;
 import net.sf.mpxj.planner.schema.Allocations;
@@ -114,6 +109,11 @@ public final class PlannerReader extends AbstractProjectReader
    {
       try
       {
+         if (CONTEXT == null)
+         {
+            throw CONTEXT_EXCEPTION;
+         }
+
          m_projectFile = new ProjectFile();
          m_eventManager = m_projectFile.getEventManager();
 
@@ -129,21 +129,7 @@ public final class PlannerReader extends AbstractProjectReader
 
          m_eventManager.addProjectListeners(m_projectListeners);
 
-         SAXParserFactory factory = SAXParserFactory.newInstance();
-         factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
-         factory.setNamespaceAware(true);
-         SAXParser saxParser = factory.newSAXParser();
-         XMLReader xmlReader = saxParser.getXMLReader();
-         SAXSource doc = new SAXSource(xmlReader, new InputSource(stream));
-
-         if (CONTEXT == null)
-         {
-            throw CONTEXT_EXCEPTION;
-         }
-
-         Unmarshaller unmarshaller = CONTEXT.createUnmarshaller();
-
-         Project plannerProject = (Project) unmarshaller.unmarshal(doc);
+         Project plannerProject = (Project) UnmarshalHelper.unmarshal(CONTEXT, stream);
 
          readProjectProperties(plannerProject);
          readCalendars(plannerProject);
",1,java,24.0,PlannerReader.java
3c9152e2c75f7e8b654beec40383748a14c6b51b,AsyncHttpClient/async-http-client,val,"@@ -0,0 +1,96 @@
+/*
+ * To the extent possible under law, Kevin Locke has waived all copyright and
+ * related or neighboring rights to this work.
+ * <p/>
+ * A legal description of this waiver is available in <a href=""https://gist.github.com/kevinoid/3829665"">LICENSE.txt</a>
+ */
+package org.asynchttpclient.util;
+
+import sun.security.util.HostnameChecker;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.security.auth.kerberos.KerberosPrincipal;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+
+/**
+ * Uses the internal HostnameChecker to verify the server's hostname matches with the
+ * certificate.  This is a requirement for HTTPS, but the raw SSLEngine does not have
+ * this functionality.  As such, it has to be added in manually.  For a more complete
+ * description of hostname verification and why it's important,
+ * please read
+ * <a href=""http://tersesystems.com/2014/03/23/fixing-hostname-verification/"">Fixing
+ * Hostname Verification</a>.
+ * <p/>
+ * This code is based on Kevin Locke's <a href=""http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/"">guide</a> .
+ * <p/>
+
+ */
+public class DefaultHostnameVerifier implements HostnameVerifier {
+
+    private HostnameVerifier extraHostnameVerifier;
+
+    public DefaultHostnameVerifier() {
+    }
+
+    public DefaultHostnameVerifier(HostnameVerifier extraHostnameVerifier) {
+        this.extraHostnameVerifier = extraHostnameVerifier;
+    }
+
+    private boolean hostnameMatches(String hostname, SSLSession session) {
+        HostnameChecker checker =
+                HostnameChecker.getInstance(HostnameChecker.TYPE_TLS);
+
+        boolean validCertificate = false, validPrincipal = false;
+        try {
+            Certificate[] peerCertificates = session.getPeerCertificates();
+
+            if (peerCertificates.length > 0 &&
+                    peerCertificates[0] instanceof X509Certificate) {
+                X509Certificate peerCertificate =
+                        (X509Certificate) peerCertificates[0];
+
+                try {
+                    checker.match(hostname, peerCertificate);
+                    // Certificate matches hostname
+                    validCertificate = true;
+                } catch (CertificateException ex) {
+                    // Certificate does not match hostname
+                }
+            } else {
+                // Peer does not have any certificates or they aren't X.509
+            }
+        } catch (SSLPeerUnverifiedException ex) {
+            // Not using certificates for peers, try verifying the principal
+            try {
+                Principal peerPrincipal = session.getPeerPrincipal();
+                if (peerPrincipal instanceof KerberosPrincipal) {
+                    validPrincipal = HostnameChecker.match(hostname,
+                            (KerberosPrincipal) peerPrincipal);
+                } else {
+                    // Can't verify principal, not Kerberos
+                }
+            } catch (SSLPeerUnverifiedException ex2) {
+                // Can't verify principal, no principal
+            }
+        }
+
+        return validCertificate || validPrincipal;
+    }
+
+    public boolean verify(String hostname, SSLSession session) {
+        if (hostnameMatches(hostname, session)) {
+            return true;
+        } else {
+            if (extraHostnameVerifier != null) {
+                return extraHostnameVerifier.verify(hostname, session);
+            } else {
+                return false;
+            }
+        }
+    }
+}
From fa056c572ab0c9b6edd05a7cc508898f35cc90d5 Mon Sep 17 00:00:00 2001
From: Will Sargent <will.sargent@gmail.com>
Date: Mon, 24 Mar 2014 23:25:44 -0700
Subject: [PATCH 2/3] Use reflection to avoid the ""not part of JDK"" error
 running tests.
---
 .../AsyncHttpClientConfigBean.java            |  8 +-
 .../util/DefaultHostnameVerifier.java         | 73 ++++++++++++++++---
 2 files changed, 65 insertions(+), 16 deletions(-)",1,java,60.0,api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
f268ab5a00302a89fd0d55cd58d0448402d209a4,jooby-project/jooby,val,"@@ -52,7 +52,7 @@ public interface ErrorHandler {
           .append(""<hr>\n"");
 
       if (message != null && !message.equals(statusCode.toString())) {
-        html.append(""<h2>message: "").append(message).append(""</h2>\n"");
+        html.append(""<h2>message: "").append(XSS.html(message)).append(""</h2>\n"");
       }
       html.append(""<h2>status code: "").append(statusCode.value()).append(""</h2>\n"");
 
@@ -67,7 +67,7 @@ public interface ErrorHandler {
       String message = Optional.ofNullable(cause.getMessage()).orElse(statusCode.reason());
       ctx.setResponseType(json)
           .setResponseCode(statusCode)
-          .send(""{\""message\"":\"""" + message + ""\"",\""statusCode\"":"" + statusCode.value()
+          .send(""{\""message\"":\"""" + XSS.json(message) + ""\"",\""statusCode\"":"" + statusCode.value()
               + "",\""reason\"":\"""" + statusCode.reason() + ""\""}"");
     }
   };
",1,java,4.0,ErrorHandler.java
dfacb8e05d0822c7b2024c452554bd8e1d6221d8,AsyncHttpClient/async-http-client,val,"@@ -539,11 +539,6 @@ public Builder setExecutorService(ExecutorService applicationThreadPool) {
             return this;
         }
-        public Builder setSSLEngineFactory(SSLEngineFactory sslEngineFactory) {
-            configBuilder.setSSLEngineFactory(sslEngineFactory);
-            return this;
-        }
-
         public Builder setSSLContext(final SSLContext sslContext) {
             configBuilder.setSSLContext(sslContext);
             return this;
@@ -669,6 +664,11 @@ public Builder setProviderClass(String providerClass) {
             return this;
         }
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            configBuilder.setAcceptAnyCertificate(acceptAnyCertificate);
+            return this;
+        }
+
         public SimpleAsyncHttpClient build() {
             if (realmBuilder != null) {",1,java,8.0,src/main/java/com/ning/http/client/SimpleAsyncHttpClient.java
d2e575fb7410370f2a7fe4c64e3f0a502dc69152,dotCMS/core,val,"@@ -1,6 +1,8 @@
 package com.dotmarketing.portlets.languagesmanager.business;
+import java.util.Collection;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
@@ -279,4 +281,14 @@
     boolean canDefaultFileToDefaultLanguage();
+    /**
+     * Given a collection of Keys, return
+     * a Map of translated values and if those are not found
+     * then return the sent key as the value
+     * @param locale
+     * @param keys
+     * @return
+     */
+    Map<String, String> getStringsAsMap(Locale locale, Collection<String> keys);
+
 }",1,java,4.0,dotCMS/src/main/java/com/dotmarketing/portlets/languagesmanager/business/LanguageAPI.java
